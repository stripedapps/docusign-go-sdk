/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// EnvelopesAPIService EnvelopesAPI service
type EnvelopesAPIService service

type ApiAuditEventsGetAuditEventsRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	envelopeId string
}

func (r ApiAuditEventsGetAuditEventsRequest) Execute() (*EnvelopeAuditEventResponse, *http.Response, error) {
	return r.ApiService.AuditEventsGetAuditEventsExecute(r)
}

/*
AuditEventsGetAuditEvents Gets the envelope audit events for an envelope.

Gets the envelope audit events for the specified envelope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiAuditEventsGetAuditEventsRequest
*/
func (a *EnvelopesAPIService) AuditEventsGetAuditEvents(ctx context.Context, accountId string, envelopeId string) ApiAuditEventsGetAuditEventsRequest {
	return ApiAuditEventsGetAuditEventsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return EnvelopeAuditEventResponse
func (a *EnvelopesAPIService) AuditEventsGetAuditEventsExecute(r ApiAuditEventsGetAuditEventsRequest) (*EnvelopeAuditEventResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeAuditEventResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.AuditEventsGetAuditEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/audit_events"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopesGetEnvelopeRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	envelopeId string
	advancedUpdate *string
	include *string
}

// When **true,** envelope information can be added or modified.
func (r ApiEnvelopesGetEnvelopeRequest) AdvancedUpdate(advancedUpdate string) ApiEnvelopesGetEnvelopeRequest {
	r.advancedUpdate = &advancedUpdate
	return r
}

// Specifies additional information about the envelope to return. Enter a comma-separated list, such as &#x60;tabs,recipients&#x60;. Valid values are:  - &#x60;custom_fields&#x60;: The custom fields associated with the envelope. - &#x60;documents&#x60;: The documents associated with the envelope. - &#x60;attachments&#x60;: The attachments associated with the envelope. - &#x60;extensions&#x60;: The email settings associated with the envelope. - &#x60;folders&#x60;: The folder where the envelope exists. - &#x60;recipients&#x60;: The recipients associated with the envelope. - &#x60;powerform&#x60;: The PowerForms associated with the envelope. - &#x60;tabs&#x60;: The tabs associated with the envelope. - &#x60;payment_tabs&#x60;: The payment tabs associated with the envelope. - &#x60;workflow&#x60;: The workflow definition associated with the envelope. 
func (r ApiEnvelopesGetEnvelopeRequest) Include(include string) ApiEnvelopesGetEnvelopeRequest {
	r.include = &include
	return r
}

func (r ApiEnvelopesGetEnvelopeRequest) Execute() (*Envelope, *http.Response, error) {
	return r.ApiService.EnvelopesGetEnvelopeExecute(r)
}

/*
EnvelopesGetEnvelope Gets the status of a single envelope.

Retrieves the overall status for the specified envelope.
To get the status of a list of envelopes, use
[Envelope: listStatusChanges ](/docs/esign-rest-api/reference/envelopes/envelopes/liststatuschanges/).

### Related topics

- [How to get envelope information](/docs/esign-rest-api/how-to/get-envelope-information/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiEnvelopesGetEnvelopeRequest
*/
func (a *EnvelopesAPIService) EnvelopesGetEnvelope(ctx context.Context, accountId string, envelopeId string) ApiEnvelopesGetEnvelopeRequest {
	return ApiEnvelopesGetEnvelopeRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return Envelope
func (a *EnvelopesAPIService) EnvelopesGetEnvelopeExecute(r ApiEnvelopesGetEnvelopeRequest) (*Envelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Envelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.EnvelopesGetEnvelope")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.advancedUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "advanced_update", r.advancedUpdate, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopesGetEnvelopesRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	acStatus *string
	block *string
	cdseMode *string
	continuationToken *string
	count *string
	customField *string
	email *string
	envelopeIds *string
	exclude *string
	folderIds *string
	folderTypes *string
	fromDate *string
	fromToStatus *string
	include *string
	includePurgeInformation *string
	intersectingFolderIds *string
	lastQueriedDate *string
	order *string
	orderBy *string
	powerformids *string
	queryBudget *string
	requesterDateFormat *string
	searchMode *string
	searchText *string
	startPosition *string
	status *string
	toDate *string
	transactionIds *string
	userFilter *string
	userId *string
	userName *string
}

// Specifies the Authoritative Copy Status for the envelopes. Valid values: Unknown, Original, Transferred, AuthoritativeCopy, AuthoritativeCopyExportPending, AuthoritativeCopyExported, DepositPending, Deposited, DepositedEO, or DepositFailed.
func (r ApiEnvelopesGetEnvelopesRequest) AcStatus(acStatus string) ApiEnvelopesGetEnvelopesRequest {
	r.acStatus = &acStatus
	return r
}

// Reserved for DocuSign. 
func (r ApiEnvelopesGetEnvelopesRequest) Block(block string) ApiEnvelopesGetEnvelopesRequest {
	r.block = &block
	return r
}

// Reserved for DocuSign. 
func (r ApiEnvelopesGetEnvelopesRequest) CdseMode(cdseMode string) ApiEnvelopesGetEnvelopesRequest {
	r.cdseMode = &cdseMode
	return r
}

// Reserved for DocuSign.
func (r ApiEnvelopesGetEnvelopesRequest) ContinuationToken(continuationToken string) ApiEnvelopesGetEnvelopesRequest {
	r.continuationToken = &continuationToken
	return r
}

// The maximum number of results to return.  Use &#x60;start_position&#x60; to specify the number of results to skip. 
func (r ApiEnvelopesGetEnvelopesRequest) Count(count string) ApiEnvelopesGetEnvelopesRequest {
	r.count = &count
	return r
}

// Optional. Specifies an envelope custom field name and value searched for in the envelopes. Format: &#x60;custom_envelope_field_name&#x3D;desired_value&#x60;  Example: If you have an envelope custom field named \&quot;Region\&quot; and you want to search for all envelopes where the value is \&quot;West\&quot; you would use set this parameter to &#x60;Region&#x3D;West&#x60;.    
func (r ApiEnvelopesGetEnvelopesRequest) CustomField(customField string) ApiEnvelopesGetEnvelopesRequest {
	r.customField = &customField
	return r
}

// Limit results to envelopes sent by the account user with this email address.  &#x60;user_name&#x60; must be given as well, and both &#x60;email&#x60; and &#x60;user_name&#x60; must refer to an existing account user. 
func (r ApiEnvelopesGetEnvelopesRequest) Email(email string) ApiEnvelopesGetEnvelopesRequest {
	r.email = &email
	return r
}

// Comma separated list of &#x60;envelopeId&#x60; values.
func (r ApiEnvelopesGetEnvelopesRequest) EnvelopeIds(envelopeIds string) ApiEnvelopesGetEnvelopesRequest {
	r.envelopeIds = &envelopeIds
	return r
}

// Excludes information from the response. Enter  as a comma-separated list (e.g., &#x60;folders,powerforms&#x60;). Valid values are:  - &#x60;recipients&#x60; - &#x60;powerforms&#x60; - &#x60;folders&#x60;
func (r ApiEnvelopesGetEnvelopesRequest) Exclude(exclude string) ApiEnvelopesGetEnvelopesRequest {
	r.exclude = &exclude
	return r
}

// Returns the envelopes from specific folders. Enter as a comma-separated list of either valid folder Guids or the following values:   - &#x60;awaiting_my_signature&#x60; - &#x60;completed&#x60; - &#x60;draft&#x60; - &#x60;drafts&#x60; - &#x60;expiring_soon&#x60; - &#x60;inbox&#x60; - &#x60;out_for_signature&#x60; - &#x60;recyclebin&#x60; - &#x60;sentitems&#x60; - &#x60;waiting_for_others&#x60;
func (r ApiEnvelopesGetEnvelopesRequest) FolderIds(folderIds string) ApiEnvelopesGetEnvelopesRequest {
	r.folderIds = &folderIds
	return r
}

// A comma-separated list of folder types you want to retrieve envelopes from. Valid values are:   - &#x60;normal&#x60; - &#x60;inbox&#x60; - &#x60;sentitems&#x60; - &#x60;draft&#x60; - &#x60;templates&#x60;
func (r ApiEnvelopesGetEnvelopesRequest) FolderTypes(folderTypes string) ApiEnvelopesGetEnvelopesRequest {
	r.folderTypes = &folderTypes
	return r
}

// Specifies the date and time to start looking for status changes. This parameter is required unless &#x60;envelopeIds&#x60; or &#x60;transactionIds&#x60; are set.   Although you can use any date format supported by the .NET system library&#39;s [&#x60;DateTime.Parse()&#x60;][msoft] function, DocuSign recommends using [ISO 8601][] format dates with an explicit time zone offset If you do not provide a time zone offset, the method uses the server&#39;s time zone.  For example, the following dates and times refer to the same instant:  * &#x60;2017-05-02T01:44Z&#x60; * &#x60;2017-05-01T21:44-04:00&#x60; * &#x60;2017-05-01T18:44-07:00&#x60;   [msoft]: https://docs.microsoft.com/en-us/dotnet/api/system.datetime.parse?redirectedfrom&#x3D;MSDN&amp;view&#x3D;net-5.0#overloads [ISO 8601]: https://en.wikipedia.org/wiki/ISO_8601
func (r ApiEnvelopesGetEnvelopesRequest) FromDate(fromDate string) ApiEnvelopesGetEnvelopesRequest {
	r.fromDate = &fromDate
	return r
}

// This is the status type checked for in the &#x60;from_date&#x60;/&#x60;to_date&#x60; period. If &#x60;changed&#x60; is specified, then envelopes that changed status during the period are found. If for example, &#x60;created&#x60; is specified, then envelopes created during the period are found. Default is &#x60;changed&#x60;.   Possible values are: Voided, Changed, Created, Deleted, Sent, Delivered, Signed, Completed, Declined, TimedOut and Processing.
func (r ApiEnvelopesGetEnvelopesRequest) FromToStatus(fromToStatus string) ApiEnvelopesGetEnvelopesRequest {
	r.fromToStatus = &fromToStatus
	return r
}

// Specifies additional information to return  about the envelopes. Use a comma-separated list, such as &#x60;folders, recipients&#x60; to specify information. Valid values are:  - &#x60;custom_fields&#x60;: The custom fields associated with the envelope. - &#x60;documents&#x60;: The documents associated with the envelope. - &#x60;attachments&#x60;: The attachments associated with the envelope. - &#x60;extensions&#x60;: Information about the email settings associated with the envelope. - &#x60;folders&#x60;: The folders where the envelope exists. - &#x60;recipients&#x60;: The recipients associated with the envelope. - &#x60;payment_tabs&#x60;: The payment tabs associated with the envelope. 
func (r ApiEnvelopesGetEnvelopesRequest) Include(include string) ApiEnvelopesGetEnvelopesRequest {
	r.include = &include
	return r
}

// When **true,** information about envelopes that have been deleted is included in the response.
func (r ApiEnvelopesGetEnvelopesRequest) IncludePurgeInformation(includePurgeInformation string) ApiEnvelopesGetEnvelopesRequest {
	r.includePurgeInformation = &includePurgeInformation
	return r
}

// A comma-separated list of folders that you want want to get envelopes from. Valid values are:   - &#x60;normal&#x60; - &#x60;inbox&#x60; - &#x60;sentitems&#x60; - &#x60;draft&#x60; - &#x60;templates&#x60;
func (r ApiEnvelopesGetEnvelopesRequest) IntersectingFolderIds(intersectingFolderIds string) ApiEnvelopesGetEnvelopesRequest {
	r.intersectingFolderIds = &intersectingFolderIds
	return r
}

// Returns envelopes that were modified prior to the specified date and time.   Example: &#x60;2020-05-09T21:56:12.2500000Z&#x60;
func (r ApiEnvelopesGetEnvelopesRequest) LastQueriedDate(lastQueriedDate string) ApiEnvelopesGetEnvelopesRequest {
	r.lastQueriedDate = &lastQueriedDate
	return r
}

// Returns envelopes in either ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;) order.
func (r ApiEnvelopesGetEnvelopesRequest) Order(order string) ApiEnvelopesGetEnvelopesRequest {
	r.order = &order
	return r
}

// Sorts results according to a specific property. Valid values are:  - &#x60;last_modified&#x60; - &#x60;action_required&#x60; - &#x60;created&#x60; - &#x60;completed&#x60; - &#x60;envelope_name&#x60; - &#x60;expire&#x60; - &#x60;sent&#x60; - &#x60;signer_list&#x60; - &#x60;status&#x60; - &#x60;subject&#x60; - &#x60;user_name&#x60; - &#x60;status_changed&#x60; - &#x60;last_modified&#x60;
func (r ApiEnvelopesGetEnvelopesRequest) OrderBy(orderBy string) ApiEnvelopesGetEnvelopesRequest {
	r.orderBy = &orderBy
	return r
}

// A comma-separated list of &#x60;PowerFormId&#x60; values.
func (r ApiEnvelopesGetEnvelopesRequest) Powerformids(powerformids string) ApiEnvelopesGetEnvelopesRequest {
	r.powerformids = &powerformids
	return r
}

// The time in seconds that the query should run before returning data.
func (r ApiEnvelopesGetEnvelopesRequest) QueryBudget(queryBudget string) ApiEnvelopesGetEnvelopesRequest {
	r.queryBudget = &queryBudget
	return r
}

func (r ApiEnvelopesGetEnvelopesRequest) RequesterDateFormat(requesterDateFormat string) ApiEnvelopesGetEnvelopesRequest {
	r.requesterDateFormat = &requesterDateFormat
	return r
}

func (r ApiEnvelopesGetEnvelopesRequest) SearchMode(searchMode string) ApiEnvelopesGetEnvelopesRequest {
	r.searchMode = &searchMode
	return r
}

// Free text search criteria that you can use to filter the list of envelopes that is returned.
func (r ApiEnvelopesGetEnvelopesRequest) SearchText(searchText string) ApiEnvelopesGetEnvelopesRequest {
	r.searchText = &searchText
	return r
}

// The zero-based index of the result from which to start returning results.  Use with &#x60;count&#x60; to limit the number of results.  The default value is &#x60;0&#x60;. 
func (r ApiEnvelopesGetEnvelopesRequest) StartPosition(startPosition string) ApiEnvelopesGetEnvelopesRequest {
	r.startPosition = &startPosition
	return r
}

// A comma-separated list of current envelope statuses to included in the response. Possible values are:  * &#x60;completed&#x60; * &#x60;created&#x60; * &#x60;declined&#x60; * &#x60;deleted&#x60; * &#x60;delivered&#x60; * &#x60;processing&#x60; * &#x60;sent&#x60; * &#x60;signed&#x60; * &#x60;timedout&#x60; * &#x60;voided&#x60;  The &#x60;any&#x60; value is equivalent to any status. 
func (r ApiEnvelopesGetEnvelopesRequest) Status(status string) ApiEnvelopesGetEnvelopesRequest {
	r.status = &status
	return r
}

// Specifies the date and time to stop looking for status changes. The default is the current date and time.  Although you can use any date format supported by the .NET system library&#39;s [&#x60;DateTime.Parse()&#x60;][msoft] function, DocuSign recommends using [ISO 8601][] format dates with an explicit time zone offset If you do not provide a time zone offset, the method uses the server&#39;s time zone.  For example, the following dates and times refer to the same instant:  * &#x60;2017-05-02T01:44Z&#x60; * &#x60;2017-05-01T21:44-04:00&#x60; * &#x60;2017-05-01T18:44-07:00&#x60;   [msoft]: https://docs.microsoft.com/en-us/dotnet/api/system.datetime.parse?redirectedfrom&#x3D;MSDN&amp;view&#x3D;net-5.0#overloads [ISO 8601]: https://en.wikipedia.org/wiki/ISO_8601 
func (r ApiEnvelopesGetEnvelopesRequest) ToDate(toDate string) ApiEnvelopesGetEnvelopesRequest {
	r.toDate = &toDate
	return r
}

// If included in the query string, this is a comma separated list of envelope &#x60;transactionId&#x60;s.   If included in the &#x60;request_body&#x60;, this is a list of envelope &#x60;transactionId&#x60;s.   ###### Note: &#x60;transactionId&#x60;s are only valid in the DocuSign system for seven days. 
func (r ApiEnvelopesGetEnvelopesRequest) TransactionIds(transactionIds string) ApiEnvelopesGetEnvelopesRequest {
	r.transactionIds = &transactionIds
	return r
}

// Returns envelopes where the current user is the recipient, the sender, or the recipient only. (For example, &#x60;user_filter&#x3D;sender&#x60;.) Valid values are:  - &#x60;sender&#x60; - &#x60;recipient&#x60; - &#x60;recipient_only&#x60;
func (r ApiEnvelopesGetEnvelopesRequest) UserFilter(userFilter string) ApiEnvelopesGetEnvelopesRequest {
	r.userFilter = &userFilter
	return r
}

// The ID of the user who created the envelopes to be retrieved. Note that an account can have multiple users, and any user with account access can retrieve envelopes by user_id from the account.
func (r ApiEnvelopesGetEnvelopesRequest) UserId(userId string) ApiEnvelopesGetEnvelopesRequest {
	r.userId = &userId
	return r
}

// Limit results to envelopes sent by the account user with this user name.  &#x60;email&#x60; must be given as well, and both &#x60;email&#x60; and &#x60;user_name&#x60; must refer to an existing account user. 
func (r ApiEnvelopesGetEnvelopesRequest) UserName(userName string) ApiEnvelopesGetEnvelopesRequest {
	r.userName = &userName
	return r
}

func (r ApiEnvelopesGetEnvelopesRequest) Execute() (*EnvelopesInformation, *http.Response, error) {
	return r.ApiService.EnvelopesGetEnvelopesExecute(r)
}

/*
EnvelopesGetEnvelopes Search for specific sets of envelopes by using search filters.

This method lets you
[search for envelopes](/docs/esign-rest-api/esign101/concepts/envelopes/)
in your accounts.
A large set of filters let you narrow the scope of your search
by date,
by envelope ID,
or by status codes.
Your request must include one or more of the following parameters:

* `from_date`
* `envelope_ids`
* `transaction_ids`

<ds-inlinemessage kind="information">
This method excludes envelopes older than six months.
</ds-inlinemessage>

To avoid unnecessary database queries, the DocuSign
signature platform first checks requests to ensure that the
filter set supplied does not result in a zero-size response
before querying the database.

For example, for a request with a `from_to_status` of
`delivered` and a current `status` of `created,sent`,
DocuSign will always return an empty list.
This is because the request translates to: find the
envelopes that were delivered between the `from_date` and
`to_date` dates that have a current status of `created` or
`sent`. Since an envelope that has been delivered can
never have a status of `created` or `sent`, a zero-size
response would be generated.
In this case, DocuSign does not query the database
and returns an empty list immediately.

Getting envelope status using `transaction_ids` is useful
for offline signing situations where it can be used
determine if an envelope was created or not. It can be used
for the cases where a network connection was lost, before
the envelope status could be returned.

The following table shows the valid current envelope
statuses (`status` parameter) for the different status
qualifiers (`from_to_status` parameter) in the request. If
the status and status qualifiers in the API request do not
contain any of the values shown in the Valid Current
Statuses column, then an empty list is returned.

Client applications should check that the statuses (`status`
parameter) they are requesting make sense for a given
`from_to_status` parameter value.

| Status Qualifier<br>(`from_to_status`) | Effective Status Qualifier | Valid Current Statuses                                                      |
| :------------------------------------- | :------------------------- | :-------------------------------------------------------------------------- |
| any (changed)                          | StatusChanged              | any, created, sent, delivered, signed, completed, declined, voided, deleted |
| created                                | Created                    | any, created, sent, delivered, signed, completed, declined, voided, deleted |
| sent                                   | Sent                       | any, sent, delivered, signed, completed, declined, voided, deleted          |
| delivered                              | StatusChanged              | any, delivered, signed, completed, declined, voided, deleted                |
| signed                                 | StatusChanged              | any, signed, completed, declined, voided, deleted                           |
| completed                              | Completed                  | any, completed, declined, voided, deleted                                   |
| declined                               | StatusChanged              | any, declined, voided, deleted                                              |
| timedout<br>always return zero results | StatusChanged              | any, voided, deleted                                                        |
| voided                                 | Voided                     | any, voided, deleted                                                        |
| deleted                                | StatusChanged              | any, deleted                                                                |

## Extraneous results

In some cases, a request for a specific envelope status will
include envelopes with additional statuses. For example, in
a request with a `from_date` of 2017-01-01, a `to_date` of
2017-01-07 and the status qualifier (`from_to_status`) set
to `delivered`, the response set might contain envelopes
that were created during that time period, but not delivered
during the time period. As a workaround, check the envelope
status values in the result set as needed.


### Related topics

- [Searching for envelopes](/docs/esign-rest-api/esign101/concepts/envelopes/search/)
- [How to list envelope status changes](/docs/esign-rest-api/how-to/list-envelope-status-changes/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiEnvelopesGetEnvelopesRequest
*/
func (a *EnvelopesAPIService) EnvelopesGetEnvelopes(ctx context.Context, accountId string) ApiEnvelopesGetEnvelopesRequest {
	return ApiEnvelopesGetEnvelopesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return EnvelopesInformation
func (a *EnvelopesAPIService) EnvelopesGetEnvelopesExecute(r ApiEnvelopesGetEnvelopesRequest) (*EnvelopesInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopesInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.EnvelopesGetEnvelopes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.acStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ac_status", r.acStatus, "")
	}
	if r.block != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "block", r.block, "")
	}
	if r.cdseMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cdse_mode", r.cdseMode, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuation_token", r.continuationToken, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.customField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "custom_field", r.customField, "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.envelopeIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "envelope_ids", r.envelopeIds, "")
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "")
	}
	if r.folderIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folder_ids", r.folderIds, "")
	}
	if r.folderTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folder_types", r.folderTypes, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "")
	}
	if r.fromToStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_to_status", r.fromToStatus, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	if r.includePurgeInformation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_purge_information", r.includePurgeInformation, "")
	}
	if r.intersectingFolderIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "intersecting_folder_ids", r.intersectingFolderIds, "")
	}
	if r.lastQueriedDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_queried_date", r.lastQueriedDate, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.powerformids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "powerformids", r.powerformids, "")
	}
	if r.queryBudget != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query_budget", r.queryBudget, "")
	}
	if r.requesterDateFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requester_date_format", r.requesterDateFormat, "")
	}
	if r.searchMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_mode", r.searchMode, "")
	}
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_text", r.searchText, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_date", r.toDate, "")
	}
	if r.transactionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transaction_ids", r.transactionIds, "")
	}
	if r.userFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_filter", r.userFilter, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "")
	}
	if r.userName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_name", r.userName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopesPostEnvelopesRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	cdseMode *string
	changeRoutingOrder *string
	completedDocumentsOnly *string
	mergeRolesOnDraft *string
	envelopeDefinition *EnvelopeDefinition
}

// Reserved for DocuSign. 
func (r ApiEnvelopesPostEnvelopesRequest) CdseMode(cdseMode string) ApiEnvelopesPostEnvelopesRequest {
	r.cdseMode = &cdseMode
	return r
}

// When true, users can define the routing order of recipients while sending documents for signature.
func (r ApiEnvelopesPostEnvelopesRequest) ChangeRoutingOrder(changeRoutingOrder string) ApiEnvelopesPostEnvelopesRequest {
	r.changeRoutingOrder = &changeRoutingOrder
	return r
}

// Reserved for DocuSign. 
func (r ApiEnvelopesPostEnvelopesRequest) CompletedDocumentsOnly(completedDocumentsOnly string) ApiEnvelopesPostEnvelopesRequest {
	r.completedDocumentsOnly = &completedDocumentsOnly
	return r
}

// When **true,** template roles will be merged, and empty recipients will be removed. This parameter applies when you create a draft envelope with multiple templates. (To create a draft envelope, the &#x60;status&#x60; field is set to &#x60;created&#x60;.)  **Note:** DocuSign recommends that this parameter should be set to **true** whenever you create a draft envelope with multiple templates.
func (r ApiEnvelopesPostEnvelopesRequest) MergeRolesOnDraft(mergeRolesOnDraft string) ApiEnvelopesPostEnvelopesRequest {
	r.mergeRolesOnDraft = &mergeRolesOnDraft
	return r
}

func (r ApiEnvelopesPostEnvelopesRequest) EnvelopeDefinition(envelopeDefinition EnvelopeDefinition) ApiEnvelopesPostEnvelopesRequest {
	r.envelopeDefinition = &envelopeDefinition
	return r
}

func (r ApiEnvelopesPostEnvelopesRequest) Execute() (*EnvelopeSummary, *http.Response, error) {
	return r.ApiService.EnvelopesPostEnvelopesExecute(r)
}

/*
EnvelopesPostEnvelopes Creates an envelope.

Creates and sends an envelope or creates a draft envelope.
Envelopes are fundamental resources in the DocuSign platform.


With this method you can:

* Create and send an envelope
  with [documents][], [recipients][], and [tabs][].
* [Create and send an envelope from a template](/docs/esign-rest-api/esign101/concepts/templates/).
* [Create and send an envelope from
  a combination of documents and templates](/docs/esign-rest-api/esign101/concepts/templates/composite/).
* Create a draft envelope.


When you use this method
to create and send an envelope
in a single request,
the following parameters in the request body (an [`envelopeDefinition`][envelopeDefinition] object) are required:

| Parameter      | Description |
| :--------      | :---------- |
| `status`       | Set to `sent` to send the envelope to recipients.<br>Set to `created` (or don't set at all) to save the envelope as a draft. |
| `emailSubject` | The subject of the email used to send the envelope. |
| `documents`    | The [documents][] to be signed. |
| `recipients`   | The email addresses of the envelope [recipients][]. |


When you create an envelope by using a
[composite template](/docs/esign-rest-api/esign101/concepts/templates/composite/),
you should specify the envelope custom fields in the inline template.
Any custom fields that you specify at the root level are ignored.

If the envelope has a workflow definition
and the `workflowStatus` is `paused`,
the envelope will not be sent immediately,
even if the envelope's `status` is `sent`.


### Related topics

[Envelope][envelopes] and [template][templates]
objects along with [documents][documents],
[recipients][recipients], and [tabs][tabs]
are the five object models at the core of the eSignature API.
The [eSignature concepts guide](/docs/esign-rest-api/esign101/concepts/)
describes how the five object models work together.

The following how-to articles contain
practical examples that show you how to
to
configure this method's
[`envelopeDefinition`][envelopeDefinition] request body
to perform common tasks.

Requesting a signature

- [How to request a signature by email](/docs/esign-rest-api/how-to/request-signature-email-remote/)
- [How to request a signature through your app](/docs/esign-rest-api/how-to/request-signature-in-app-embedded/)
- [How to request a signature by email using a template](/docs/esign-rest-api/how-to/request-signature-template-remote/)
- [How to request a signature using a composite template](/docs/esign-rest-api/how-to/request-signature-composite-template-embedded/)
- [How to request a signature by SMS delivery](/docs/esign-rest-api/how-to/request-signature-sms/)
- [How to send a request for payment](/docs/esign-rest-api/how-to/request-a-payment/)
- [How to send an envelope to an In Person Signer](/docs/esign-rest-api/how-to/send-envelope-to-in-person-signer/)
- [How to request a signature through your app (embedded signing) with a CFR Part 11 account](/docs/esign-rest-api/how-to/request-signature-in-app-embedded-cfrpart11/)

Working with envelopes and templates

- [How to get envelope information](/docs/esign-rest-api/how-to/get-envelope-information/)
- [How to list envelope recipients](/docs/esign-rest-api/how-to/get-envelope-recipients/)
- [How to list envelope status changes](/docs/esign-rest-api/how-to/list-envelope-status-changes/)
- [How to create a template](/docs/esign-rest-api/how-to/create-template/)
- [How to send an envelope via your app](/docs/esign-rest-api/how-to/embedded-sending/)
- [How to bulk send envelopes](/docs/esign-rest-api/how-to/bulk-send-envelopes/)

Working with advanced recipient routing

- [How to pause a signature workflow](/docs/esign-rest-api/how-to/pause-workflow/)
- [How to unpause a signature workflow](/docs/esign-rest-api/how-to/unpause-workflow/)
- [How to use conditional recipients](/docs/esign-rest-api/how-to/use-conditional-recipients/)
- [How to schedule an envelope](/docs/esign-rest-api/how-to/schedule-an-envelope/)
- [How to send an envelope with delayed routing](/docs/esign-rest-api/how-to/send-envelope-with-delayed-routing/)

Working with documents

- [How to list envelope documents](/docs/esign-rest-api/how-to/list-envelope-documents/)
- [How to download envelope documents](/docs/esign-rest-api/how-to/download-envelope-documents/)
- [How to attach documents via binary transfer](/docs/esign-rest-api/how-to/send-binary/)
- [How to create a signable HTML document](/docs/esign-rest-api/how-to/creating-signable-html/)
- [How to convert a PDF file into a signable HTML document](/docs/esign-rest-api/how-to/converting-pdf/)
- [How to set document visibility for envelope recipients](/docs/esign-rest-api/how-to/set-document-visibility/)

Working with tabs

- [How to get envelope tab values](/docs/esign-rest-api/how-to/get-envelope-tab-values/)
- [How to get envelope custom tab values](/docs/esign-rest-api/how-to/get-envelope-custom-tab-values/)
- [How to set envelope tab values](/docs/esign-rest-api/how-to/set-envelope-tab-values/)
- [How to set tab values in a template](/docs/esign-rest-api/how-to/set-template-tab-values/)

Working with brands

- [How to create a brand](/docs/esign-rest-api/how-to/create-brand/)
- [How to apply a brand to an envelope](/docs/esign-rest-api/how-to/apply-brand-to-envelope/)
- [How to apply a brand and template to an envelope](/docs/esign-rest-api/how-to/apply-brand-and-template-to-envelope/)

Working with permissions

- [How to create a permission profile](/docs/esign-rest-api/how-to/permission-profile-creating/)
- [How to update individual permission settings](/docs/esign-rest-api/how-to/permission-profile-updating/)
- [How to set a permission profile](/docs/esign-rest-api/how-to/permission-profile-setting/)
- [How to delete a permission profile](/docs/esign-rest-api/how-to/permission-profile-deleting/)

Implementing multi-factor recipient (signer) authentication

- [How to require ID verification (IDV) for a recipient](/docs/esign-rest-api/how-to/id-verification/)
- [How to require knowledge-based authentication (KBA) for a recipient](/docs/esign-rest-api/how-to/knowledge-based-authentication/)
- [How to require phone authentication for a recipient](/docs/esign-rest-api/how-to/phone-auth/)
- [How to require access code authentication for a recipient](/docs/esign-rest-api/how-to/require-access-code-recipient/)

<!-- this should mirror /docs/esign-rest-api/how-to/ -->



[addingdocs]:           /docs/esign-rest-api/esign101/concepts/envelopes/
[attachments]:          /docs/esign-rest-api/esign101/concepts/documents/attachments/
[authcopies]:           /docs/esign-rest-api/esign101/concepts/documents/authoritative-copies/
[conoverview]:          /docs/esign-rest-api/esign101/concepts/overview/
[deleting]:             /docs/esign-rest-api/esign101/concepts/envelopes/
[documents]:            /docs/esign-rest-api/esign101/concepts/documents/
[envelopeDefinition]:   /docs/esign-rest-api/reference/envelopes/envelopes/create/#schema__envelopedefinition
[envelopes]:            /docs/esign-rest-api/esign101/concepts/envelopes/
[locking]:              /docs/esign-rest-api/esign101/concepts/envelopes/lock/
[payments]:             /docs/esign-rest-api/esign101/concepts/tabs/payment/
[purging]:              /docs/esign-rest-api/esign101/concepts/documents/purging/
[recipients]:           /docs/esign-rest-api/esign101/concepts/recipients/
[recipstatus]:          /docs/esign-rest-api/esign101/concepts/recipients/#recipient-status
[reciptypes]:           /docs/esign-rest-api/esign101/concepts/recipients/#recipient-types
[supdocs]:              /docs/esign-rest-api/esign101/concepts/documents/supplemental/
[tabanchor]:            /docs/esign-rest-api/esign101/concepts/tabs/auto-place/
[tabcustom]:            /docs/esign-rest-api/esign101/concepts/tabs/custom-tabs/
[tabs]:                 /docs/esign-rest-api/esign101/concepts/tabs/
[tabtypes]:             /docs/esign-rest-api/esign101/concepts/tabs/
[templates]:            /docs/esign-rest-api/esign101/concepts/templates/
[tracking]:             /docs/esign-rest-api/esign101/concepts/envelopes/



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiEnvelopesPostEnvelopesRequest
*/
func (a *EnvelopesAPIService) EnvelopesPostEnvelopes(ctx context.Context, accountId string) ApiEnvelopesPostEnvelopesRequest {
	return ApiEnvelopesPostEnvelopesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return EnvelopeSummary
func (a *EnvelopesAPIService) EnvelopesPostEnvelopesExecute(r ApiEnvelopesPostEnvelopesRequest) (*EnvelopeSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.EnvelopesPostEnvelopes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cdseMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cdse_mode", r.cdseMode, "")
	}
	if r.changeRoutingOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "change_routing_order", r.changeRoutingOrder, "")
	}
	if r.completedDocumentsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completed_documents_only", r.completedDocumentsOnly, "")
	}
	if r.mergeRolesOnDraft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "merge_roles_on_draft", r.mergeRolesOnDraft, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopesPutEnvelopeRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	envelopeId string
	advancedUpdate *string
	resendEnvelope *string
	envelope *Envelope
}

// When **true,** allows the caller to update recipients, tabs, custom fields, notification, email settings and other envelope attributes.
func (r ApiEnvelopesPutEnvelopeRequest) AdvancedUpdate(advancedUpdate string) ApiEnvelopesPutEnvelopeRequest {
	r.advancedUpdate = &advancedUpdate
	return r
}

// When **true,** sends the specified envelope again.
func (r ApiEnvelopesPutEnvelopeRequest) ResendEnvelope(resendEnvelope string) ApiEnvelopesPutEnvelopeRequest {
	r.resendEnvelope = &resendEnvelope
	return r
}

// A container used to send documents to recipients. The envelope carries information about the sender and timestamps to indicate the progress of the delivery procedure. It can contain collections of Documents, Tabs and Recipients.
func (r ApiEnvelopesPutEnvelopeRequest) Envelope(envelope Envelope) ApiEnvelopesPutEnvelopeRequest {
	r.envelope = &envelope
	return r
}

func (r ApiEnvelopesPutEnvelopeRequest) Execute() (*EnvelopeUpdateSummary, *http.Response, error) {
	return r.ApiService.EnvelopesPutEnvelopeExecute(r)
}

/*
EnvelopesPutEnvelope Send, void, or modify a draft envelope. Purge documents from a completed envelope.

This method enables you to make changes to an envelope.
You can use it to:

* [Send a draft envelope](#sending-a-draft-envelope)
* [Void an in-process envelope](#voiding-an-in-process-envelope)
* [Modify a draft envelope](#modifying-envelope-email-information)
* [Purge documents and envelope metadata from the DocuSign platform](#purging-documents-from-docusign)

Although the request body for this method
is a complete envelope definition,
you only need to provide
the properties that
you're updating.

## Sending a draft envelope

To send a draft envelope, include the following code in the request body:

```json
{
  "status": "sent"
}
```

You can attach a workflow before sending the envelope:

```json
{
  "status": "sent",
  "workflow": {
    "workflowSteps": [
      {
        "action": "pause_before",
        "description": "pause_before routing order 2",
        "itemId": 2,
        "triggerOnItem": "routing_order"
      }
    ]
  }
}
```

## Working with workflows

To unpause a workflow, the request body should include this:

```json
{
  "workflow": {
    "workflowStatus": "in_progress"
  }
}
```

## Voiding an in-process envelope

To void an in-process envelope, include the following code in the request body:

```json
{
  "status": "voided",
  "voidedReason": "The reason for voiding the envelope"
}
```

## Modifying envelope email information

To change the email subject and message of a draft envelope,
include the following code in the request body:

```json
{
  "emailSubject": "new email subject",
  "emailBlurb": "new email message"
}
```

## Purging documents from DocuSign

To place only the documents
in the purge queue,
leaving any
corresponding attachments
and tabs in the DocuSign platform,
set the `purgeState` property
to `documents_queued`.

```json
{
  "envelopeId": "222e6847-xxxx-xxxx-xxxx-72a3c9c16fca",
  "purgeState": "documents_queued"
}
```

To place documents,
attachments,
and tabs
in the purge queue,
set the `purgeState` property
to `documents_and_metadata_queued`.

```json
{
  "envelopeId": "222e6847-xxxx-xxxx-xxxx-72a3c9c16fca",
  "purgeState": "documents_and_metadata_queued"
}
```

To place documents,
attachments,
and tabs
in the purge queue
and to redact personal information,
set the `purgeState` property
to `documents_and_metadata_and_redact_queued`.

```json
{
  "envelopeId": "222e6847-xxxx-xxxx-xxxx-72a3c9c16fca",
  "purgeState": "documents_and_metadata_and_redact_queued"
}
```

You can purge documents
only from completed envelopes
that are not marked as the authoritative copy.
The user requesting the purge
must have permission to purge documents
and
must be the sender or be acting on behalf of the sender.

When the purge request is initiated
the items to be purged
are placed in the purge queue
for deletion in 14 days.
The sender
and
all recipients with DocuSign accounts
associated with the envelope
get an email notification
the documents will be deleted in 14 days.
The notification contains a link
to the documents.
A second email notification
is sent 7 days later.
At the end of the 14-day period
the documents are deleted from the system.
Recipients without DocuSign accounts
do not receive email notifications.

If your account has a Document Retention policy,
envelope documents
are automatically placed
in the purge queue,
and notification emails are sent
at the end of the retention period.
Setting a Document Retention policy is the same as setting a
schedule for purging documents.

## Removing documents from the purge queue

To remove documents from the purge queue, include the following code in the request body:

```json
{
  "envelopeId": "222e6847-xxxx-xxxx-xxxx-72a3c9c16fca",
  "purgeState": "documents_dequeued"
}
```

### Related topics

- [Void an envelope](https://www.docusign.com/blog/dsdev-common-api-tasks-void-an-envelope) ([Common API Tasks](https://www.docusign.com/blog/tags/common-api-tasks))
- [Purging documents (eSignature Concepts)](/docs/esign-rest-api/esign101/concepts/documents/purging/)
- [Purging documents in an envelope (blog post)](https://www.docusign.com/blog/developers/purging-documents-envelope)
- [How to unpause a signature workflow](/docs/esign-rest-api/how-to/unpause-workflow/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiEnvelopesPutEnvelopeRequest
*/
func (a *EnvelopesAPIService) EnvelopesPutEnvelope(ctx context.Context, accountId string, envelopeId string) ApiEnvelopesPutEnvelopeRequest {
	return ApiEnvelopesPutEnvelopeRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return EnvelopeUpdateSummary
func (a *EnvelopesAPIService) EnvelopesPutEnvelopeExecute(r ApiEnvelopesPutEnvelopeRequest) (*EnvelopeUpdateSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeUpdateSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.EnvelopesPutEnvelope")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.advancedUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "advanced_update", r.advancedUpdate, "")
	}
	if r.resendEnvelope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resend_envelope", r.resendEnvelope, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelope
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopesPutStatusRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	acStatus *string
	block *string
	count *string
	email *string
	envelopeIds *string
	fromDate *string
	fromToStatus *string
	startPosition *string
	status *string
	toDate *string
	transactionIds *string
	userName *string
	envelopeIdsRequest *EnvelopeIdsRequest
}

// Specifies the Authoritative Copy Status for the envelopes. Valid values:   - &#x60;Unknown&#x60; - &#x60;Original&#x60; - &#x60;Transferred&#x60; - &#x60;AuthoritativeCopy&#x60; - &#x60;AuthoritativeCopyExportPending&#x60; - &#x60;AuthoritativeCopyExported&#x60; - &#x60;DepositPending&#x60; - &#x60;Deposited&#x60; - &#x60;DepositedEO&#x60; - &#x60;DepositFailed&#x60;
func (r ApiEnvelopesPutStatusRequest) AcStatus(acStatus string) ApiEnvelopesPutStatusRequest {
	r.acStatus = &acStatus
	return r
}

// When **true,** removes any results that match one of the provided &#x60;transaction_ids&#x60;.
func (r ApiEnvelopesPutStatusRequest) Block(block string) ApiEnvelopesPutStatusRequest {
	r.block = &block
	return r
}

// The maximum number of results to return.  Use &#x60;start_position&#x60; to specify the number of results to skip.  
func (r ApiEnvelopesPutStatusRequest) Count(count string) ApiEnvelopesPutStatusRequest {
	r.count = &count
	return r
}

// The email address of the sender.
func (r ApiEnvelopesPutStatusRequest) Email(email string) ApiEnvelopesPutStatusRequest {
	r.email = &email
	return r
}

// The envelope IDs to include in the results.  The value of this property can be: - A comma-separated list of envelope IDs - The special value &#x60;request_body&#x60;. In this case, the method uses the envelope IDs in the request body.
func (r ApiEnvelopesPutStatusRequest) EnvelopeIds(envelopeIds string) ApiEnvelopesPutStatusRequest {
	r.envelopeIds = &envelopeIds
	return r
}

// The date/time setting that specifies when the request begins checking for status changes for envelopes in the account. This is required unless parameters &#x60;envelope_ids&#x60; and/or &#x60;transaction_Ids&#x60; are provided.  **Note:** This parameter must be set to a valid  &#x60;DateTime&#x60;, or  &#x60;envelope_ids&#x60; and/or &#x60;transaction_ids&#x60; must be specified.
func (r ApiEnvelopesPutStatusRequest) FromDate(fromDate string) ApiEnvelopesPutStatusRequest {
	r.fromDate = &fromDate
	return r
}

// The envelope status that you are checking for. Possible values are:   - &#x60;Changed&#x60; (default) - &#x60;Completed&#x60; - &#x60;Created&#x60; - &#x60;Declined&#x60; - &#x60;Deleted&#x60; - &#x60;Delivered&#x60; - &#x60;Processing&#x60; - &#x60;Sent&#x60; - &#x60;Signed&#x60; - &#x60;TimedOut&#x60; - &#x60;Voided&#x60;  For example, if you specify &#x60;Changed&#x60;, this method returns a list of envelopes that changed status during the &#x60;from_date&#x60; to &#x60;to_date&#x60; time period.  
func (r ApiEnvelopesPutStatusRequest) FromToStatus(fromToStatus string) ApiEnvelopesPutStatusRequest {
	r.fromToStatus = &fromToStatus
	return r
}

// The zero-based index of the result from which to start returning results.  Use with &#x60;count&#x60; to limit the number of results.  The default value is &#x60;0&#x60;. 
func (r ApiEnvelopesPutStatusRequest) StartPosition(startPosition string) ApiEnvelopesPutStatusRequest {
	r.startPosition = &startPosition
	return r
}

// A comma-separated list of envelope status to search for. Possible values are:  - &#x60;completed&#x60; - &#x60;created&#x60; - &#x60;declined&#x60; - &#x60;deleted&#x60; - &#x60;delivered&#x60; - &#x60;processing&#x60; - &#x60;sent&#x60; - &#x60;signed&#x60; - &#x60;template&#x60; - &#x60;voided&#x60; 
func (r ApiEnvelopesPutStatusRequest) Status(status string) ApiEnvelopesPutStatusRequest {
	r.status = &status
	return r
}

// Optional date/time setting that specifies the last date/time  or envelope status changes in the result set.   The default value is the time that you call the method.  
func (r ApiEnvelopesPutStatusRequest) ToDate(toDate string) ApiEnvelopesPutStatusRequest {
	r.toDate = &toDate
	return r
}

// The transaction IDs to include in the results. Note that transaction IDs are valid for seven days.  The value of this property can be: - A list of comma-separated transaction IDs - The special value &#x60;request_body&#x60;. In this case, this method uses the transaction IDs in the request body.
func (r ApiEnvelopesPutStatusRequest) TransactionIds(transactionIds string) ApiEnvelopesPutStatusRequest {
	r.transactionIds = &transactionIds
	return r
}

// Limits results to envelopes sent by the account user with this user name.  &#x60;email&#x60; must be given as well, and both &#x60;email&#x60; and &#x60;user_name&#x60; must refer to an existing account user. 
func (r ApiEnvelopesPutStatusRequest) UserName(userName string) ApiEnvelopesPutStatusRequest {
	r.userName = &userName
	return r
}

func (r ApiEnvelopesPutStatusRequest) EnvelopeIdsRequest(envelopeIdsRequest EnvelopeIdsRequest) ApiEnvelopesPutStatusRequest {
	r.envelopeIdsRequest = &envelopeIdsRequest
	return r
}

func (r ApiEnvelopesPutStatusRequest) Execute() (*EnvelopesInformation, *http.Response, error) {
	return r.ApiService.EnvelopesPutStatusExecute(r)
}

/*
EnvelopesPutStatus Gets envelope statuses for a set of envelopes.

Retrieves envelope statuses for a set of envelopes.

<ds-inlinemessage>
To search for envelopes using a broad range of filters, use
<a href="/docs/esign-rest-api/reference/envelopes/envelopes/liststatuschanges/">Envelopes: listStatusChanges</a>
instead of this method.
</ds-inlinemessage>

You must specify exactly one of the following query parameters:

| Parameter         | Description                                                                      |
| :---------------- | :------------------------------------------------------------------------------- |
| `from_date`       | a valid UTC DateTime:  `2016-01-01`                                              |
| `envelope_ids`    | A comma-separated list of envelope IDs<br>or the special value `request_body`    |
| `transaction_ids` | A comma-separated list of transaction IDs<br>or the special value `request_body` |

When you use the special value `request_body`, the request body looks like this:

```
{
  "envelopeIds": [
    "44c5ad6c-xxxx-xxxx-xxxx-ebda5e2dfe15",
    "8e26040d-xxxx-xxxx-xxxx-1e29b924d237",
    "c8b40a2d-xxxx-xxxx-xxxx-4fe56fe10f95"
  ]
}
```

<ds-inlinemessage kind="warning">
Omitting the request body altogether causes the endpoint to return an error.
The request body must be at least <code>{}</code>.
</ds-inlinemessage>

### Related topics

- [Searching for envelopes](/docs/esign-rest-api/esign101/concepts/envelopes/search/)
- [How to list envelope status changes](/docs/esign-rest-api/how-to/list-envelope-status-changes/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiEnvelopesPutStatusRequest
*/
func (a *EnvelopesAPIService) EnvelopesPutStatus(ctx context.Context, accountId string) ApiEnvelopesPutStatusRequest {
	return ApiEnvelopesPutStatusRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return EnvelopesInformation
func (a *EnvelopesAPIService) EnvelopesPutStatusExecute(r ApiEnvelopesPutStatusRequest) (*EnvelopesInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopesInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.EnvelopesPutStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/status"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.acStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ac_status", r.acStatus, "")
	}
	if r.block != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "block", r.block, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.envelopeIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "envelope_ids", r.envelopeIds, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "")
	}
	if r.fromToStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_to_status", r.fromToStatus, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_date", r.toDate, "")
	}
	if r.transactionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transaction_ids", r.transactionIds, "")
	}
	if r.userName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_name", r.userName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeIdsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNotificationGetEnvelopesEnvelopeIdNotificationRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	envelopeId string
}

func (r ApiNotificationGetEnvelopesEnvelopeIdNotificationRequest) Execute() (*Notification, *http.Response, error) {
	return r.ApiService.NotificationGetEnvelopesEnvelopeIdNotificationExecute(r)
}

/*
NotificationGetEnvelopesEnvelopeIdNotification Gets envelope notification information.

Retrieves the envelope notification, reminders and expirations, information for an existing envelope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiNotificationGetEnvelopesEnvelopeIdNotificationRequest
*/
func (a *EnvelopesAPIService) NotificationGetEnvelopesEnvelopeIdNotification(ctx context.Context, accountId string, envelopeId string) ApiNotificationGetEnvelopesEnvelopeIdNotificationRequest {
	return ApiNotificationGetEnvelopesEnvelopeIdNotificationRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return Notification
func (a *EnvelopesAPIService) NotificationGetEnvelopesEnvelopeIdNotificationExecute(r ApiNotificationGetEnvelopesEnvelopeIdNotificationRequest) (*Notification, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Notification
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.NotificationGetEnvelopesEnvelopeIdNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/notification"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNotificationPutEnvelopesEnvelopeIdNotificationRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	envelopeId string
	envelopeNotificationRequest *EnvelopeNotificationRequest
}

func (r ApiNotificationPutEnvelopesEnvelopeIdNotificationRequest) EnvelopeNotificationRequest(envelopeNotificationRequest EnvelopeNotificationRequest) ApiNotificationPutEnvelopesEnvelopeIdNotificationRequest {
	r.envelopeNotificationRequest = &envelopeNotificationRequest
	return r
}

func (r ApiNotificationPutEnvelopesEnvelopeIdNotificationRequest) Execute() (*Notification, *http.Response, error) {
	return r.ApiService.NotificationPutEnvelopesEnvelopeIdNotificationExecute(r)
}

/*
NotificationPutEnvelopesEnvelopeIdNotification Sets envelope notifications for an existing envelope.

This method sets the notifications (reminders and expirations) for an existing envelope. The request body sends a structure containing reminders and expirations settings. It also specifies whether to use the settings specified in the request, or the account default notification settings for the envelope.

Note that this request only specifies when notifications are sent; it does not initiate sending of email messages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiNotificationPutEnvelopesEnvelopeIdNotificationRequest
*/
func (a *EnvelopesAPIService) NotificationPutEnvelopesEnvelopeIdNotification(ctx context.Context, accountId string, envelopeId string) ApiNotificationPutEnvelopesEnvelopeIdNotificationRequest {
	return ApiNotificationPutEnvelopesEnvelopeIdNotificationRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return Notification
func (a *EnvelopesAPIService) NotificationPutEnvelopesEnvelopeIdNotificationExecute(r ApiNotificationPutEnvelopesEnvelopeIdNotificationRequest) (*Notification, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Notification
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.NotificationPutEnvelopesEnvelopeIdNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/notification"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeNotificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPagesDeletePageRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	documentId string
	envelopeId string
	pageNumber string
}

func (r ApiPagesDeletePageRequest) Execute() (*http.Response, error) {
	return r.ApiService.PagesDeletePageExecute(r)
}

/*
PagesDeletePage Deletes a page from a document in an envelope.

Deletes a page from a document in an envelope based on the page number.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param documentId The unique ID of the document within the envelope.  Unlike other IDs in the eSignature API, you specify the `documentId` yourself. Typically the first document has the ID `1`, the second document `2`, and so on, but you can use any numbering scheme that fits within a 32-bit signed integer (1 through 2147483647).   Tab objects have a `documentId` property that specifies the document on which to place the tab. 
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param pageNumber The page number being accessed.
 @return ApiPagesDeletePageRequest
*/
func (a *EnvelopesAPIService) PagesDeletePage(ctx context.Context, accountId string, documentId string, envelopeId string, pageNumber string) ApiPagesDeletePageRequest {
	return ApiPagesDeletePageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		documentId: documentId,
		envelopeId: envelopeId,
		pageNumber: pageNumber,
	}
}

// Execute executes the request
func (a *EnvelopesAPIService) PagesDeletePageExecute(r ApiPagesDeletePageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.PagesDeletePage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/documents/{documentId}/pages/{pageNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", url.PathEscape(parameterValueToString(r.pageNumber, "pageNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPagesGetPageImageRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	documentId string
	envelopeId string
	pageNumber string
	dpi *string
	maxHeight *string
	maxWidth *string
	showChanges *string
}

// Sets the dots per inch (DPI) for the returned image.
func (r ApiPagesGetPageImageRequest) Dpi(dpi string) ApiPagesGetPageImageRequest {
	r.dpi = &dpi
	return r
}

// Sets the maximum height for the page image in pixels. The DPI is recalculated based on this setting.
func (r ApiPagesGetPageImageRequest) MaxHeight(maxHeight string) ApiPagesGetPageImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Sets the maximum width for the page image in pixels. The DPI is recalculated based on this setting.
func (r ApiPagesGetPageImageRequest) MaxWidth(maxWidth string) ApiPagesGetPageImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// When **true,** changes display in the user interface.
func (r ApiPagesGetPageImageRequest) ShowChanges(showChanges string) ApiPagesGetPageImageRequest {
	r.showChanges = &showChanges
	return r
}

func (r ApiPagesGetPageImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.PagesGetPageImageExecute(r)
}

/*
PagesGetPageImage Gets a page image from an envelope for display.

Returns an image of a page in a document for display.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param documentId The unique ID of the document within the envelope.  Unlike other IDs in the eSignature API, you specify the `documentId` yourself. Typically the first document has the ID `1`, the second document `2`, and so on, but you can use any numbering scheme that fits within a 32-bit signed integer (1 through 2147483647).   Tab objects have a `documentId` property that specifies the document on which to place the tab. 
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param pageNumber The page number being accessed.
 @return ApiPagesGetPageImageRequest
*/
func (a *EnvelopesAPIService) PagesGetPageImage(ctx context.Context, accountId string, documentId string, envelopeId string, pageNumber string) ApiPagesGetPageImageRequest {
	return ApiPagesGetPageImageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		documentId: documentId,
		envelopeId: envelopeId,
		pageNumber: pageNumber,
	}
}

// Execute executes the request
//  @return *os.File
func (a *EnvelopesAPIService) PagesGetPageImageExecute(r ApiPagesGetPageImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.PagesGetPageImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/documents/{documentId}/pages/{pageNumber}/page_image"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", url.PathEscape(parameterValueToString(r.pageNumber, "pageNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dpi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dpi", r.dpi, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_height", r.maxHeight, "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_width", r.maxWidth, "")
	}
	if r.showChanges != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_changes", r.showChanges, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/png"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPagesGetPageImagesRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	documentId string
	envelopeId string
	count *string
	dpi *string
	maxHeight *string
	maxWidth *string
	nocache *string
	showChanges *string
	startPosition *string
}

// The maximum number of results to return.
func (r ApiPagesGetPageImagesRequest) Count(count string) ApiPagesGetPageImagesRequest {
	r.count = &count
	return r
}

// The number of dots per inch (DPI) for the resulting images. Valid values are 1-310 DPI. The default value is 94.
func (r ApiPagesGetPageImagesRequest) Dpi(dpi string) ApiPagesGetPageImagesRequest {
	r.dpi = &dpi
	return r
}

// Sets the maximum height of the returned images in pixels.
func (r ApiPagesGetPageImagesRequest) MaxHeight(maxHeight string) ApiPagesGetPageImagesRequest {
	r.maxHeight = &maxHeight
	return r
}

// Sets the maximum width of the returned images in pixels.
func (r ApiPagesGetPageImagesRequest) MaxWidth(maxWidth string) ApiPagesGetPageImagesRequest {
	r.maxWidth = &maxWidth
	return r
}

// When **true,** using cache is disabled and image information is retrieved from a database. **True** is the default value. 
func (r ApiPagesGetPageImagesRequest) Nocache(nocache string) ApiPagesGetPageImagesRequest {
	r.nocache = &nocache
	return r
}

// When **true,** changes display in the user interface.
func (r ApiPagesGetPageImagesRequest) ShowChanges(showChanges string) ApiPagesGetPageImagesRequest {
	r.showChanges = &showChanges
	return r
}

// The position within the total result set from which to start returning values. The value **thumbnail** may be used to return the page image.
func (r ApiPagesGetPageImagesRequest) StartPosition(startPosition string) ApiPagesGetPageImagesRequest {
	r.startPosition = &startPosition
	return r
}

func (r ApiPagesGetPageImagesRequest) Execute() (*PageImages, *http.Response, error) {
	return r.ApiService.PagesGetPageImagesExecute(r)
}

/*
PagesGetPageImages Returns document page images based on input.

Returns images of the pages in a document for display based on the parameters that you specify.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param documentId The unique ID of the document within the envelope.  Unlike other IDs in the eSignature API, you specify the `documentId` yourself. Typically the first document has the ID `1`, the second document `2`, and so on, but you can use any numbering scheme that fits within a 32-bit signed integer (1 through 2147483647).   Tab objects have a `documentId` property that specifies the document on which to place the tab. 
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiPagesGetPageImagesRequest
*/
func (a *EnvelopesAPIService) PagesGetPageImages(ctx context.Context, accountId string, documentId string, envelopeId string) ApiPagesGetPageImagesRequest {
	return ApiPagesGetPageImagesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		documentId: documentId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return PageImages
func (a *EnvelopesAPIService) PagesGetPageImagesExecute(r ApiPagesGetPageImagesRequest) (*PageImages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageImages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.PagesGetPageImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/documents/{documentId}/pages"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.dpi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dpi", r.dpi, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_height", r.maxHeight, "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_width", r.maxWidth, "")
	}
	if r.nocache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nocache", r.nocache, "")
	}
	if r.showChanges != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_changes", r.showChanges, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPagesPutPageImageRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	documentId string
	envelopeId string
	pageNumber string
	pageRequest *PageRequest
}

func (r ApiPagesPutPageImageRequest) PageRequest(pageRequest PageRequest) ApiPagesPutPageImageRequest {
	r.pageRequest = &pageRequest
	return r
}

func (r ApiPagesPutPageImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.PagesPutPageImageExecute(r)
}

/*
PagesPutPageImage Rotates page image from an envelope for display.

Rotates page image from an envelope for display. The page image can be rotated to the left or right.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param documentId The unique ID of the document within the envelope.  Unlike other IDs in the eSignature API, you specify the `documentId` yourself. Typically the first document has the ID `1`, the second document `2`, and so on, but you can use any numbering scheme that fits within a 32-bit signed integer (1 through 2147483647).   Tab objects have a `documentId` property that specifies the document on which to place the tab. 
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param pageNumber The page number being accessed.
 @return ApiPagesPutPageImageRequest
*/
func (a *EnvelopesAPIService) PagesPutPageImage(ctx context.Context, accountId string, documentId string, envelopeId string, pageNumber string) ApiPagesPutPageImageRequest {
	return ApiPagesPutPageImageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		documentId: documentId,
		envelopeId: envelopeId,
		pageNumber: pageNumber,
	}
}

// Execute executes the request
func (a *EnvelopesAPIService) PagesPutPageImageExecute(r ApiPagesPutPageImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.PagesPutPageImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/documents/{documentId}/pages/{pageNumber}/page_image"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", url.PathEscape(parameterValueToString(r.pageNumber, "pageNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRecipientsGetRecipientInitialsImageRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	envelopeId string
	recipientId string
	includeChrome *string
}

// The added line and identifier around the initial image. Note: Older envelopes might only have chromed images. If getting the non-chromed image fails, try getting the chromed image.
func (r ApiRecipientsGetRecipientInitialsImageRequest) IncludeChrome(includeChrome string) ApiRecipientsGetRecipientInitialsImageRequest {
	r.includeChrome = &includeChrome
	return r
}

func (r ApiRecipientsGetRecipientInitialsImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.RecipientsGetRecipientInitialsImageExecute(r)
}

/*
RecipientsGetRecipientInitialsImage Gets the initials image for a user.

Retrieves the initials image for the specified user. The image is returned in the same format as it was uploaded. In the request you can specify if the chrome (the added line and identifier around the initial image) is returned with the image.

The userId specified in the endpoint must match the authenticated user's user ID and the user must be a member of the account.

The `signatureIdOrName` parameter accepts signature ID or signature name. DocuSign recommends you use signature ID (`signatureId`), since some names contain characters that do not properly URL encode. If you use the user name, it is likely that the name includes spaces and you might need to URL encode the name before using it in the endpoint.

For example: "Bob Smith" to "Bob%20Smith"

Older envelopes might only contain chromed images. If getting the non-chromed image fails, try getting the chromed image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param recipientId A local reference used to map recipients to other objects, such as specific document tabs.  A `recipientId` must be either an integer or a GUID, and the `recipientId` must be unique within an envelope.  For example, many envelopes assign the first recipient a `recipientId` of `1`. 
 @return ApiRecipientsGetRecipientInitialsImageRequest
*/
func (a *EnvelopesAPIService) RecipientsGetRecipientInitialsImage(ctx context.Context, accountId string, envelopeId string, recipientId string) ApiRecipientsGetRecipientInitialsImageRequest {
	return ApiRecipientsGetRecipientInitialsImageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
		recipientId: recipientId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *EnvelopesAPIService) RecipientsGetRecipientInitialsImageExecute(r ApiRecipientsGetRecipientInitialsImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.RecipientsGetRecipientInitialsImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/recipients/{recipientId}/initials_image"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recipientId"+"}", url.PathEscape(parameterValueToString(r.recipientId, "recipientId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeChrome != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_chrome", r.includeChrome, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/gif"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecipientsGetRecipientSignatureRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	envelopeId string
	recipientId string
}

func (r ApiRecipientsGetRecipientSignatureRequest) Execute() (*UserSignature, *http.Response, error) {
	return r.ApiService.RecipientsGetRecipientSignatureExecute(r)
}

/*
RecipientsGetRecipientSignature Gets signature information for a signer or sign-in-person recipient.

Retrieves signature information for a signer or sign-in-person recipient.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param recipientId A local reference used to map recipients to other objects, such as specific document tabs.  A `recipientId` must be either an integer or a GUID, and the `recipientId` must be unique within an envelope.  For example, many envelopes assign the first recipient a `recipientId` of `1`. 
 @return ApiRecipientsGetRecipientSignatureRequest
*/
func (a *EnvelopesAPIService) RecipientsGetRecipientSignature(ctx context.Context, accountId string, envelopeId string, recipientId string) ApiRecipientsGetRecipientSignatureRequest {
	return ApiRecipientsGetRecipientSignatureRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
		recipientId: recipientId,
	}
}

// Execute executes the request
//  @return UserSignature
func (a *EnvelopesAPIService) RecipientsGetRecipientSignatureExecute(r ApiRecipientsGetRecipientSignatureRequest) (*UserSignature, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserSignature
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.RecipientsGetRecipientSignature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/recipients/{recipientId}/signature"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recipientId"+"}", url.PathEscape(parameterValueToString(r.recipientId, "recipientId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecipientsGetRecipientSignatureImageRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	envelopeId string
	recipientId string
	includeChrome *string
}

// When **true,** the response includes the chromed version of the signature image.
func (r ApiRecipientsGetRecipientSignatureImageRequest) IncludeChrome(includeChrome string) ApiRecipientsGetRecipientSignatureImageRequest {
	r.includeChrome = &includeChrome
	return r
}

func (r ApiRecipientsGetRecipientSignatureImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.RecipientsGetRecipientSignatureImageExecute(r)
}

/*
RecipientsGetRecipientSignatureImage Retrieve signature image information for a signer/sign-in-person recipient.

Retrieves the specified user signature image. The image is returned in the same format as uploaded. In the request you can specify if the chrome (the added line and identifier around the initial image) is returned with the image.

The userId specified in the endpoint must match the authenticated user's user ID and the user must be a member of the account.

The `signatureIdOrName` parameter accepts signature ID or signature name. DocuSign recommends you use signature ID (`signatureId`), since some names contain characters that don't properly URL encode. If you use the user name, it is likely that the name includes spaces and you might need to URL encode the name before using it in the endpoint. 

For example: "Bob Smith" to "Bob%20Smith"

Older envelopes might only have chromed images. If getting the non-chromed image fails, try getting the chromed image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param recipientId A local reference used to map recipients to other objects, such as specific document tabs.  A `recipientId` must be either an integer or a GUID, and the `recipientId` must be unique within an envelope.  For example, many envelopes assign the first recipient a `recipientId` of `1`. 
 @return ApiRecipientsGetRecipientSignatureImageRequest
*/
func (a *EnvelopesAPIService) RecipientsGetRecipientSignatureImage(ctx context.Context, accountId string, envelopeId string, recipientId string) ApiRecipientsGetRecipientSignatureImageRequest {
	return ApiRecipientsGetRecipientSignatureImageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
		recipientId: recipientId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *EnvelopesAPIService) RecipientsGetRecipientSignatureImageExecute(r ApiRecipientsGetRecipientSignatureImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.RecipientsGetRecipientSignatureImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/recipients/{recipientId}/signature_image"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recipientId"+"}", url.PathEscape(parameterValueToString(r.recipientId, "recipientId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeChrome != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_chrome", r.includeChrome, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/gif"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecipientsPutRecipientInitialsImageRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	envelopeId string
	recipientId string
}

func (r ApiRecipientsPutRecipientInitialsImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.RecipientsPutRecipientInitialsImageExecute(r)
}

/*
RecipientsPutRecipientInitialsImage Sets the initials image for an accountless signer.

Updates the initials image for a signer that does not have a DocuSign account. The supported image formats for this file are: gif, png, jpeg, and bmp. The file size must be less than 200K.

For the Authentication/Authorization for this call, the credentials must match the sender of the envelope, the recipient must be an accountless signer or in person signer. The account must have the `CanSendEnvelope` property set to **true** and the `ExpressSendOnly` property in `SendingUser` structure must be set to **false.**

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param recipientId A local reference used to map recipients to other objects, such as specific document tabs.  A `recipientId` must be either an integer or a GUID, and the `recipientId` must be unique within an envelope.  For example, many envelopes assign the first recipient a `recipientId` of `1`. 
 @return ApiRecipientsPutRecipientInitialsImageRequest
*/
func (a *EnvelopesAPIService) RecipientsPutRecipientInitialsImage(ctx context.Context, accountId string, envelopeId string, recipientId string) ApiRecipientsPutRecipientInitialsImageRequest {
	return ApiRecipientsPutRecipientInitialsImageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
		recipientId: recipientId,
	}
}

// Execute executes the request
func (a *EnvelopesAPIService) RecipientsPutRecipientInitialsImageExecute(r ApiRecipientsPutRecipientInitialsImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.RecipientsPutRecipientInitialsImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/recipients/{recipientId}/initials_image"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recipientId"+"}", url.PathEscape(parameterValueToString(r.recipientId, "recipientId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRecipientsPutRecipientSignatureImageRequest struct {
	ctx context.Context
	ApiService *EnvelopesAPIService
	accountId string
	envelopeId string
	recipientId string
}

func (r ApiRecipientsPutRecipientSignatureImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.RecipientsPutRecipientSignatureImageExecute(r)
}

/*
RecipientsPutRecipientSignatureImage Sets the signature image for an accountless signer.

Updates the signature image for an accountless signer. The supported image formats for this file are: gif, png, jpeg, and bmp. The file size must be less than 200K.

For the Authentication/Authorization for this call, the credentials must match the sender of the envelope, the recipient must be an accountless signer or in person signer. The account must have the `CanSendEnvelope` property set to **true** and the `ExpressSendOnly` property in `SendingUser` structure must be set to **false.**

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param recipientId A local reference used to map recipients to other objects, such as specific document tabs.  A `recipientId` must be either an integer or a GUID, and the `recipientId` must be unique within an envelope.  For example, many envelopes assign the first recipient a `recipientId` of `1`. 
 @return ApiRecipientsPutRecipientSignatureImageRequest
*/
func (a *EnvelopesAPIService) RecipientsPutRecipientSignatureImage(ctx context.Context, accountId string, envelopeId string, recipientId string) ApiRecipientsPutRecipientSignatureImageRequest {
	return ApiRecipientsPutRecipientSignatureImageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
		recipientId: recipientId,
	}
}

// Execute executes the request
func (a *EnvelopesAPIService) RecipientsPutRecipientSignatureImageExecute(r ApiRecipientsPutRecipientSignatureImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopesAPIService.RecipientsPutRecipientSignatureImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/recipients/{recipientId}/signature_image"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recipientId"+"}", url.PathEscape(parameterValueToString(r.recipientId, "recipientId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
