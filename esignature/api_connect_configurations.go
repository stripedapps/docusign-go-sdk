/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ConnectConfigurationsAPIService ConnectConfigurationsAPI service
type ConnectConfigurationsAPIService service

type ApiConnectDeleteConnectConfigRequest struct {
	ctx context.Context
	ApiService *ConnectConfigurationsAPIService
	accountId string
	connectId string
}

func (r ApiConnectDeleteConnectConfigRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectDeleteConnectConfigExecute(r)
}

/*
ConnectDeleteConnectConfig Deletes the specified Connect configuration.

Deletes the specified DocuSign Connect configuration.

**Note:** To use this function, you must be an account administrator and Connect must be enabled on your account.




 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param connectId The ID of the custom Connect configuration being accessed.
 @return ApiConnectDeleteConnectConfigRequest
*/
func (a *ConnectConfigurationsAPIService) ConnectDeleteConnectConfig(ctx context.Context, accountId string, connectId string) ApiConnectDeleteConnectConfigRequest {
	return ApiConnectDeleteConnectConfigRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		connectId: connectId,
	}
}

// Execute executes the request
func (a *ConnectConfigurationsAPIService) ConnectDeleteConnectConfigExecute(r ApiConnectDeleteConnectConfigRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectConfigurationsAPIService.ConnectDeleteConnectConfig")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/connect/{connectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectId"+"}", url.PathEscape(parameterValueToString(r.connectId, "connectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectGetConnectAllUsersRequest struct {
	ctx context.Context
	ApiService *ConnectConfigurationsAPIService
	accountId string
	connectId string
	count *string
	domainUsersOnly *string
	emailSubstring *string
	startPosition *string
	status *string
	userNameSubstring *string
}

// The maximum number of results to return.
func (r ApiConnectGetConnectAllUsersRequest) Count(count string) ApiConnectGetConnectAllUsersRequest {
	r.count = &count
	return r
}

func (r ApiConnectGetConnectAllUsersRequest) DomainUsersOnly(domainUsersOnly string) ApiConnectGetConnectAllUsersRequest {
	r.domainUsersOnly = &domainUsersOnly
	return r
}

// Filters returned user records by full email address or a substring of email address.
func (r ApiConnectGetConnectAllUsersRequest) EmailSubstring(emailSubstring string) ApiConnectGetConnectAllUsersRequest {
	r.emailSubstring = &emailSubstring
	return r
}

// The position within the total result set from which to start returning values. The value **thumbnail** may be used to return the page image.
func (r ApiConnectGetConnectAllUsersRequest) StartPosition(startPosition string) ApiConnectGetConnectAllUsersRequest {
	r.startPosition = &startPosition
	return r
}

// The status of the item.
func (r ApiConnectGetConnectAllUsersRequest) Status(status string) ApiConnectGetConnectAllUsersRequest {
	r.status = &status
	return r
}

// Filters results based on a full or partial user name.  **Note:** When you enter a partial user name, you do not use a wildcard character.
func (r ApiConnectGetConnectAllUsersRequest) UserNameSubstring(userNameSubstring string) ApiConnectGetConnectAllUsersRequest {
	r.userNameSubstring = &userNameSubstring
	return r
}

func (r ApiConnectGetConnectAllUsersRequest) Execute() (*IntegratedConnectUserInfoList, *http.Response, error) {
	return r.ApiService.ConnectGetConnectAllUsersExecute(r)
}

/*
ConnectGetConnectAllUsers Returns all users from the configured Connect service.

Returns all users from the configured Connect service.

**Note:** To use this function, you must be an account administrator and Connect must be enabled on your account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param connectId The ID of the custom Connect configuration being accessed.
 @return ApiConnectGetConnectAllUsersRequest
*/
func (a *ConnectConfigurationsAPIService) ConnectGetConnectAllUsers(ctx context.Context, accountId string, connectId string) ApiConnectGetConnectAllUsersRequest {
	return ApiConnectGetConnectAllUsersRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		connectId: connectId,
	}
}

// Execute executes the request
//  @return IntegratedConnectUserInfoList
func (a *ConnectConfigurationsAPIService) ConnectGetConnectAllUsersExecute(r ApiConnectGetConnectAllUsersRequest) (*IntegratedConnectUserInfoList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegratedConnectUserInfoList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectConfigurationsAPIService.ConnectGetConnectAllUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/connect/{connectId}/all/users"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectId"+"}", url.PathEscape(parameterValueToString(r.connectId, "connectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.domainUsersOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain_users_only", r.domainUsersOnly, "")
	}
	if r.emailSubstring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email_substring", r.emailSubstring, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.userNameSubstring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_name_substring", r.userNameSubstring, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectGetConnectConfigRequest struct {
	ctx context.Context
	ApiService *ConnectConfigurationsAPIService
	accountId string
	connectId string
}

func (r ApiConnectGetConnectConfigRequest) Execute() (*ConnectConfigResults, *http.Response, error) {
	return r.ApiService.ConnectGetConnectConfigExecute(r)
}

/*
ConnectGetConnectConfig Gets the details about a Connect configuration.

Retrieves the information for the specified DocuSign Connect configuration.

**Note:** To use this function, you must be an account administrator and Connect must be enabled on your account.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param connectId The ID of the custom Connect configuration being accessed.
 @return ApiConnectGetConnectConfigRequest
*/
func (a *ConnectConfigurationsAPIService) ConnectGetConnectConfig(ctx context.Context, accountId string, connectId string) ApiConnectGetConnectConfigRequest {
	return ApiConnectGetConnectConfigRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		connectId: connectId,
	}
}

// Execute executes the request
//  @return ConnectConfigResults
func (a *ConnectConfigurationsAPIService) ConnectGetConnectConfigExecute(r ApiConnectGetConnectConfigRequest) (*ConnectConfigResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectConfigResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectConfigurationsAPIService.ConnectGetConnectConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/connect/{connectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectId"+"}", url.PathEscape(parameterValueToString(r.connectId, "connectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectGetConnectConfigsRequest struct {
	ctx context.Context
	ApiService *ConnectConfigurationsAPIService
	accountId string
}

func (r ApiConnectGetConnectConfigsRequest) Execute() (*ConnectConfigResults, *http.Response, error) {
	return r.ApiService.ConnectGetConnectConfigsExecute(r)
}

/*
ConnectGetConnectConfigs Get Connect configuration information.

Retrieves all the DocuSign Custom Connect definitions for the specified account.

**Note:** To use this function, you must be an account administrator and Connect must be enabled on your account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiConnectGetConnectConfigsRequest
*/
func (a *ConnectConfigurationsAPIService) ConnectGetConnectConfigs(ctx context.Context, accountId string) ApiConnectGetConnectConfigsRequest {
	return ApiConnectGetConnectConfigsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return ConnectConfigResults
func (a *ConnectConfigurationsAPIService) ConnectGetConnectConfigsExecute(r ApiConnectGetConnectConfigsRequest) (*ConnectConfigResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectConfigResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectConfigurationsAPIService.ConnectGetConnectConfigs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/connect"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectGetConnectUsersRequest struct {
	ctx context.Context
	ApiService *ConnectConfigurationsAPIService
	accountId string
	connectId string
	count *string
	emailSubstring *string
	listIncludedUsers *string
	startPosition *string
	status *string
	userNameSubstring *string
}

// The maximum number of results to return.  Use &#x60;start_position&#x60; to specify the number of results to skip.  
func (r ApiConnectGetConnectUsersRequest) Count(count string) ApiConnectGetConnectUsersRequest {
	r.count = &count
	return r
}

// Filters returned user records by full email address or a substring of email address.
func (r ApiConnectGetConnectUsersRequest) EmailSubstring(emailSubstring string) ApiConnectGetConnectUsersRequest {
	r.emailSubstring = &emailSubstring
	return r
}

func (r ApiConnectGetConnectUsersRequest) ListIncludedUsers(listIncludedUsers string) ApiConnectGetConnectUsersRequest {
	r.listIncludedUsers = &listIncludedUsers
	return r
}

// The zero-based index of the result from which to start returning results.  Use with &#x60;count&#x60; to limit the number of results.  The default value is &#x60;0&#x60;. 
func (r ApiConnectGetConnectUsersRequest) StartPosition(startPosition string) ApiConnectGetConnectUsersRequest {
	r.startPosition = &startPosition
	return r
}

// Filters the results by user status. You can specify a comma-separated list of the following statuses:  * ActivationRequired  * ActivationSent  * Active * Closed  * Disabled 
func (r ApiConnectGetConnectUsersRequest) Status(status string) ApiConnectGetConnectUsersRequest {
	r.status = &status
	return r
}

// Filters results based on a full or partial user name.  **Note:** When you enter a partial user name, you do not use a wildcard character.
func (r ApiConnectGetConnectUsersRequest) UserNameSubstring(userNameSubstring string) ApiConnectGetConnectUsersRequest {
	r.userNameSubstring = &userNameSubstring
	return r
}

func (r ApiConnectGetConnectUsersRequest) Execute() (*IntegratedUserInfoList, *http.Response, error) {
	return r.ApiService.ConnectGetConnectUsersExecute(r)
}

/*
ConnectGetConnectUsers Returns users from the configured Connect service.

Returns users from the configured Connect service.

**Note:** To use this function, you must be an account administrator and Connect must be enabled on your account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param connectId The ID of the custom Connect configuration being accessed.
 @return ApiConnectGetConnectUsersRequest
*/
func (a *ConnectConfigurationsAPIService) ConnectGetConnectUsers(ctx context.Context, accountId string, connectId string) ApiConnectGetConnectUsersRequest {
	return ApiConnectGetConnectUsersRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		connectId: connectId,
	}
}

// Execute executes the request
//  @return IntegratedUserInfoList
func (a *ConnectConfigurationsAPIService) ConnectGetConnectUsersExecute(r ApiConnectGetConnectUsersRequest) (*IntegratedUserInfoList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegratedUserInfoList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectConfigurationsAPIService.ConnectGetConnectUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/connect/{connectId}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectId"+"}", url.PathEscape(parameterValueToString(r.connectId, "connectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.emailSubstring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email_substring", r.emailSubstring, "")
	}
	if r.listIncludedUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "list_included_users", r.listIncludedUsers, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.userNameSubstring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_name_substring", r.userNameSubstring, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectOAuthConfigDeleteConnectOAuthConfigRequest struct {
	ctx context.Context
	ApiService *ConnectConfigurationsAPIService
	accountId string
}

func (r ApiConnectOAuthConfigDeleteConnectOAuthConfigRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectOAuthConfigDeleteConnectOAuthConfigExecute(r)
}

/*
ConnectOAuthConfigDeleteConnectOAuthConfig Delete the Connect OAuth configuration.

Deletes the Connect OAuth configuration for the specified account.

**Note:** To use this function, you must be an account administrator and Connect must be enabled on your account.

## Related topics:
- [OAuth for DocuSign Connect](/platform/webhooks/connect/validation-and-security/oauth-connect/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiConnectOAuthConfigDeleteConnectOAuthConfigRequest
*/
func (a *ConnectConfigurationsAPIService) ConnectOAuthConfigDeleteConnectOAuthConfig(ctx context.Context, accountId string) ApiConnectOAuthConfigDeleteConnectOAuthConfigRequest {
	return ApiConnectOAuthConfigDeleteConnectOAuthConfigRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *ConnectConfigurationsAPIService) ConnectOAuthConfigDeleteConnectOAuthConfigExecute(r ApiConnectOAuthConfigDeleteConnectOAuthConfigRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectConfigurationsAPIService.ConnectOAuthConfigDeleteConnectOAuthConfig")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/connect/oauth"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectOAuthConfigGetConnectOAuthConfigRequest struct {
	ctx context.Context
	ApiService *ConnectConfigurationsAPIService
	accountId string
}

func (r ApiConnectOAuthConfigGetConnectOAuthConfigRequest) Execute() (*ConnectOAuthConfig, *http.Response, error) {
	return r.ApiService.ConnectOAuthConfigGetConnectOAuthConfigExecute(r)
}

/*
ConnectOAuthConfigGetConnectOAuthConfig Retrieves the Connect OAuth information for the account.

Gets the Connect OAuth configuration for the specified account.

**Note:** To use this function, you must be an account administrator and Connect must be enabled on your account.

## Related topics:
- [OAuth for DocuSign Connect](/platform/webhooks/connect/validation-and-security/oauth-connect/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiConnectOAuthConfigGetConnectOAuthConfigRequest
*/
func (a *ConnectConfigurationsAPIService) ConnectOAuthConfigGetConnectOAuthConfig(ctx context.Context, accountId string) ApiConnectOAuthConfigGetConnectOAuthConfigRequest {
	return ApiConnectOAuthConfigGetConnectOAuthConfigRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return ConnectOAuthConfig
func (a *ConnectConfigurationsAPIService) ConnectOAuthConfigGetConnectOAuthConfigExecute(r ApiConnectOAuthConfigGetConnectOAuthConfigRequest) (*ConnectOAuthConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectOAuthConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectConfigurationsAPIService.ConnectOAuthConfigGetConnectOAuthConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/connect/oauth"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectOAuthConfigPostConnectOAuthConfigRequest struct {
	ctx context.Context
	ApiService *ConnectConfigurationsAPIService
	accountId string
	connectOAuthConfig *ConnectOAuthConfig
}

func (r ApiConnectOAuthConfigPostConnectOAuthConfigRequest) ConnectOAuthConfig(connectOAuthConfig ConnectOAuthConfig) ApiConnectOAuthConfigPostConnectOAuthConfigRequest {
	r.connectOAuthConfig = &connectOAuthConfig
	return r
}

func (r ApiConnectOAuthConfigPostConnectOAuthConfigRequest) Execute() (*ConnectOAuthConfig, *http.Response, error) {
	return r.ApiService.ConnectOAuthConfigPostConnectOAuthConfigExecute(r)
}

/*
ConnectOAuthConfigPostConnectOAuthConfig Set up Connect OAuth for the specified account.

Sets up Connect OAuth for the specified account using an authorization server of your choice. To use this endpoint, get the client ID and client secret from your authorization server.

When you call this endpoint, DocuSign requests an access token from your authorization server. DocuSign will use that token in the Authorization HTTP header of your account's Connect messages. Finally, your listener will be responsible for validating the token by calling the authorization server.

**Note:** To use this function, you must be an account administrator and Connect must be enabled on your account.

## Related topics:
- [OAuth for DocuSign Connect](/platform/webhooks/connect/validation-and-security/oauth-connect/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiConnectOAuthConfigPostConnectOAuthConfigRequest
*/
func (a *ConnectConfigurationsAPIService) ConnectOAuthConfigPostConnectOAuthConfig(ctx context.Context, accountId string) ApiConnectOAuthConfigPostConnectOAuthConfigRequest {
	return ApiConnectOAuthConfigPostConnectOAuthConfigRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return ConnectOAuthConfig
func (a *ConnectConfigurationsAPIService) ConnectOAuthConfigPostConnectOAuthConfigExecute(r ApiConnectOAuthConfigPostConnectOAuthConfigRequest) (*ConnectOAuthConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectOAuthConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectConfigurationsAPIService.ConnectOAuthConfigPostConnectOAuthConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/connect/oauth"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connectOAuthConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectOAuthConfigPutConnectOAuthConfigRequest struct {
	ctx context.Context
	ApiService *ConnectConfigurationsAPIService
	accountId string
	connectOAuthConfig *ConnectOAuthConfig
}

func (r ApiConnectOAuthConfigPutConnectOAuthConfigRequest) ConnectOAuthConfig(connectOAuthConfig ConnectOAuthConfig) ApiConnectOAuthConfigPutConnectOAuthConfigRequest {
	r.connectOAuthConfig = &connectOAuthConfig
	return r
}

func (r ApiConnectOAuthConfigPutConnectOAuthConfigRequest) Execute() (*ConnectOAuthConfig, *http.Response, error) {
	return r.ApiService.ConnectOAuthConfigPutConnectOAuthConfigExecute(r)
}

/*
ConnectOAuthConfigPutConnectOAuthConfig Updates the existing Connect OAuth configuration for the account. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiConnectOAuthConfigPutConnectOAuthConfigRequest
*/
func (a *ConnectConfigurationsAPIService) ConnectOAuthConfigPutConnectOAuthConfig(ctx context.Context, accountId string) ApiConnectOAuthConfigPutConnectOAuthConfigRequest {
	return ApiConnectOAuthConfigPutConnectOAuthConfigRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return ConnectOAuthConfig
func (a *ConnectConfigurationsAPIService) ConnectOAuthConfigPutConnectOAuthConfigExecute(r ApiConnectOAuthConfigPutConnectOAuthConfigRequest) (*ConnectOAuthConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectOAuthConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectConfigurationsAPIService.ConnectOAuthConfigPutConnectOAuthConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/connect/oauth"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connectOAuthConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectPostConnectConfigurationRequest struct {
	ctx context.Context
	ApiService *ConnectConfigurationsAPIService
	accountId string
	connectCustomConfiguration *ConnectCustomConfiguration
}

func (r ApiConnectPostConnectConfigurationRequest) ConnectCustomConfiguration(connectCustomConfiguration ConnectCustomConfiguration) ApiConnectPostConnectConfigurationRequest {
	r.connectCustomConfiguration = &connectCustomConfiguration
	return r
}

func (r ApiConnectPostConnectConfigurationRequest) Execute() (*ConnectCustomConfiguration, *http.Response, error) {
	return r.ApiService.ConnectPostConnectConfigurationExecute(r)
}

/*
ConnectPostConnectConfiguration Creates a Connect configuration.

Creates a custom Connect configuration for the specified account.

Connect is a webhook service that provides updates when certain events occur in your eSignature workflows. You can use this endpoint to create:
* Account-level Connect configurations to listen for events related to any envelopes sent by one or more account users
* Recipient Connect configurations that are triggered when one or more of your account users receive an envelope

To set an account-level configuration, set `configurationType` to **custom.**
To set a Recipient Connect configuration, set `configurationType` to **customrecipient.**

If you want to listen for events on only one envelope, use the [eventNotification](/docs/esign-rest-api/reference/envelopes/envelopes/create/#schema__envelopedefinition_eventnotification) object instead.

**Note:** To use this function, you must be an account administrator and Connect must be enabled on your account.

## Data models

There are four possible data models for your Connect configuration. Consider:
* Do you want the data in JSON or XML?
* Do you want events sent individually (SIM) or in aggregate?

DocuSign recommends using the [JSON SIM event model](/platform/webhooks/connect/improved-json-sim-event-model/).

<ds-column>

<ds-step open="false" hideIcon="true">
<h3>JSON SIM (Recommended)</h3>
<div>

Set `deliveryMode` to **SIM** and `eventData.version` to **restv2.1.** Use the `events` property to set the event statuses that will trigger your configuration.

The following sample request shows how to create an envelope-level configuration using JSON SIM:
```
{
  "configurationType": "custom",
  "urlToPublishTo": "YOUR-WEBHOOK-URL",
  "allUsers": "true",
  "name": "jsonSimTest",
  "deliveryMode": "SIM",
  "allowEnvelopePublish": "true",
  "enableLog": "true",
  "eventData": {
      "version": "restv2.1"
  },
  "events": [
      "envelope-sent",
      "envelope-delivered",
      "envelope-completed"
  ]
}
```

The following sample request shows how to create a Recipient Connect configuration using JSON SIM:
```
{
  "configurationType": "customrecipient",
  "urlToPublishTo": "YOUR-WEBHOOK-URL",
  "allUsers": "true",
  "name": "jsonSimTest",
  "deliveryMode": "SIM",
  "allowEnvelopePublish": "true",
  "enableLog": "true",
  "eventData": {
      "version": "restv2.1"
  },
  "events": [
      "recipient-sent",
      "recipient-completed"
  ]
}
```

</div></ds-step>

<ds-step open="false" hideIcon="true">
<h3>JSON Aggregate</h3>
<div>

Set `deliveryMode` to **aggregate** and `eventData.version` to **restv2.1.** Use the `envelopeEvents` or `recipientEvents` property to set the event statuses that will trigger your configuration.

</div></ds-step>

<ds-step open="false" hideIcon="true">
<h3>XML Aggregate</h3>
<div>

Set `deliveryMode` to **aggregate.** Use the `envelopeEvents` or `recipientEvents` property to set the event statuses that will trigger your configuration.

</div></ds-step>

<ds-step open="false" hideIcon="true">
<h3>XML SIM (Legacy apps only)</h3>
<div>

**Note:** This model [will be deprecated](https://www.docusign.com/blog/developers/docusign-connect-xml-sim-messaging-format-deprecated). 

Set `deliveryMode` to **SIM.** Use the `envelopeEvents` or `recipientEvents` property to set the event statuses that will trigger your configuration.

</div></ds-step>
</ds-column>

## Troubleshooting

If your configuration is not working, check the following.

* Connect must be enabled for your account to use this function.
* If you are using `envelopeEvents` or `recipientEvents`, make sure that the event values are sentence case, not lowercase.
* Make sure you have either set `allUsers` to **true** or set `userIds` to a non-empty array of IDs.
* By default, this endpoint creates a disabled configuration. To enable the configuration immediately, set the body parameter `allowEnvelopePublish` to **true.** You can also enable the configuration in the UI.
* To check if events are being emitted, set `enableLog` to **true** to view event logs in the Connect console.

## Related topics

* For more information about Connect, see the [DocuSign Connect guide](/platform/webhooks/connect/).
* Use the MyAPICalls sample app to see an [example of this endpoint](https://myapicalls.sampleapps.docusign.com/scenario/6) using the JSON SIM model.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiConnectPostConnectConfigurationRequest
*/
func (a *ConnectConfigurationsAPIService) ConnectPostConnectConfiguration(ctx context.Context, accountId string) ApiConnectPostConnectConfigurationRequest {
	return ApiConnectPostConnectConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return ConnectCustomConfiguration
func (a *ConnectConfigurationsAPIService) ConnectPostConnectConfigurationExecute(r ApiConnectPostConnectConfigurationRequest) (*ConnectCustomConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectCustomConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectConfigurationsAPIService.ConnectPostConnectConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/connect"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connectCustomConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectPutConnectConfigurationRequest struct {
	ctx context.Context
	ApiService *ConnectConfigurationsAPIService
	accountId string
	connectCustomConfiguration *ConnectCustomConfiguration
}

func (r ApiConnectPutConnectConfigurationRequest) ConnectCustomConfiguration(connectCustomConfiguration ConnectCustomConfiguration) ApiConnectPutConnectConfigurationRequest {
	r.connectCustomConfiguration = &connectCustomConfiguration
	return r
}

func (r ApiConnectPutConnectConfigurationRequest) Execute() (*ConnectCustomConfiguration, *http.Response, error) {
	return r.ApiService.ConnectPutConnectConfigurationExecute(r)
}

/*
ConnectPutConnectConfiguration Updates a specified Connect configuration.

Updates the specified DocuSign Connect configuration in your account. To enable the configuration, set the `allowEnvelopePublish` property to **true.**

After any updates, test your configuration to make sure it works as expected.

**Note:** To use this function, you must be an account administrator and Connect must be enabled on your account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiConnectPutConnectConfigurationRequest
*/
func (a *ConnectConfigurationsAPIService) ConnectPutConnectConfiguration(ctx context.Context, accountId string) ApiConnectPutConnectConfigurationRequest {
	return ApiConnectPutConnectConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return ConnectCustomConfiguration
func (a *ConnectConfigurationsAPIService) ConnectPutConnectConfigurationExecute(r ApiConnectPutConnectConfigurationRequest) (*ConnectCustomConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectCustomConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectConfigurationsAPIService.ConnectPutConnectConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/connect"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connectCustomConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
