/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AccountsAPIService AccountsAPI service
type AccountsAPIService service

type ApiAccountsDeleteAccountRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
	redactUserData *string
}

func (r ApiAccountsDeleteAccountRequest) RedactUserData(redactUserData string) ApiAccountsDeleteAccountRequest {
	r.redactUserData = &redactUserData
	return r
}

func (r ApiAccountsDeleteAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.AccountsDeleteAccountExecute(r)
}

/*
AccountsDeleteAccount Deletes the specified account.

This closes the specified account. You must be an account admin to close your account. Once closed, an account must be reopened by DocuSign.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiAccountsDeleteAccountRequest
*/
func (a *AccountsAPIService) AccountsDeleteAccount(ctx context.Context, accountId string) ApiAccountsDeleteAccountRequest {
	return ApiAccountsDeleteAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *AccountsAPIService) AccountsDeleteAccountExecute(r ApiAccountsDeleteAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.AccountsDeleteAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.redactUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redact_user_data", r.redactUserData, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAccountsGetAccountRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
	includeAccountSettings *string
}

// When **true,** includes account settings in the response. The default value is **false.**
func (r ApiAccountsGetAccountRequest) IncludeAccountSettings(includeAccountSettings string) ApiAccountsGetAccountRequest {
	r.includeAccountSettings = &includeAccountSettings
	return r
}

func (r ApiAccountsGetAccountRequest) Execute() (*AccountInformation, *http.Response, error) {
	return r.ApiService.AccountsGetAccountExecute(r)
}

/*
AccountsGetAccount Retrieves the account information for the specified account.

Retrieves the account information for the specified account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiAccountsGetAccountRequest
*/
func (a *AccountsAPIService) AccountsGetAccount(ctx context.Context, accountId string) ApiAccountsGetAccountRequest {
	return ApiAccountsGetAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return AccountInformation
func (a *AccountsAPIService) AccountsGetAccountExecute(r ApiAccountsGetAccountRequest) (*AccountInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.AccountsGetAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeAccountSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_account_settings", r.includeAccountSettings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsGetProvisioningRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
}

func (r ApiAccountsGetProvisioningRequest) Execute() (*ProvisioningInformation, *http.Response, error) {
	return r.ApiService.AccountsGetProvisioningExecute(r)
}

/*
AccountsGetProvisioning Retrieves the account provisioning information for the account.

Retrieves the account provisioning information for the account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountsGetProvisioningRequest
*/
func (a *AccountsAPIService) AccountsGetProvisioning(ctx context.Context) ApiAccountsGetProvisioningRequest {
	return ApiAccountsGetProvisioningRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProvisioningInformation
func (a *AccountsAPIService) AccountsGetProvisioningExecute(r ApiAccountsGetProvisioningRequest) (*ProvisioningInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProvisioningInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.AccountsGetProvisioning")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/provisioning"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsPostAccountsRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	newAccountDefinition *NewAccountDefinition
}

func (r ApiAccountsPostAccountsRequest) NewAccountDefinition(newAccountDefinition NewAccountDefinition) ApiAccountsPostAccountsRequest {
	r.newAccountDefinition = &newAccountDefinition
	return r
}

func (r ApiAccountsPostAccountsRequest) Execute() (*NewAccountSummary, *http.Response, error) {
	return r.ApiService.AccountsPostAccountsExecute(r)
}

/*
AccountsPostAccounts Creates new accounts.

Creates new DocuSign accounts.
You can use this method to create
a single account
or up to 100 accounts at a time.

**Note:**  This method is restricted to partner integrations.
You must work with DocuSign Professional Services
or DocuSign Business Development,
who will provide you with the Distributor Code
and Distributor Password
that you need to include in the request body.


When creating a single account,
the body of the request is a
[`newAccountRequest`][newAccountRequest]
object.

Example:

```
{
  "newAccountRequest": [
    {
      "accountName":"Test Account",
      "distributorCode":"MY_DIST_CODE",
      "distributorPassword":"MY_DIST_PWD",
      "initialUser":{
        "email":"user@emaildomain.com",
        "firstName":"John",
        "middleName": "Harry",
        "lastName":"Doe",
        "suffixName": "",
        "userName": "John Doe",
        "jobTitle": "Engineer",
        "company": "Test Company"
      },
      "addressInformation":{
        "address1": "1234 Main Street",
        "address2": "Suite 100",
        "city": "Seattle",
        "state": "WA",
        "postalCode": "98101",
        "country": "US",
        "phone": "1234567890",
        "fax": "1234567891"
      },
      "planInformation":{
        "planId":"37085696-xxxx-xxxx-xxxx-7ea067752959"
      },
      "referralInformation":{
        "includedSeats": "1",
        "referralCode": "code",
        "referrerName": "name"
      }
    }
  ]
}

```
If the request succeeds,
it returns a
201 (Created) HTTP response code.
The response returns the new account ID, password, and the default user
information for each newly created account.


When creating multiple accounts,
the body of the request is a
`newAccountRequests`
object,
which contains one or more
[`newAccountDefinition`][newAccountDefinition]
objects.
You can create up to 100 new accounts
at a time this way.

The body for a multi-account
creation request
looks like this in JSON:

```
{
  "newAccountRequests": [
    {
      "accountName": "accountone",
      . . .
    },
    {
      "accountName": "accounttwo",
      . . .
    }
  ]
}
```

A multi-account request
looks like this in XML:

```
<newAccountsDefinition xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.docusign.com/restapi">
  <newAccountRequests>
    <newAccountDefinition>
      . . .
    </newAccountDefinition>
    <newAccountDefinition>
      . . .
    </newAccountDefinition>
  </newAccountRequests>
</newAccountsDefinition>
```

A multi-account creation request
may succeed (report a 201 code)
even if some accounts could not be created.
In this case, the `errorDetails` property
in the response contains specific information
about the failure.



[newAccountDefinition]: #/definitions/newAccountDefinition
[nameValue]: #/definitions/nameValue
[newAccountRequest]: #/definitions/newAccountRequest


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountsPostAccountsRequest
*/
func (a *AccountsAPIService) AccountsPostAccounts(ctx context.Context) ApiAccountsPostAccountsRequest {
	return ApiAccountsPostAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NewAccountSummary
func (a *AccountsAPIService) AccountsPostAccountsExecute(r ApiAccountsPostAccountsRequest) (*NewAccountSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NewAccountSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.AccountsPostAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.newAccountDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBillingChargesGetAccountBillingChargesRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
	includeCharges *string
}

// Specifies which billing charges to return. Valid values are:  * envelopes * seats 
func (r ApiBillingChargesGetAccountBillingChargesRequest) IncludeCharges(includeCharges string) ApiBillingChargesGetAccountBillingChargesRequest {
	r.includeCharges = &includeCharges
	return r
}

func (r ApiBillingChargesGetAccountBillingChargesRequest) Execute() (*BillingChargeResponse, *http.Response, error) {
	return r.ApiService.BillingChargesGetAccountBillingChargesExecute(r)
}

/*
BillingChargesGetAccountBillingCharges Gets list of recurring and usage charges for the account.

Retrieves the list of recurring and usage charges for the account. This can be used to determine the charge structure and usage of charge plan items. 

Privileges required: account administrator 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiBillingChargesGetAccountBillingChargesRequest
*/
func (a *AccountsAPIService) BillingChargesGetAccountBillingCharges(ctx context.Context, accountId string) ApiBillingChargesGetAccountBillingChargesRequest {
	return ApiBillingChargesGetAccountBillingChargesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return BillingChargeResponse
func (a *AccountsAPIService) BillingChargesGetAccountBillingChargesExecute(r ApiBillingChargesGetAccountBillingChargesRequest) (*BillingChargeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BillingChargeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.BillingChargesGetAccountBillingCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/billing_charges"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeCharges != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_charges", r.includeCharges, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCaptiveRecipientsDeleteCaptiveRecipientsPartRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
	recipientPart string
	captiveRecipientInformation *CaptiveRecipientInformation
}

func (r ApiCaptiveRecipientsDeleteCaptiveRecipientsPartRequest) CaptiveRecipientInformation(captiveRecipientInformation CaptiveRecipientInformation) ApiCaptiveRecipientsDeleteCaptiveRecipientsPartRequest {
	r.captiveRecipientInformation = &captiveRecipientInformation
	return r
}

func (r ApiCaptiveRecipientsDeleteCaptiveRecipientsPartRequest) Execute() (*CaptiveRecipientInformation, *http.Response, error) {
	return r.ApiService.CaptiveRecipientsDeleteCaptiveRecipientsPartExecute(r)
}

/*
CaptiveRecipientsDeleteCaptiveRecipientsPart Deletes the signature for one or more captive recipient records.

This method deletes the signature for one or more captive recipient records. It is primarily used for testing. This functionality provides a way to reset the signature associated with a client user ID so that a new signature can be created the next time the client user ID is used.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param recipientPart Signature is the only supported value. 
 @return ApiCaptiveRecipientsDeleteCaptiveRecipientsPartRequest
*/
func (a *AccountsAPIService) CaptiveRecipientsDeleteCaptiveRecipientsPart(ctx context.Context, accountId string, recipientPart string) ApiCaptiveRecipientsDeleteCaptiveRecipientsPartRequest {
	return ApiCaptiveRecipientsDeleteCaptiveRecipientsPartRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		recipientPart: recipientPart,
	}
}

// Execute executes the request
//  @return CaptiveRecipientInformation
func (a *AccountsAPIService) CaptiveRecipientsDeleteCaptiveRecipientsPartExecute(r ApiCaptiveRecipientsDeleteCaptiveRecipientsPartRequest) (*CaptiveRecipientInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CaptiveRecipientInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.CaptiveRecipientsDeleteCaptiveRecipientsPart")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/captive_recipients/{recipientPart}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recipientPart"+"}", url.PathEscape(parameterValueToString(r.recipientPart, "recipientPart")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.captiveRecipientInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopePurgeConfigurationGetEnvelopePurgeConfigurationRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
}

func (r ApiEnvelopePurgeConfigurationGetEnvelopePurgeConfigurationRequest) Execute() (*EnvelopePurgeConfiguration, *http.Response, error) {
	return r.ApiService.EnvelopePurgeConfigurationGetEnvelopePurgeConfigurationExecute(r)
}

/*
EnvelopePurgeConfigurationGetEnvelopePurgeConfiguration Gets the envelope purge configuration for an account.

An envelope purge configuration enables account administrators to permanently remove documents and their field data from completed and voided envelopes after a specified retention period (`retentionDays`). This method retrieves the current envelope purge configuration for your account.

**Note:** To use this method, you must be an account administrator.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiEnvelopePurgeConfigurationGetEnvelopePurgeConfigurationRequest
*/
func (a *AccountsAPIService) EnvelopePurgeConfigurationGetEnvelopePurgeConfiguration(ctx context.Context, accountId string) ApiEnvelopePurgeConfigurationGetEnvelopePurgeConfigurationRequest {
	return ApiEnvelopePurgeConfigurationGetEnvelopePurgeConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return EnvelopePurgeConfiguration
func (a *AccountsAPIService) EnvelopePurgeConfigurationGetEnvelopePurgeConfigurationExecute(r ApiEnvelopePurgeConfigurationGetEnvelopePurgeConfigurationRequest) (*EnvelopePurgeConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopePurgeConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.EnvelopePurgeConfigurationGetEnvelopePurgeConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/settings/envelope_purge_configuration"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopePurgeConfigurationPutEnvelopePurgeConfigurationRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
	envelopePurgeConfiguration *EnvelopePurgeConfiguration
}

func (r ApiEnvelopePurgeConfigurationPutEnvelopePurgeConfigurationRequest) EnvelopePurgeConfiguration(envelopePurgeConfiguration EnvelopePurgeConfiguration) ApiEnvelopePurgeConfigurationPutEnvelopePurgeConfigurationRequest {
	r.envelopePurgeConfiguration = &envelopePurgeConfiguration
	return r
}

func (r ApiEnvelopePurgeConfigurationPutEnvelopePurgeConfigurationRequest) Execute() (*EnvelopePurgeConfiguration, *http.Response, error) {
	return r.ApiService.EnvelopePurgeConfigurationPutEnvelopePurgeConfigurationExecute(r)
}

/*
EnvelopePurgeConfigurationPutEnvelopePurgeConfiguration Sets the envelope purge configuration for an account.

An envelope purge configuration enables account administrators to permanently remove documents and their field data from completed and voided envelopes after a specified retention period (`retentionDays`). This method sets the envelope purge configuration for your account.

**Note:** To use this method, you must be an account administrator.

For more information, see [Purge Envelopes](https://support.docusign.com/s/document-item?bundleId=oeq1643226594604&topicId=edo1578456348066.html).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiEnvelopePurgeConfigurationPutEnvelopePurgeConfigurationRequest
*/
func (a *AccountsAPIService) EnvelopePurgeConfigurationPutEnvelopePurgeConfiguration(ctx context.Context, accountId string) ApiEnvelopePurgeConfigurationPutEnvelopePurgeConfigurationRequest {
	return ApiEnvelopePurgeConfigurationPutEnvelopePurgeConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return EnvelopePurgeConfiguration
func (a *AccountsAPIService) EnvelopePurgeConfigurationPutEnvelopePurgeConfigurationExecute(r ApiEnvelopePurgeConfigurationPutEnvelopePurgeConfigurationRequest) (*EnvelopePurgeConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopePurgeConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.EnvelopePurgeConfigurationPutEnvelopePurgeConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/settings/envelope_purge_configuration"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopePurgeConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNotificationDefaultsGetNotificationDefaultsRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
}

func (r ApiNotificationDefaultsGetNotificationDefaultsRequest) Execute() (*NotificationDefaults, *http.Response, error) {
	return r.ApiService.NotificationDefaultsGetNotificationDefaultsExecute(r)
}

/*
NotificationDefaultsGetNotificationDefaults Gets envelope notification defaults.

This method returns the default settings for the email notifications that signers and senders receive about envelopes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiNotificationDefaultsGetNotificationDefaultsRequest
*/
func (a *AccountsAPIService) NotificationDefaultsGetNotificationDefaults(ctx context.Context, accountId string) ApiNotificationDefaultsGetNotificationDefaultsRequest {
	return ApiNotificationDefaultsGetNotificationDefaultsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return NotificationDefaults
func (a *AccountsAPIService) NotificationDefaultsGetNotificationDefaultsExecute(r ApiNotificationDefaultsGetNotificationDefaultsRequest) (*NotificationDefaults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationDefaults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.NotificationDefaultsGetNotificationDefaults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/settings/notification_defaults"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNotificationDefaultsPutNotificationDefaultsRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
	notificationDefaults *NotificationDefaults
}

func (r ApiNotificationDefaultsPutNotificationDefaultsRequest) NotificationDefaults(notificationDefaults NotificationDefaults) ApiNotificationDefaultsPutNotificationDefaultsRequest {
	r.notificationDefaults = &notificationDefaults
	return r
}

func (r ApiNotificationDefaultsPutNotificationDefaultsRequest) Execute() (*NotificationDefaults, *http.Response, error) {
	return r.ApiService.NotificationDefaultsPutNotificationDefaultsExecute(r)
}

/*
NotificationDefaultsPutNotificationDefaults Updates envelope notification default settings.

This method changes the default settings for the email notifications that signers and senders receive about envelopes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiNotificationDefaultsPutNotificationDefaultsRequest
*/
func (a *AccountsAPIService) NotificationDefaultsPutNotificationDefaults(ctx context.Context, accountId string) ApiNotificationDefaultsPutNotificationDefaultsRequest {
	return ApiNotificationDefaultsPutNotificationDefaultsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return NotificationDefaults
func (a *AccountsAPIService) NotificationDefaultsPutNotificationDefaultsExecute(r ApiNotificationDefaultsPutNotificationDefaultsRequest) (*NotificationDefaults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationDefaults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.NotificationDefaultsPutNotificationDefaults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/settings/notification_defaults"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationDefaults
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecipientNamesGetRecipientNamesRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
	email *string
}

// (Required) The email address for which you want to retrieve recipient names.
func (r ApiRecipientNamesGetRecipientNamesRequest) Email(email string) ApiRecipientNamesGetRecipientNamesRequest {
	r.email = &email
	return r
}

func (r ApiRecipientNamesGetRecipientNamesRequest) Execute() (*RecipientNamesResponse, *http.Response, error) {
	return r.ApiService.RecipientNamesGetRecipientNamesExecute(r)
}

/*
RecipientNamesGetRecipientNames Gets the recipient names associated with an email address.

Retrieves a list of all of the names associated with the email address that you pass in. This list can include variants of a single recipient's name that are used for signing, as well as the names of multiple different recipients.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiRecipientNamesGetRecipientNamesRequest
*/
func (a *AccountsAPIService) RecipientNamesGetRecipientNames(ctx context.Context, accountId string) ApiRecipientNamesGetRecipientNamesRequest {
	return ApiRecipientNamesGetRecipientNamesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return RecipientNamesResponse
func (a *AccountsAPIService) RecipientNamesGetRecipientNamesExecute(r ApiRecipientNamesGetRecipientNamesRequest) (*RecipientNamesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RecipientNamesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.RecipientNamesGetRecipientNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/recipient_names"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSettingsGetSettingsRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
}

func (r ApiSettingsGetSettingsRequest) Execute() (*AccountSettingsInformation, *http.Response, error) {
	return r.ApiService.SettingsGetSettingsExecute(r)
}

/*
SettingsGetSettings Gets account settings information.

Retrieves the account settings information for the specified account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiSettingsGetSettingsRequest
*/
func (a *AccountsAPIService) SettingsGetSettings(ctx context.Context, accountId string) ApiSettingsGetSettingsRequest {
	return ApiSettingsGetSettingsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return AccountSettingsInformation
func (a *AccountsAPIService) SettingsGetSettingsExecute(r ApiSettingsGetSettingsRequest) (*AccountSettingsInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountSettingsInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.SettingsGetSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSettingsPutSettingsRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
	accountSettingsInformation *AccountSettingsInformation
}

func (r ApiSettingsPutSettingsRequest) AccountSettingsInformation(accountSettingsInformation AccountSettingsInformation) ApiSettingsPutSettingsRequest {
	r.accountSettingsInformation = &accountSettingsInformation
	return r
}

func (r ApiSettingsPutSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.SettingsPutSettingsExecute(r)
}

/*
SettingsPutSettings Updates the account settings for an account.

Updates the account settings for the specified account.

Although the request body for this method
is a complete
`accountSettingsInformation` object,
you only need to provide
the properties that
you are updating.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiSettingsPutSettingsRequest
*/
func (a *AccountsAPIService) SettingsPutSettings(ctx context.Context, accountId string) ApiSettingsPutSettingsRequest {
	return ApiSettingsPutSettingsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *AccountsAPIService) SettingsPutSettingsExecute(r ApiSettingsPutSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.SettingsPutSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountSettingsInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSharedAccessGetSharedAccessRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
	count *string
	envelopesNotSharedUserStatus *string
	folderIds *string
	itemType *string
	searchText *string
	shared *string
	startPosition *string
	userIds *string
}

// The maximum number of results to return.  Use &#x60;start_position&#x60; to specify the number of results to skip.  Default: &#x60;1000&#x60; 
func (r ApiSharedAccessGetSharedAccessRequest) Count(count string) ApiSharedAccessGetSharedAccessRequest {
	r.count = &count
	return r
}

// This query parameter works in conjunction with &#x60;user_ids&#x60;. When you specify one of the following user statuses, the query limits the results to only users that match the specified status: - &#x60;ActivationRequired&#x60;: Membership Activation required - &#x60;ActivationSent&#x60;: Membership activation sent to user - &#x60;Active&#x60;: User Membership is active - &#x60;Closed&#x60;: User Membership is closed - &#x60;Disabled&#x60;: User Membership is disabled
func (r ApiSharedAccessGetSharedAccessRequest) EnvelopesNotSharedUserStatus(envelopesNotSharedUserStatus string) ApiSharedAccessGetSharedAccessRequest {
	r.envelopesNotSharedUserStatus = &envelopesNotSharedUserStatus
	return r
}

// A comma-separated list of folder IDs for which to return shared item information. If &#x60;item_type&#x60; is set to &#x60;folders&#x60;, at least one folder ID is required.
func (r ApiSharedAccessGetSharedAccessRequest) FolderIds(folderIds string) ApiSharedAccessGetSharedAccessRequest {
	r.folderIds = &folderIds
	return r
}

// Specifies the type of shared item being requested. Valid values:  - &#x60;envelopes&#x60;: Get information about envelope sharing between users. - &#x60;templates&#x60;: Get information about template sharing among users and groups. - &#x60;folders&#x60;: Get information about folder sharing among users and groups. 
func (r ApiSharedAccessGetSharedAccessRequest) ItemType(itemType string) ApiSharedAccessGetSharedAccessRequest {
	r.itemType = &itemType
	return r
}

// Filter user names based on the specified string. The wild-card &#39;*&#39; (asterisk) can be used in the string.
func (r ApiSharedAccessGetSharedAccessRequest) SearchText(searchText string) ApiSharedAccessGetSharedAccessRequest {
	r.searchText = &searchText
	return r
}

// A comma-separated list of sharing filters that specifies which users appear in the response.   - &#x60;not_shared&#x60;: The response lists users who do not share items of &#x60;item_type&#x60; with the current user.  - &#x60;shared_to&#x60;: The response lists users in &#x60;user_list&#x60; who are sharing items to current user.  - &#x60;shared_from&#x60;: The response lists users in &#x60;user_list&#x60; who are sharing items from the current user.  - &#x60;shared_to_and_from&#x60;: The response lists users in &#x60;user_list&#x60; who are sharing items to and from the current user.  If the current user does not have administrative privileges, only the &#x60;shared_to&#x60; option is valid.
func (r ApiSharedAccessGetSharedAccessRequest) Shared(shared string) ApiSharedAccessGetSharedAccessRequest {
	r.shared = &shared
	return r
}

// The zero-based index of the result from which to start returning results.  Use with &#x60;count&#x60; to limit the number of results.  The default value is &#x60;0&#x60;. 
func (r ApiSharedAccessGetSharedAccessRequest) StartPosition(startPosition string) ApiSharedAccessGetSharedAccessRequest {
	r.startPosition = &startPosition
	return r
}

// A comma-separated list of user IDs for whom the shared item information is being requested.
func (r ApiSharedAccessGetSharedAccessRequest) UserIds(userIds string) ApiSharedAccessGetSharedAccessRequest {
	r.userIds = &userIds
	return r
}

func (r ApiSharedAccessGetSharedAccessRequest) Execute() (*AccountSharedAccess, *http.Response, error) {
	return r.ApiService.SharedAccessGetSharedAccessExecute(r)
}

/*
SharedAccessGetSharedAccess Reserved: Gets the shared item status for one or more users.

Retrieves shared item status for one or more users and types of items.

Users with account administration privileges can retrieve shared access information for all account users. Users without account administrator privileges can only retrieve shared access information for themselves, and the returned information is limited to retrieving the status of the members of the account that are sharing their folders to the user. This is equivalent to setting the `shared` parameter to `shared_from`.

**Note:** This endpoint returns the shared status for the legacy Shared Envelopes feature. To use the new Shared Access feature, use the [Authorizations resource](/docs/esign-rest-api/reference/accounts/authorizations/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiSharedAccessGetSharedAccessRequest
*/
func (a *AccountsAPIService) SharedAccessGetSharedAccess(ctx context.Context, accountId string) ApiSharedAccessGetSharedAccessRequest {
	return ApiSharedAccessGetSharedAccessRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return AccountSharedAccess
func (a *AccountsAPIService) SharedAccessGetSharedAccessExecute(r ApiSharedAccessGetSharedAccessRequest) (*AccountSharedAccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountSharedAccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.SharedAccessGetSharedAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/shared_access"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.envelopesNotSharedUserStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "envelopes_not_shared_user_status", r.envelopesNotSharedUserStatus, "")
	}
	if r.folderIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folder_ids", r.folderIds, "")
	}
	if r.itemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "item_type", r.itemType, "")
	}
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_text", r.searchText, "")
	}
	if r.shared != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shared", r.shared, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	if r.userIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_ids", r.userIds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharedAccessPutSharedAccessRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
	itemType *string
	preserveExistingSharedAccess *string
	userIds *string
	accountSharedAccess *AccountSharedAccess
}

// Specifies the type of shared item being set: - &#x60;envelopes&#x60;: Set envelope sharing between users. - &#x60;templates&#x60;: Set information about template sharing among users and groups. - &#x60;folders&#x60;: Get information about folder sharing among users and groups. 
func (r ApiSharedAccessPutSharedAccessRequest) ItemType(itemType string) ApiSharedAccessPutSharedAccessRequest {
	r.itemType = &itemType
	return r
}

// When **true,** preserve the existing shared access settings.
func (r ApiSharedAccessPutSharedAccessRequest) PreserveExistingSharedAccess(preserveExistingSharedAccess string) ApiSharedAccessPutSharedAccessRequest {
	r.preserveExistingSharedAccess = &preserveExistingSharedAccess
	return r
}

// A comma-separated list of IDs for users whose shared item access is being set.
func (r ApiSharedAccessPutSharedAccessRequest) UserIds(userIds string) ApiSharedAccessPutSharedAccessRequest {
	r.userIds = &userIds
	return r
}

func (r ApiSharedAccessPutSharedAccessRequest) AccountSharedAccess(accountSharedAccess AccountSharedAccess) ApiSharedAccessPutSharedAccessRequest {
	r.accountSharedAccess = &accountSharedAccess
	return r
}

func (r ApiSharedAccessPutSharedAccessRequest) Execute() (*AccountSharedAccess, *http.Response, error) {
	return r.ApiService.SharedAccessPutSharedAccessExecute(r)
}

/*
SharedAccessPutSharedAccess Reserved: Sets the shared access information for users.

This sets the shared access status for one or more users or templates.

When setting user shared access, only users with account administration privileges can set shared access status for envelopes.

When setting template shared access, only users who own a template and have sharing permission or with account administration privileges can set shared access for templates.

Changes to the shared items status are not additive. The change always replaces the current status.

To change template shared access, add the query parameter `item_type` = `templates` to the request. When this is set, the user and envelopes properties are not required.

**Note:** This functionality is a newer version of the [Update Group Share](/docs/esign-rest-api/reference/templates/templates/updategroupshare/) functionality.



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiSharedAccessPutSharedAccessRequest
*/
func (a *AccountsAPIService) SharedAccessPutSharedAccess(ctx context.Context, accountId string) ApiSharedAccessPutSharedAccessRequest {
	return ApiSharedAccessPutSharedAccessRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return AccountSharedAccess
func (a *AccountsAPIService) SharedAccessPutSharedAccessExecute(r ApiSharedAccessPutSharedAccessRequest) (*AccountSharedAccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountSharedAccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.SharedAccessPutSharedAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/shared_access"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.itemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "item_type", r.itemType, "")
	}
	if r.preserveExistingSharedAccess != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preserve_existing_shared_access", r.preserveExistingSharedAccess, "")
	}
	if r.userIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_ids", r.userIds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountSharedAccess
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSupportedLanguagesGetSupportedLanguagesRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
}

func (r ApiSupportedLanguagesGetSupportedLanguagesRequest) Execute() (*SupportedLanguages, *http.Response, error) {
	return r.ApiService.SupportedLanguagesGetSupportedLanguagesExecute(r)
}

/*
SupportedLanguagesGetSupportedLanguages Gets the supported languages for envelope recipients.

Retrieves a list of supported languages that you can set for an individual recipient when creating an envelope, as well as their simple type enumeration values. These are the languages that you can set for the standard email format and signing view for each recipient.

For example, in the recipient's email notification, this setting affects elements such as the standard introductory text describing the request to sign. It also determines the language used for buttons and tabs in both the email notification and the signing experience.

**Note:** Setting a language for a recipient affects only the DocuSign standard text. Any custom text that you enter for the `emailBody` and `emailSubject` of the notification is not translated, and appears exactly as you enter it.

For more information, see [Set Recipient Language and Specify Custom Email Messages](https://support.docusign.com/s/document-item?bundleId=gbo1643332197980&topicId=wxf1578456494201.html).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiSupportedLanguagesGetSupportedLanguagesRequest
*/
func (a *AccountsAPIService) SupportedLanguagesGetSupportedLanguages(ctx context.Context, accountId string) ApiSupportedLanguagesGetSupportedLanguagesRequest {
	return ApiSupportedLanguagesGetSupportedLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return SupportedLanguages
func (a *AccountsAPIService) SupportedLanguagesGetSupportedLanguagesExecute(r ApiSupportedLanguagesGetSupportedLanguagesRequest) (*SupportedLanguages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SupportedLanguages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.SupportedLanguagesGetSupportedLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/supported_languages"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnsupportedFileTypesGetUnsupportedFileTypesRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountId string
}

func (r ApiUnsupportedFileTypesGetUnsupportedFileTypesRequest) Execute() (*FileTypeList, *http.Response, error) {
	return r.ApiService.UnsupportedFileTypesGetUnsupportedFileTypesExecute(r)
}

/*
UnsupportedFileTypesGetUnsupportedFileTypes Gets a list of unsupported file types.

Retrieves a list of file types (mime-types and file-extensions) that are not supported for upload through the DocuSign system.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiUnsupportedFileTypesGetUnsupportedFileTypesRequest
*/
func (a *AccountsAPIService) UnsupportedFileTypesGetUnsupportedFileTypes(ctx context.Context, accountId string) ApiUnsupportedFileTypesGetUnsupportedFileTypesRequest {
	return ApiUnsupportedFileTypesGetUnsupportedFileTypesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return FileTypeList
func (a *AccountsAPIService) UnsupportedFileTypesGetUnsupportedFileTypesExecute(r ApiUnsupportedFileTypesGetUnsupportedFileTypesRequest) (*FileTypeList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileTypeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.UnsupportedFileTypesGetUnsupportedFileTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/unsupported_file_types"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
