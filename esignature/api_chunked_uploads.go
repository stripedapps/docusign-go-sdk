/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ChunkedUploadsAPIService ChunkedUploadsAPI service
type ChunkedUploadsAPIService service

type ApiChunkedUploadsDeleteChunkedUploadRequest struct {
	ctx context.Context
	ApiService *ChunkedUploadsAPIService
	accountId string
	chunkedUploadId string
}

func (r ApiChunkedUploadsDeleteChunkedUploadRequest) Execute() (*ChunkedUploadResponse, *http.Response, error) {
	return r.ApiService.ChunkedUploadsDeleteChunkedUploadExecute(r)
}

/*
ChunkedUploadsDeleteChunkedUpload Deletes a chunked upload.

Deletes a chunked upload that has been committed but not yet consumed.

This method cannot be used to delete the following types of chunked uploads, which the system deletes automatically:


- Chunked uploads that have been consumed by use in another API call.
- Expired chunked uploads.

**Note:** If you are aware of a chunked upload that can be discarded, the best practice is to explicitly delete it. If you wait for the system to automatically delete it after it expires, the chunked upload will continue to count against your quota.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param chunkedUploadId The ID of the chunked upload. 
 @return ApiChunkedUploadsDeleteChunkedUploadRequest
*/
func (a *ChunkedUploadsAPIService) ChunkedUploadsDeleteChunkedUpload(ctx context.Context, accountId string, chunkedUploadId string) ApiChunkedUploadsDeleteChunkedUploadRequest {
	return ApiChunkedUploadsDeleteChunkedUploadRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		chunkedUploadId: chunkedUploadId,
	}
}

// Execute executes the request
//  @return ChunkedUploadResponse
func (a *ChunkedUploadsAPIService) ChunkedUploadsDeleteChunkedUploadExecute(r ApiChunkedUploadsDeleteChunkedUploadRequest) (*ChunkedUploadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChunkedUploadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChunkedUploadsAPIService.ChunkedUploadsDeleteChunkedUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/chunked_uploads/{chunkedUploadId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chunkedUploadId"+"}", url.PathEscape(parameterValueToString(r.chunkedUploadId, "chunkedUploadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChunkedUploadsGetChunkedUploadRequest struct {
	ctx context.Context
	ApiService *ChunkedUploadsAPIService
	accountId string
	chunkedUploadId string
	include *string
}

// (Optional) This parameter enables you to include additional attribute data in the response. The valid value for this method is &#x60;checksum&#x60;, which returns an SHA256 checksum of the content of the chunked upload in the response. You can use compare this checksum against your own checksum of the original content to verify that there are no missing parts before you attempt to commit the chunked upload.
func (r ApiChunkedUploadsGetChunkedUploadRequest) Include(include string) ApiChunkedUploadsGetChunkedUploadRequest {
	r.include = &include
	return r
}

func (r ApiChunkedUploadsGetChunkedUploadRequest) Execute() (*ChunkedUploadResponse, *http.Response, error) {
	return r.ApiService.ChunkedUploadsGetChunkedUploadExecute(r)
}

/*
ChunkedUploadsGetChunkedUpload Retrieves metadata about a chunked upload.

Returns the details (but not the content) about a chunked upload.

**Note:** You cannot obtain details about a chunked upload that has expired, been deleted, or consumed by other actions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param chunkedUploadId The ID of the chunked upload. 
 @return ApiChunkedUploadsGetChunkedUploadRequest
*/
func (a *ChunkedUploadsAPIService) ChunkedUploadsGetChunkedUpload(ctx context.Context, accountId string, chunkedUploadId string) ApiChunkedUploadsGetChunkedUploadRequest {
	return ApiChunkedUploadsGetChunkedUploadRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		chunkedUploadId: chunkedUploadId,
	}
}

// Execute executes the request
//  @return ChunkedUploadResponse
func (a *ChunkedUploadsAPIService) ChunkedUploadsGetChunkedUploadExecute(r ApiChunkedUploadsGetChunkedUploadRequest) (*ChunkedUploadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChunkedUploadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChunkedUploadsAPIService.ChunkedUploadsGetChunkedUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/chunked_uploads/{chunkedUploadId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chunkedUploadId"+"}", url.PathEscape(parameterValueToString(r.chunkedUploadId, "chunkedUploadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChunkedUploadsPostChunkedUploadsRequest struct {
	ctx context.Context
	ApiService *ChunkedUploadsAPIService
	accountId string
	chunkedUploadRequest *ChunkedUploadRequest
}

func (r ApiChunkedUploadsPostChunkedUploadsRequest) ChunkedUploadRequest(chunkedUploadRequest ChunkedUploadRequest) ApiChunkedUploadsPostChunkedUploadsRequest {
	r.chunkedUploadRequest = &chunkedUploadRequest
	return r
}

func (r ApiChunkedUploadsPostChunkedUploadsRequest) Execute() (*ChunkedUploadResponse, *http.Response, error) {
	return r.ApiService.ChunkedUploadsPostChunkedUploadsExecute(r)
}

/*
ChunkedUploadsPostChunkedUploads Initiate a new chunked upload.

This method initiates a new chunked upload with the first part of the content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiChunkedUploadsPostChunkedUploadsRequest
*/
func (a *ChunkedUploadsAPIService) ChunkedUploadsPostChunkedUploads(ctx context.Context, accountId string) ApiChunkedUploadsPostChunkedUploadsRequest {
	return ApiChunkedUploadsPostChunkedUploadsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return ChunkedUploadResponse
func (a *ChunkedUploadsAPIService) ChunkedUploadsPostChunkedUploadsExecute(r ApiChunkedUploadsPostChunkedUploadsRequest) (*ChunkedUploadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChunkedUploadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChunkedUploadsAPIService.ChunkedUploadsPostChunkedUploads")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/chunked_uploads"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chunkedUploadRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChunkedUploadsPutChunkedUploadPartRequest struct {
	ctx context.Context
	ApiService *ChunkedUploadsAPIService
	accountId string
	chunkedUploadId string
	chunkedUploadPartSeq string
	chunkedUploadRequest *ChunkedUploadRequest
}

func (r ApiChunkedUploadsPutChunkedUploadPartRequest) ChunkedUploadRequest(chunkedUploadRequest ChunkedUploadRequest) ApiChunkedUploadsPutChunkedUploadPartRequest {
	r.chunkedUploadRequest = &chunkedUploadRequest
	return r
}

func (r ApiChunkedUploadsPutChunkedUploadPartRequest) Execute() (*ChunkedUploadResponse, *http.Response, error) {
	return r.ApiService.ChunkedUploadsPutChunkedUploadPartExecute(r)
}

/*
ChunkedUploadsPutChunkedUploadPart Add a chunk to an existing chunked upload.

Adds a chunk or part to an existing chunked upload. After you use the Create method to initiate a new chunked upload and upload the first part, 
use this method to upload subsequent parts.

For simplicity, DocuSign recommends that you upload the parts in their sequential order ( 1,2, 3, 4, etc.). The Create method adds the first part and assigns it the `sequence` value `0`. As a result, DocuSign recommends that you start with a `sequence` value of `1` when you use this method, and continue uploading parts contiguously until you have uploaded the entirety of the original content to DocuSign.

Example:


```
PUT /v2.1/accounts/{accountId}/chunked_uploads/{chunkedUploadId}/1
PUT /v2.1/accounts/{accountId}/chunked_uploads/{chunkedUploadId}/2
PUT /v2.1/accounts/{accountId}/chunked_uploads/{chunkedUploadId}/3
```

**Note:** You cannot replace a part that DocuSign has already received, or add parts to a chunked upload that is already successfully committed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param chunkedUploadId The ID of the chunked upload. 
 @param chunkedUploadPartSeq The sequence or order of the part in the chunked upload. By default, the sequence of the first part that is uploaded as part of the Create request is `0`.  **Note:** You can add parts out of order. However, the chunked upload must consist of a contiguous series of one or more parts before you can successfully commit it.
 @return ApiChunkedUploadsPutChunkedUploadPartRequest
*/
func (a *ChunkedUploadsAPIService) ChunkedUploadsPutChunkedUploadPart(ctx context.Context, accountId string, chunkedUploadId string, chunkedUploadPartSeq string) ApiChunkedUploadsPutChunkedUploadPartRequest {
	return ApiChunkedUploadsPutChunkedUploadPartRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		chunkedUploadId: chunkedUploadId,
		chunkedUploadPartSeq: chunkedUploadPartSeq,
	}
}

// Execute executes the request
//  @return ChunkedUploadResponse
func (a *ChunkedUploadsAPIService) ChunkedUploadsPutChunkedUploadPartExecute(r ApiChunkedUploadsPutChunkedUploadPartRequest) (*ChunkedUploadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChunkedUploadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChunkedUploadsAPIService.ChunkedUploadsPutChunkedUploadPart")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/chunked_uploads/{chunkedUploadId}/{chunkedUploadPartSeq}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chunkedUploadId"+"}", url.PathEscape(parameterValueToString(r.chunkedUploadId, "chunkedUploadId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chunkedUploadPartSeq"+"}", url.PathEscape(parameterValueToString(r.chunkedUploadPartSeq, "chunkedUploadPartSeq")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chunkedUploadRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChunkedUploadsPutChunkedUploadsRequest struct {
	ctx context.Context
	ApiService *ChunkedUploadsAPIService
	accountId string
	chunkedUploadId string
	action *string
}

// (Required) You must use this query parameter with the value &#x60;commit&#x60;, which affirms the request to validate and prepare the chunked upload for use with other API calls.
func (r ApiChunkedUploadsPutChunkedUploadsRequest) Action(action string) ApiChunkedUploadsPutChunkedUploadsRequest {
	r.action = &action
	return r
}

func (r ApiChunkedUploadsPutChunkedUploadsRequest) Execute() (*ChunkedUploadResponse, *http.Response, error) {
	return r.ApiService.ChunkedUploadsPutChunkedUploadsExecute(r)
}

/*
ChunkedUploadsPutChunkedUploads Commit a chunked upload.

This method checks the integrity of a chunked upload and then commits it. When this request is successful, the chunked upload is then ready to be referenced in other API calls.

If the request is unsuccessful, ensure that you have uploaded all of the parts by using the Update method.

**Note:** After you commit a chunked upload, it no longer accepts additional parts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId (Required) The external account number (int) or account ID GUID.
 @param chunkedUploadId (Required) The ID of the chunked upload to commit.
 @return ApiChunkedUploadsPutChunkedUploadsRequest
*/
func (a *ChunkedUploadsAPIService) ChunkedUploadsPutChunkedUploads(ctx context.Context, accountId string, chunkedUploadId string) ApiChunkedUploadsPutChunkedUploadsRequest {
	return ApiChunkedUploadsPutChunkedUploadsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		chunkedUploadId: chunkedUploadId,
	}
}

// Execute executes the request
//  @return ChunkedUploadResponse
func (a *ChunkedUploadsAPIService) ChunkedUploadsPutChunkedUploadsExecute(r ApiChunkedUploadsPutChunkedUploadsRequest) (*ChunkedUploadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChunkedUploadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChunkedUploadsAPIService.ChunkedUploadsPutChunkedUploads")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/chunked_uploads/{chunkedUploadId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chunkedUploadId"+"}", url.PathEscape(parameterValueToString(r.chunkedUploadId, "chunkedUploadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
