/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// UsersAPIService UsersAPI service
type UsersAPIService service

type ApiUserGetUserRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	accountId string
	userId string
	additionalInfo *string
	email *string
}

// Setting this parameter has no effect in this operation.
func (r ApiUserGetUserRequest) AdditionalInfo(additionalInfo string) ApiUserGetUserRequest {
	r.additionalInfo = &additionalInfo
	return r
}

// Setting this parameter has no effect in this operation.
func (r ApiUserGetUserRequest) Email(email string) ApiUserGetUserRequest {
	r.email = &email
	return r
}

func (r ApiUserGetUserRequest) Execute() (*UserInformation, *http.Response, error) {
	return r.ApiService.UserGetUserExecute(r)
}

/*
UserGetUser Gets the user information for a specified user.

Retrieves the user information for the specified user.  For example:

```json
{
  "userName": "Tania Morales",
  "userId": "6b67a1ee-xxxx-xxxx-xxxx-385763624163",
  "userType": "CompanyUser",
  "isAdmin": "False",
  "isNAREnabled": "false",
  "userStatus": "Active",
  "uri": "/users/6b67a1ee-xxxx-xxxx-xxxx-385763624163",
  "email": "examplename42@orobia.net",
  "createdDateTime": "2019-04-01T22:11:56.4570000Z",
  "userAddedToAccountDateTime": "0001-01-01T08:00:00.0000000Z",
  "firstName": "Tania",
  "lastName": "Morales",
  "jobTitle": "",
  "company": "Company",
  "permissionProfileId": "12345678",
  "permissionProfileName": "DocuSign Viewer",
  "userSettings": {. . .},
  "sendActivationOnInvalidLogin": "false",
  "enableConnectForUser": "false",
  "groupList": [. . .],
  "workAddress": {. . .},
  "homeAddress": {. . .},
  "signatureImageUri": "/users/6b67a1ee-xxxx-xxxx-xxxx-385763624163/signatures/0304c47b-xxxx-xxxx-xxxx-c9673963bb50/signature_image",
  "initialsImageUri": "/users/6b67a1ee-xxxx-xxxx-xxxx-385763624163/signatures/0304c47b-xxxx-xxxx-xxxx-c9673963bb50/initials_image",
  "defaultAccountId": "f636f297-xxxx-xxxx-xxxx-8e7a14715950"
}
```



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserGetUserRequest
*/
func (a *UsersAPIService) UserGetUser(ctx context.Context, accountId string, userId string) ApiUserGetUserRequest {
	return ApiUserGetUserRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserInformation
func (a *UsersAPIService) UserGetUserExecute(r ApiUserGetUserRequest) (*UserInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UserGetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.additionalInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additional_info", r.additionalInfo, "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserProfileImageDeleteUserProfileImageRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	accountId string
	userId string
}

func (r ApiUserProfileImageDeleteUserProfileImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserProfileImageDeleteUserProfileImageExecute(r)
}

/*
UserProfileImageDeleteUserProfileImage Deletes the user profile image for the specified user.

Deletes the user profile image from the  specified user's profile.

The userId parameter specified in the endpoint must match the authenticated user's user ID and the user must be a member of the specified account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserProfileImageDeleteUserProfileImageRequest
*/
func (a *UsersAPIService) UserProfileImageDeleteUserProfileImage(ctx context.Context, accountId string, userId string) ApiUserProfileImageDeleteUserProfileImageRequest {
	return ApiUserProfileImageDeleteUserProfileImageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UserProfileImageDeleteUserProfileImageExecute(r ApiUserProfileImageDeleteUserProfileImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UserProfileImageDeleteUserProfileImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/profile/image"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserProfileImageGetUserProfileImageRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	accountId string
	userId string
	encoding *string
}

// Reserved for DocuSign.
func (r ApiUserProfileImageGetUserProfileImageRequest) Encoding(encoding string) ApiUserProfileImageGetUserProfileImageRequest {
	r.encoding = &encoding
	return r
}

func (r ApiUserProfileImageGetUserProfileImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.UserProfileImageGetUserProfileImageExecute(r)
}

/*
UserProfileImageGetUserProfileImage Retrieves the user profile image for the specified user.

Retrieves the user profile picture for the specified user.

The `userId` path parameter must match the authenticated user's user ID,
and the user must be a member of the specified account.

| Return value      | Meaning                                                                        |
| :---------------- | :----------------------------------------------------------------------------- |
| `200 OK`          | The response contains the profile image in the same format as it was uploaded. |
| `404 Not found`   | The user does not have a profile image.                                        |
| `400 Bad request` | There was an error in the request. The response has more information.          |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserProfileImageGetUserProfileImageRequest
*/
func (a *UsersAPIService) UserProfileImageGetUserProfileImage(ctx context.Context, accountId string, userId string) ApiUserProfileImageGetUserProfileImageRequest {
	return ApiUserProfileImageGetUserProfileImageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *UsersAPIService) UserProfileImageGetUserProfileImageExecute(r ApiUserProfileImageGetUserProfileImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UserProfileImageGetUserProfileImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/profile/image"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.encoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encoding", r.encoding, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/gif"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserProfileImagePutUserProfileImageRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	accountId string
	userId string
}

func (r ApiUserProfileImagePutUserProfileImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserProfileImagePutUserProfileImageExecute(r)
}

/*
UserProfileImagePutUserProfileImage Updates the user profile image for a specified user.

Updates the user profile image by uploading an image to the user profile.

The supported image formats are: gif, png, jpeg, and bmp. The file must be less than 200K. For best viewing results, DocuSign recommends that the image is no more than 79 pixels wide and high.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserProfileImagePutUserProfileImageRequest
*/
func (a *UsersAPIService) UserProfileImagePutUserProfileImage(ctx context.Context, accountId string, userId string) ApiUserProfileImagePutUserProfileImageRequest {
	return ApiUserProfileImagePutUserProfileImageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UserProfileImagePutUserProfileImageExecute(r ApiUserProfileImagePutUserProfileImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UserProfileImagePutUserProfileImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/profile/image"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserPutUserRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	accountId string
	userId string
	allowAllLanguages *string
	userInformation *UserInformation
}

func (r ApiUserPutUserRequest) AllowAllLanguages(allowAllLanguages string) ApiUserPutUserRequest {
	r.allowAllLanguages = &allowAllLanguages
	return r
}

func (r ApiUserPutUserRequest) UserInformation(userInformation UserInformation) ApiUserPutUserRequest {
	r.userInformation = &userInformation
	return r
}

func (r ApiUserPutUserRequest) Execute() (*UserInformation, *http.Response, error) {
	return r.ApiService.UserPutUserExecute(r)
}

/*
UserPutUser Updates user information for the specified user.

To update user information for a specific user, submit a [Users](#Users) object with updated field values in the request body of this operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserPutUserRequest
*/
func (a *UsersAPIService) UserPutUser(ctx context.Context, accountId string, userId string) ApiUserPutUserRequest {
	return ApiUserPutUserRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserInformation
func (a *UsersAPIService) UserPutUserExecute(r ApiUserPutUserRequest) (*UserInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UserPutUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowAllLanguages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_all_languages", r.allowAllLanguages, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSettingsGetUserSettingsRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	accountId string
	userId string
}

func (r ApiUserSettingsGetUserSettingsRequest) Execute() (*UserSettingsInformation, *http.Response, error) {
	return r.ApiService.UserSettingsGetUserSettingsExecute(r)
}

/*
UserSettingsGetUserSettings Gets the user account settings for a specified user.

Retrieves a list of the account settings and email
notification information for the specified user.

The response returns the account setting
name/value information and the email notification
settings for the specified user. For more
information, see
[Users:create](/docs/esign-rest-api/reference/users/users/create/).




 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserSettingsGetUserSettingsRequest
*/
func (a *UsersAPIService) UserSettingsGetUserSettings(ctx context.Context, accountId string, userId string) ApiUserSettingsGetUserSettingsRequest {
	return ApiUserSettingsGetUserSettingsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserSettingsInformation
func (a *UsersAPIService) UserSettingsGetUserSettingsExecute(r ApiUserSettingsGetUserSettingsRequest) (*UserSettingsInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserSettingsInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UserSettingsGetUserSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSettingsPutUserSettingsRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	accountId string
	userId string
	allowAllLanguages *string
	userSettingsInformation *UserSettingsInformation
}

func (r ApiUserSettingsPutUserSettingsRequest) AllowAllLanguages(allowAllLanguages string) ApiUserSettingsPutUserSettingsRequest {
	r.allowAllLanguages = &allowAllLanguages
	return r
}

func (r ApiUserSettingsPutUserSettingsRequest) UserSettingsInformation(userSettingsInformation UserSettingsInformation) ApiUserSettingsPutUserSettingsRequest {
	r.userSettingsInformation = &userSettingsInformation
	return r
}

func (r ApiUserSettingsPutUserSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserSettingsPutUserSettingsExecute(r)
}

/*
UserSettingsPutUserSettings Updates the user account settings for a specified user.

Updates the account settings list and email notification types for the specified user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserSettingsPutUserSettingsRequest
*/
func (a *UsersAPIService) UserSettingsPutUserSettings(ctx context.Context, accountId string, userId string) ApiUserSettingsPutUserSettingsRequest {
	return ApiUserSettingsPutUserSettingsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UserSettingsPutUserSettingsExecute(r ApiUserSettingsPutUserSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UserSettingsPutUserSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowAllLanguages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_all_languages", r.allowAllLanguages, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userSettingsInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersDeleteUsersRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	accountId string
	delete *string
	userInfoList *UserInfoList
}

// A list of groups to remove the user from. A comma-separated list of the following:  - &#x60;Groups&#x60; - &#x60;PermissionSet&#x60; - &#x60;SigningGroupsEmail&#x60;
func (r ApiUsersDeleteUsersRequest) Delete(delete string) ApiUsersDeleteUsersRequest {
	r.delete = &delete
	return r
}

func (r ApiUsersDeleteUsersRequest) UserInfoList(userInfoList UserInfoList) ApiUsersDeleteUsersRequest {
	r.userInfoList = &userInfoList
	return r
}

func (r ApiUsersDeleteUsersRequest) Execute() (*UsersResponse, *http.Response, error) {
	return r.ApiService.UsersDeleteUsersExecute(r)
}

/*
UsersDeleteUsers Closes one or more users in the account.

Closes one or more users in the account,
preventing them from accessing account features.
Users are not permanently deleted.

The request body requires only
the IDs of the users to close:

```json
{
    "users": [
        { "userId": "6b67a1ee-xxxx-xxxx-xxxx-385763624163" },
        { "userId": "b6c74c52-xxxx-xxxx-xxxx-457a81d88926" },
        { "userId": "464f7988-xxxx-xxxx-xxxx-781ee556ab7a" }
    ]
}
```

You can use [`Users:update`](/docs/esign-rest-api/reference/users/users/update/)
to re-open a closed user.



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiUsersDeleteUsersRequest
*/
func (a *UsersAPIService) UsersDeleteUsers(ctx context.Context, accountId string) ApiUsersDeleteUsersRequest {
	return ApiUsersDeleteUsersRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return UsersResponse
func (a *UsersAPIService) UsersDeleteUsersExecute(r ApiUsersDeleteUsersRequest) (*UsersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersDeleteUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.delete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delete", r.delete, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userInfoList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGetUsersRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	accountId string
	additionalInfo *string
	alternateAdminsOnly *string
	count *string
	domainUsersOnly *string
	email *string
	emailSubstring *string
	groupId *string
	includeUsersettingsForCsv *string
	loginStatus *string
	notGroupId *string
	startPosition *string
	status *string
	userNameSubstring *string
}

// When **true,** the custom settings information is returned for each user in the account. If this parameter is omitted, the default behavior is **false.**
func (r ApiUsersGetUsersRequest) AdditionalInfo(additionalInfo string) ApiUsersGetUsersRequest {
	r.additionalInfo = &additionalInfo
	return r
}

func (r ApiUsersGetUsersRequest) AlternateAdminsOnly(alternateAdminsOnly string) ApiUsersGetUsersRequest {
	r.alternateAdminsOnly = &alternateAdminsOnly
	return r
}

// The maximum number of results to return.  Use &#x60;start_position&#x60; to specify the number of results to skip.  Valid values: &#x60;1&#x60; to &#x60;100&#x60; 
func (r ApiUsersGetUsersRequest) Count(count string) ApiUsersGetUsersRequest {
	r.count = &count
	return r
}

func (r ApiUsersGetUsersRequest) DomainUsersOnly(domainUsersOnly string) ApiUsersGetUsersRequest {
	r.domainUsersOnly = &domainUsersOnly
	return r
}

// Filters results based on the email address associated with the user that you want to return.  **Note:** You can use either this parameter or the &#x60;email_substring&#x60; parameter, but not both. For older accounts, this parameter might return multiple users who are associated with a single email address. 
func (r ApiUsersGetUsersRequest) Email(email string) ApiUsersGetUsersRequest {
	r.email = &email
	return r
}

// Filters results based on a fragment of an email address. For example, you could enter &#x60;gmail&#x60; to return all users who have Gmail addresses.  **Note:** You do not use a wildcard character with this parameter. You can use either this parameter or the &#x60;email&#x60; parameter, but not both. 
func (r ApiUsersGetUsersRequest) EmailSubstring(emailSubstring string) ApiUsersGetUsersRequest {
	r.emailSubstring = &emailSubstring
	return r
}

// Filters results based on one or more group IDs.
func (r ApiUsersGetUsersRequest) GroupId(groupId string) ApiUsersGetUsersRequest {
	r.groupId = &groupId
	return r
}

// When **true,** the response includes the &#x60;userSettings&#x60; object data in CSV format.
func (r ApiUsersGetUsersRequest) IncludeUsersettingsForCsv(includeUsersettingsForCsv string) ApiUsersGetUsersRequest {
	r.includeUsersettingsForCsv = &includeUsersettingsForCsv
	return r
}

// When **true,** the response includes the login status of each user.
func (r ApiUsersGetUsersRequest) LoginStatus(loginStatus string) ApiUsersGetUsersRequest {
	r.loginStatus = &loginStatus
	return r
}

// Return user records excluding the specified group IDs.
func (r ApiUsersGetUsersRequest) NotGroupId(notGroupId string) ApiUsersGetUsersRequest {
	r.notGroupId = &notGroupId
	return r
}

// The zero-based index of the result from which to start returning results.  Use with &#x60;count&#x60; to limit the number of results.  The default value is &#x60;0&#x60;. 
func (r ApiUsersGetUsersRequest) StartPosition(startPosition string) ApiUsersGetUsersRequest {
	r.startPosition = &startPosition
	return r
}

// Filters results by user account status. A comma-separated list of any of the following:  * &#x60;ActivationRequired&#x60; * &#x60;ActivationSent&#x60; * &#x60;Active&#x60; * &#x60;Closed&#x60; * &#x60;Disabled&#x60; 
func (r ApiUsersGetUsersRequest) Status(status string) ApiUsersGetUsersRequest {
	r.status = &status
	return r
}

// Filters the user records returned by the user name or a sub-string of user name.
func (r ApiUsersGetUsersRequest) UserNameSubstring(userNameSubstring string) ApiUsersGetUsersRequest {
	r.userNameSubstring = &userNameSubstring
	return r
}

func (r ApiUsersGetUsersRequest) Execute() (*UserInformationList, *http.Response, error) {
	return r.ApiService.UsersGetUsersExecute(r)
}

/*
UsersGetUsers Retrieves the list of users for the specified account.

Retrieves the list of users for the specified account.

The response returns the list of users for the account, with information about the result set. If the `additional_info` query is added to the endpoint and set to **true,** full user information is returned for each user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId (Required) The external account number (int) or account ID GUID.
 @return ApiUsersGetUsersRequest
*/
func (a *UsersAPIService) UsersGetUsers(ctx context.Context, accountId string) ApiUsersGetUsersRequest {
	return ApiUsersGetUsersRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return UserInformationList
func (a *UsersAPIService) UsersGetUsersExecute(r ApiUsersGetUsersRequest) (*UserInformationList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserInformationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.additionalInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additional_info", r.additionalInfo, "")
	}
	if r.alternateAdminsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alternate_admins_only", r.alternateAdminsOnly, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.domainUsersOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain_users_only", r.domainUsersOnly, "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.emailSubstring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email_substring", r.emailSubstring, "")
	}
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", r.groupId, "")
	}
	if r.includeUsersettingsForCsv != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_usersettings_for_csv", r.includeUsersettingsForCsv, "")
	}
	if r.loginStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "login_status", r.loginStatus, "")
	}
	if r.notGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_group_id", r.notGroupId, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.userNameSubstring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_name_substring", r.userNameSubstring, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPostUsersRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	accountId string
	newUsersDefinition *NewUsersDefinition
}

func (r ApiUsersPostUsersRequest) NewUsersDefinition(newUsersDefinition NewUsersDefinition) ApiUsersPostUsersRequest {
	r.newUsersDefinition = &newUsersDefinition
	return r
}

func (r ApiUsersPostUsersRequest) Execute() (*NewUsersSummary, *http.Response, error) {
	return r.ApiService.UsersPostUsersExecute(r)
}

/*
UsersPostUsers Adds new users to the specified account.

Adds new users to an account. 

The body of this request is an array of `newUsers` objects. For each new user, you must provide at least the `userName` and `email` properties. The maximum number of users you can create in one request is 500 users. 

The `userSettings` property specifies the actions users can perform. In the example below, Tal Mason will be able to send envelopes, and the activation email will be in French because the `locale` is set to `fr`.


```
POST /restapi/v2.1/accounts/{accountId}/users
Content-Type: application/json
```
```
{
  "newUsers": [
    {
      "userName": "Claire Horace",
      "email": "claire@example.com"
    },
    {
      "userName": "Tal Mason",
      "email": "talmason@example.com",
      "company": "TeleSel",
      "userSettings": {
        "locale": "fr",
        "canSendEnvelope": true
      }
    }
  ]
}
```

A successful response is a `newUsers` array with information about the newly created users. If there was a problem in creating a user, that user entry will contain an `errorDetails` property that describes what went wrong.

```json
{
  "newUsers": [
    {
      "userId": "18f3be12-xxxx-xxxx-xxxx-883d8f9b8ade",
      "uri": "/users/18f3be12-xxxx-xxxx-xxxx-883d8f9b8ade",
      "email": "claire@example.com",
      "userName": "Claire Horace",
      "createdDateTime": "0001-01-01T08:00:00.0000000Z",
      "errorDetails": {
        "errorCode": "USER_ALREADY_EXISTS_IN_ACCOUNT",
        "message": "Username and email combination already exists for this account."
      }
    },
    {
      "userId": "be9899a3-xxxx-xxxx-xxxx-2c8dd7156e33",
      "uri": "/users/be9899a3-xxxx-xxxx-xxxx-2c8dd7156e33",
      "email": "talmason@example.com",
      "userName": "Tal Mason",
      "userStatus": "ActivationSent",
      "createdDateTime": "2020-05-26T23:25:30.7330000Z"
    }
  ]
}
```


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiUsersPostUsersRequest
*/
func (a *UsersAPIService) UsersPostUsers(ctx context.Context, accountId string) ApiUsersPostUsersRequest {
	return ApiUsersPostUsersRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return NewUsersSummary
func (a *UsersAPIService) UsersPostUsersExecute(r ApiUsersPostUsersRequest) (*NewUsersSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NewUsersSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPostUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.newUsersDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPutUsersRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	accountId string
	allowAllLanguages *string
	userInformationList *UserInformationList
}

func (r ApiUsersPutUsersRequest) AllowAllLanguages(allowAllLanguages string) ApiUsersPutUsersRequest {
	r.allowAllLanguages = &allowAllLanguages
	return r
}

func (r ApiUsersPutUsersRequest) UserInformationList(userInformationList UserInformationList) ApiUsersPutUsersRequest {
	r.userInformationList = &userInformationList
	return r
}

func (r ApiUsersPutUsersRequest) Execute() (*UserInformationList, *http.Response, error) {
	return r.ApiService.UsersPutUsersExecute(r)
}

/*
UsersPutUsers Changes one or more users in the specified account.

This method updates the information about one or more account users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiUsersPutUsersRequest
*/
func (a *UsersAPIService) UsersPutUsers(ctx context.Context, accountId string) ApiUsersPutUsersRequest {
	return ApiUsersPutUsersRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return UserInformationList
func (a *UsersAPIService) UsersPutUsersExecute(r ApiUsersPutUsersRequest) (*UserInformationList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserInformationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPutUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowAllLanguages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_all_languages", r.allowAllLanguages, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userInformationList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
