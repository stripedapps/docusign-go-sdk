/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// EnvelopeWorkflowDefinitionAPIService EnvelopeWorkflowDefinitionAPI service
type EnvelopeWorkflowDefinitionAPIService service

type ApiEnvelopeWorkflowDefinitionV2DeleteEnvelopeWorkflowDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	envelopeId string
}

func (r ApiEnvelopeWorkflowDefinitionV2DeleteEnvelopeWorkflowDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvelopeWorkflowDefinitionV2DeleteEnvelopeWorkflowDefinitionExecute(r)
}

/*
EnvelopeWorkflowDefinitionV2DeleteEnvelopeWorkflowDefinition Delete the workflow definition for an envelope.

Deletes the specified envelope's workflow definition if it has one.

**Note:** If the envelope was scheduled to be sent, this endpoint will cancel the scheduled send and the envelope status will be reset to 
`created`. To resend the envelope, call the update the status to `sent` with the [Envelopes::Update](/docs/esign-rest-api/reference/envelopes/envelopes/update/) method.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiEnvelopeWorkflowDefinitionV2DeleteEnvelopeWorkflowDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowDefinitionV2DeleteEnvelopeWorkflowDefinition(ctx context.Context, accountId string, envelopeId string) ApiEnvelopeWorkflowDefinitionV2DeleteEnvelopeWorkflowDefinitionRequest {
	return ApiEnvelopeWorkflowDefinitionV2DeleteEnvelopeWorkflowDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowDefinitionV2DeleteEnvelopeWorkflowDefinitionExecute(r ApiEnvelopeWorkflowDefinitionV2DeleteEnvelopeWorkflowDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.EnvelopeWorkflowDefinitionV2DeleteEnvelopeWorkflowDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvelopeWorkflowDefinitionV2GetEnvelopeWorkflowDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	envelopeId string
}

func (r ApiEnvelopeWorkflowDefinitionV2GetEnvelopeWorkflowDefinitionRequest) Execute() (*Workflow, *http.Response, error) {
	return r.ApiService.EnvelopeWorkflowDefinitionV2GetEnvelopeWorkflowDefinitionExecute(r)
}

/*
EnvelopeWorkflowDefinitionV2GetEnvelopeWorkflowDefinition Returns the workflow definition for an envelope.

Returns the workflow definition for the envelope specified by `envelopeId`. If the envelope does not have a workflow object, this method returns a 404.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiEnvelopeWorkflowDefinitionV2GetEnvelopeWorkflowDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowDefinitionV2GetEnvelopeWorkflowDefinition(ctx context.Context, accountId string, envelopeId string) ApiEnvelopeWorkflowDefinitionV2GetEnvelopeWorkflowDefinitionRequest {
	return ApiEnvelopeWorkflowDefinitionV2GetEnvelopeWorkflowDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return Workflow
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowDefinitionV2GetEnvelopeWorkflowDefinitionExecute(r ApiEnvelopeWorkflowDefinitionV2GetEnvelopeWorkflowDefinitionRequest) (*Workflow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Workflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.EnvelopeWorkflowDefinitionV2GetEnvelopeWorkflowDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopeWorkflowDefinitionV2PutEnvelopeWorkflowDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	envelopeId string
	workflow *Workflow
}

func (r ApiEnvelopeWorkflowDefinitionV2PutEnvelopeWorkflowDefinitionRequest) Workflow(workflow Workflow) ApiEnvelopeWorkflowDefinitionV2PutEnvelopeWorkflowDefinitionRequest {
	r.workflow = &workflow
	return r
}

func (r ApiEnvelopeWorkflowDefinitionV2PutEnvelopeWorkflowDefinitionRequest) Execute() (*Workflow, *http.Response, error) {
	return r.ApiService.EnvelopeWorkflowDefinitionV2PutEnvelopeWorkflowDefinitionExecute(r)
}

/*
EnvelopeWorkflowDefinitionV2PutEnvelopeWorkflowDefinition Updates the workflow definition for an envelope.

Updates the specified envelope's workflow.

You can use this endpoint to add scheduled sending to a draft envelope. You can also update the scheduled sending for a sent envelope if the scheduled sending countdown is in progress. In that case, the envelope will be reset to a draft state.

You can also add delayed routing to a draft envelope or a sent envelope that has not started workflow processing.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiEnvelopeWorkflowDefinitionV2PutEnvelopeWorkflowDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowDefinitionV2PutEnvelopeWorkflowDefinition(ctx context.Context, accountId string, envelopeId string) ApiEnvelopeWorkflowDefinitionV2PutEnvelopeWorkflowDefinitionRequest {
	return ApiEnvelopeWorkflowDefinitionV2PutEnvelopeWorkflowDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return Workflow
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowDefinitionV2PutEnvelopeWorkflowDefinitionExecute(r ApiEnvelopeWorkflowDefinitionV2PutEnvelopeWorkflowDefinitionRequest) (*Workflow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Workflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.EnvelopeWorkflowDefinitionV2PutEnvelopeWorkflowDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflow
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopeWorkflowDelayedRoutingDeleteEnvelopeDelayedRoutingDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	envelopeId string
	workflowStepId string
}

func (r ApiEnvelopeWorkflowDelayedRoutingDeleteEnvelopeDelayedRoutingDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvelopeWorkflowDelayedRoutingDeleteEnvelopeDelayedRoutingDefinitionExecute(r)
}

/*
EnvelopeWorkflowDelayedRoutingDeleteEnvelopeDelayedRoutingDefinition Deletes the delayed routing rules for the specified envelope workflow step.

Delete the delayed routing object for an envelope's workflow step. You cannot call this endpoint once the delay is in progress. As a workaround, you can update the delay or send time to one minute in the future using the [updateEnvelopeDelayedRoutingDefinition](/docs/esign-rest-api/reference/envelopes/envelopeworkflowdefinition/updateEnvelopeDelayedRoutingDefinition/) endpoint. 

**Note:** After deleting the delayed routing object, the workflow step still contains the `pause_before` action. Once the workflow step is reached, you will need to [unpause the envelope](/docs/esign-rest-api/how-to/unpause-workflow/). If you want to delete the step entirely, use [deleteEnvelopeWorkflowStepDefinition](/docs/esign-rest-api/reference/envelopes/envelopeworkflowdefinition/deleteenvelopeworkflowstepdefinition/) instead.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param workflowStepId The ID of the workflow step.
 @return ApiEnvelopeWorkflowDelayedRoutingDeleteEnvelopeDelayedRoutingDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowDelayedRoutingDeleteEnvelopeDelayedRoutingDefinition(ctx context.Context, accountId string, envelopeId string, workflowStepId string) ApiEnvelopeWorkflowDelayedRoutingDeleteEnvelopeDelayedRoutingDefinitionRequest {
	return ApiEnvelopeWorkflowDelayedRoutingDeleteEnvelopeDelayedRoutingDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
		workflowStepId: workflowStepId,
	}
}

// Execute executes the request
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowDelayedRoutingDeleteEnvelopeDelayedRoutingDefinitionExecute(r ApiEnvelopeWorkflowDelayedRoutingDeleteEnvelopeDelayedRoutingDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.EnvelopeWorkflowDelayedRoutingDeleteEnvelopeDelayedRoutingDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/workflow/steps/{workflowStepId}/delayedRouting"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflowStepId"+"}", url.PathEscape(parameterValueToString(r.workflowStepId, "workflowStepId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvelopeWorkflowDelayedRoutingGetEnvelopeDelayedRoutingDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	envelopeId string
	workflowStepId string
}

func (r ApiEnvelopeWorkflowDelayedRoutingGetEnvelopeDelayedRoutingDefinitionRequest) Execute() (*DelayedRouting, *http.Response, error) {
	return r.ApiService.EnvelopeWorkflowDelayedRoutingGetEnvelopeDelayedRoutingDefinitionExecute(r)
}

/*
EnvelopeWorkflowDelayedRoutingGetEnvelopeDelayedRoutingDefinition Returns the delayed routing rules for an envelope's workflow step definition.

Given an envelope and a workflow step, returns the delayed routing rules for that workflow step.

**Note:** If the workflow step does not have a delayed routing object, this method returns a 404.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param workflowStepId The ID of the workflow step.
 @return ApiEnvelopeWorkflowDelayedRoutingGetEnvelopeDelayedRoutingDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowDelayedRoutingGetEnvelopeDelayedRoutingDefinition(ctx context.Context, accountId string, envelopeId string, workflowStepId string) ApiEnvelopeWorkflowDelayedRoutingGetEnvelopeDelayedRoutingDefinitionRequest {
	return ApiEnvelopeWorkflowDelayedRoutingGetEnvelopeDelayedRoutingDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
		workflowStepId: workflowStepId,
	}
}

// Execute executes the request
//  @return DelayedRouting
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowDelayedRoutingGetEnvelopeDelayedRoutingDefinitionExecute(r ApiEnvelopeWorkflowDelayedRoutingGetEnvelopeDelayedRoutingDefinitionRequest) (*DelayedRouting, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DelayedRouting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.EnvelopeWorkflowDelayedRoutingGetEnvelopeDelayedRoutingDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/workflow/steps/{workflowStepId}/delayedRouting"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflowStepId"+"}", url.PathEscape(parameterValueToString(r.workflowStepId, "workflowStepId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopeWorkflowDelayedRoutingPutEnvelopeDelayedRoutingDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	envelopeId string
	workflowStepId string
	delayedRouting *DelayedRouting
}

// A complex element that specifies the delayed routing settings for the workflow step.
func (r ApiEnvelopeWorkflowDelayedRoutingPutEnvelopeDelayedRoutingDefinitionRequest) DelayedRouting(delayedRouting DelayedRouting) ApiEnvelopeWorkflowDelayedRoutingPutEnvelopeDelayedRoutingDefinitionRequest {
	r.delayedRouting = &delayedRouting
	return r
}

func (r ApiEnvelopeWorkflowDelayedRoutingPutEnvelopeDelayedRoutingDefinitionRequest) Execute() (*DelayedRouting, *http.Response, error) {
	return r.ApiService.EnvelopeWorkflowDelayedRoutingPutEnvelopeDelayedRoutingDefinitionExecute(r)
}

/*
EnvelopeWorkflowDelayedRoutingPutEnvelopeDelayedRoutingDefinition Updates the delayed routing rules for an envelope's workflow step definition.

Updates the delayed routing rules for an envelope's workflow step definition.

You can use this endpoint to add delayed routing to a draft envelope or a sent envelope (as long as the previous workflow step has not yet been completed). You can also update the delayed routing rule for an envelope, as long as the delay is not yet complete. If you update the delayed routing rule while the delay is already in progress, the countdown will reset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param workflowStepId The ID of the workflow step.
 @return ApiEnvelopeWorkflowDelayedRoutingPutEnvelopeDelayedRoutingDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowDelayedRoutingPutEnvelopeDelayedRoutingDefinition(ctx context.Context, accountId string, envelopeId string, workflowStepId string) ApiEnvelopeWorkflowDelayedRoutingPutEnvelopeDelayedRoutingDefinitionRequest {
	return ApiEnvelopeWorkflowDelayedRoutingPutEnvelopeDelayedRoutingDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
		workflowStepId: workflowStepId,
	}
}

// Execute executes the request
//  @return DelayedRouting
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowDelayedRoutingPutEnvelopeDelayedRoutingDefinitionExecute(r ApiEnvelopeWorkflowDelayedRoutingPutEnvelopeDelayedRoutingDefinitionRequest) (*DelayedRouting, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DelayedRouting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.EnvelopeWorkflowDelayedRoutingPutEnvelopeDelayedRoutingDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/workflow/steps/{workflowStepId}/delayedRouting"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflowStepId"+"}", url.PathEscape(parameterValueToString(r.workflowStepId, "workflowStepId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.delayedRouting
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopeWorkflowScheduledSendingDeleteEnvelopeScheduledSendingDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	envelopeId string
}

func (r ApiEnvelopeWorkflowScheduledSendingDeleteEnvelopeScheduledSendingDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvelopeWorkflowScheduledSendingDeleteEnvelopeScheduledSendingDefinitionExecute(r)
}

/*
EnvelopeWorkflowScheduledSendingDeleteEnvelopeScheduledSendingDefinition Deletes the scheduled sending rules for the envelope's workflow.

Deletes the scheduled sending rules for an envelope's workflow. You cannot call this endpoint once the scheduled sending countdown has begun.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiEnvelopeWorkflowScheduledSendingDeleteEnvelopeScheduledSendingDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowScheduledSendingDeleteEnvelopeScheduledSendingDefinition(ctx context.Context, accountId string, envelopeId string) ApiEnvelopeWorkflowScheduledSendingDeleteEnvelopeScheduledSendingDefinitionRequest {
	return ApiEnvelopeWorkflowScheduledSendingDeleteEnvelopeScheduledSendingDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowScheduledSendingDeleteEnvelopeScheduledSendingDefinitionExecute(r ApiEnvelopeWorkflowScheduledSendingDeleteEnvelopeScheduledSendingDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.EnvelopeWorkflowScheduledSendingDeleteEnvelopeScheduledSendingDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/workflow/scheduledSending"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvelopeWorkflowScheduledSendingGetEnvelopeScheduledSendingDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	envelopeId string
}

func (r ApiEnvelopeWorkflowScheduledSendingGetEnvelopeScheduledSendingDefinitionRequest) Execute() (*ScheduledSending, *http.Response, error) {
	return r.ApiService.EnvelopeWorkflowScheduledSendingGetEnvelopeScheduledSendingDefinitionExecute(r)
}

/*
EnvelopeWorkflowScheduledSendingGetEnvelopeScheduledSendingDefinition Returns the scheduled sending rules for an envelope's workflow definition.

Given a template and a workflow step, returns the scheduled sending rules for that workflow step.

**Note:** If the workflow step does not have a scheduled sending object, this method returns a 404.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiEnvelopeWorkflowScheduledSendingGetEnvelopeScheduledSendingDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowScheduledSendingGetEnvelopeScheduledSendingDefinition(ctx context.Context, accountId string, envelopeId string) ApiEnvelopeWorkflowScheduledSendingGetEnvelopeScheduledSendingDefinitionRequest {
	return ApiEnvelopeWorkflowScheduledSendingGetEnvelopeScheduledSendingDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return ScheduledSending
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowScheduledSendingGetEnvelopeScheduledSendingDefinitionExecute(r ApiEnvelopeWorkflowScheduledSendingGetEnvelopeScheduledSendingDefinitionRequest) (*ScheduledSending, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScheduledSending
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.EnvelopeWorkflowScheduledSendingGetEnvelopeScheduledSendingDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/workflow/scheduledSending"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopeWorkflowScheduledSendingPutEnvelopeScheduledSendingDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	envelopeId string
	scheduledSending *ScheduledSending
}

// An object that describes the settings for scheduled sending.
func (r ApiEnvelopeWorkflowScheduledSendingPutEnvelopeScheduledSendingDefinitionRequest) ScheduledSending(scheduledSending ScheduledSending) ApiEnvelopeWorkflowScheduledSendingPutEnvelopeScheduledSendingDefinitionRequest {
	r.scheduledSending = &scheduledSending
	return r
}

func (r ApiEnvelopeWorkflowScheduledSendingPutEnvelopeScheduledSendingDefinitionRequest) Execute() (*ScheduledSending, *http.Response, error) {
	return r.ApiService.EnvelopeWorkflowScheduledSendingPutEnvelopeScheduledSendingDefinitionExecute(r)
}

/*
EnvelopeWorkflowScheduledSendingPutEnvelopeScheduledSendingDefinition Updates the scheduled sending rules for an envelope's workflow.

Updates the scheduled sending rules for an envelope's workflow. The envelope must have an existing workflow object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiEnvelopeWorkflowScheduledSendingPutEnvelopeScheduledSendingDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowScheduledSendingPutEnvelopeScheduledSendingDefinition(ctx context.Context, accountId string, envelopeId string) ApiEnvelopeWorkflowScheduledSendingPutEnvelopeScheduledSendingDefinitionRequest {
	return ApiEnvelopeWorkflowScheduledSendingPutEnvelopeScheduledSendingDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return ScheduledSending
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowScheduledSendingPutEnvelopeScheduledSendingDefinitionExecute(r ApiEnvelopeWorkflowScheduledSendingPutEnvelopeScheduledSendingDefinitionRequest) (*ScheduledSending, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScheduledSending
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.EnvelopeWorkflowScheduledSendingPutEnvelopeScheduledSendingDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/workflow/scheduledSending"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.scheduledSending
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopeWorkflowStepDeleteEnvelopeWorkflowStepDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	envelopeId string
	workflowStepId string
}

func (r ApiEnvelopeWorkflowStepDeleteEnvelopeWorkflowStepDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvelopeWorkflowStepDeleteEnvelopeWorkflowStepDefinitionExecute(r)
}

/*
EnvelopeWorkflowStepDeleteEnvelopeWorkflowStepDefinition Deletes a workflow step from an envelope's workflow definition.

Deletes the workflow step specified by `workflowStepId` from an envelope specified by `envelopeId`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param workflowStepId The ID of the workflow step.
 @return ApiEnvelopeWorkflowStepDeleteEnvelopeWorkflowStepDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowStepDeleteEnvelopeWorkflowStepDefinition(ctx context.Context, accountId string, envelopeId string, workflowStepId string) ApiEnvelopeWorkflowStepDeleteEnvelopeWorkflowStepDefinitionRequest {
	return ApiEnvelopeWorkflowStepDeleteEnvelopeWorkflowStepDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
		workflowStepId: workflowStepId,
	}
}

// Execute executes the request
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowStepDeleteEnvelopeWorkflowStepDefinitionExecute(r ApiEnvelopeWorkflowStepDeleteEnvelopeWorkflowStepDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.EnvelopeWorkflowStepDeleteEnvelopeWorkflowStepDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/workflow/steps/{workflowStepId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflowStepId"+"}", url.PathEscape(parameterValueToString(r.workflowStepId, "workflowStepId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvelopeWorkflowStepGetEnvelopeWorkflowStepDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	envelopeId string
	workflowStepId string
}

func (r ApiEnvelopeWorkflowStepGetEnvelopeWorkflowStepDefinitionRequest) Execute() (*WorkflowStep, *http.Response, error) {
	return r.ApiService.EnvelopeWorkflowStepGetEnvelopeWorkflowStepDefinitionExecute(r)
}

/*
EnvelopeWorkflowStepGetEnvelopeWorkflowStepDefinition Returns a specified workflow step for a specified template.

Returns a workflow step specified by `workflowStepId` for an envelope specified by `envelopeId`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param workflowStepId The ID of the workflow step.
 @return ApiEnvelopeWorkflowStepGetEnvelopeWorkflowStepDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowStepGetEnvelopeWorkflowStepDefinition(ctx context.Context, accountId string, envelopeId string, workflowStepId string) ApiEnvelopeWorkflowStepGetEnvelopeWorkflowStepDefinitionRequest {
	return ApiEnvelopeWorkflowStepGetEnvelopeWorkflowStepDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
		workflowStepId: workflowStepId,
	}
}

// Execute executes the request
//  @return WorkflowStep
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowStepGetEnvelopeWorkflowStepDefinitionExecute(r ApiEnvelopeWorkflowStepGetEnvelopeWorkflowStepDefinitionRequest) (*WorkflowStep, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.EnvelopeWorkflowStepGetEnvelopeWorkflowStepDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/workflow/steps/{workflowStepId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflowStepId"+"}", url.PathEscape(parameterValueToString(r.workflowStepId, "workflowStepId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopeWorkflowStepPostEnvelopeWorkflowStepDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	envelopeId string
	workflowStep *WorkflowStep
}

func (r ApiEnvelopeWorkflowStepPostEnvelopeWorkflowStepDefinitionRequest) WorkflowStep(workflowStep WorkflowStep) ApiEnvelopeWorkflowStepPostEnvelopeWorkflowStepDefinitionRequest {
	r.workflowStep = &workflowStep
	return r
}

func (r ApiEnvelopeWorkflowStepPostEnvelopeWorkflowStepDefinitionRequest) Execute() (*WorkflowStep, *http.Response, error) {
	return r.ApiService.EnvelopeWorkflowStepPostEnvelopeWorkflowStepDefinitionExecute(r)
}

/*
EnvelopeWorkflowStepPostEnvelopeWorkflowStepDefinition Adds a new step to an envelope's workflow.

Adds a new step to an envelope's workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiEnvelopeWorkflowStepPostEnvelopeWorkflowStepDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowStepPostEnvelopeWorkflowStepDefinition(ctx context.Context, accountId string, envelopeId string) ApiEnvelopeWorkflowStepPostEnvelopeWorkflowStepDefinitionRequest {
	return ApiEnvelopeWorkflowStepPostEnvelopeWorkflowStepDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return WorkflowStep
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowStepPostEnvelopeWorkflowStepDefinitionExecute(r ApiEnvelopeWorkflowStepPostEnvelopeWorkflowStepDefinitionRequest) (*WorkflowStep, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.EnvelopeWorkflowStepPostEnvelopeWorkflowStepDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/workflow/steps"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflowStep
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopeWorkflowStepPutEnvelopeWorkflowStepDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	envelopeId string
	workflowStepId string
	workflowStep *WorkflowStep
}

func (r ApiEnvelopeWorkflowStepPutEnvelopeWorkflowStepDefinitionRequest) WorkflowStep(workflowStep WorkflowStep) ApiEnvelopeWorkflowStepPutEnvelopeWorkflowStepDefinitionRequest {
	r.workflowStep = &workflowStep
	return r
}

func (r ApiEnvelopeWorkflowStepPutEnvelopeWorkflowStepDefinitionRequest) Execute() (*WorkflowStep, *http.Response, error) {
	return r.ApiService.EnvelopeWorkflowStepPutEnvelopeWorkflowStepDefinitionExecute(r)
}

/*
EnvelopeWorkflowStepPutEnvelopeWorkflowStepDefinition Updates the specified workflow step for an envelope.

Updates the workflow step specified by `workflowStepId` for an envelope.

You can use this endpoint to add or update delayed routing for a draft envelope. You can add or update delayed routing for a sent envelope as long as the previous workflow step has not been completed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param workflowStepId The ID of the workflow step.
 @return ApiEnvelopeWorkflowStepPutEnvelopeWorkflowStepDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowStepPutEnvelopeWorkflowStepDefinition(ctx context.Context, accountId string, envelopeId string, workflowStepId string) ApiEnvelopeWorkflowStepPutEnvelopeWorkflowStepDefinitionRequest {
	return ApiEnvelopeWorkflowStepPutEnvelopeWorkflowStepDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
		workflowStepId: workflowStepId,
	}
}

// Execute executes the request
//  @return WorkflowStep
func (a *EnvelopeWorkflowDefinitionAPIService) EnvelopeWorkflowStepPutEnvelopeWorkflowStepDefinitionExecute(r ApiEnvelopeWorkflowStepPutEnvelopeWorkflowStepDefinitionRequest) (*WorkflowStep, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.EnvelopeWorkflowStepPutEnvelopeWorkflowStepDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/workflow/steps/{workflowStepId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflowStepId"+"}", url.PathEscape(parameterValueToString(r.workflowStepId, "workflowStepId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflowStep
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTemplateWorkflowDefinitionDeleteTemplateWorkflowDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	templateId string
}

func (r ApiTemplateWorkflowDefinitionDeleteTemplateWorkflowDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.TemplateWorkflowDefinitionDeleteTemplateWorkflowDefinitionExecute(r)
}

/*
TemplateWorkflowDefinitionDeleteTemplateWorkflowDefinition Delete the workflow definition for a template.

Deletes the specified template's workflow definition if it has one.

**Note:** If the specified template does not have a workflow definition, this endpoint returns a 200 response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @return ApiTemplateWorkflowDefinitionDeleteTemplateWorkflowDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowDefinitionDeleteTemplateWorkflowDefinition(ctx context.Context, accountId string, templateId string) ApiTemplateWorkflowDefinitionDeleteTemplateWorkflowDefinitionRequest {
	return ApiTemplateWorkflowDefinitionDeleteTemplateWorkflowDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowDefinitionDeleteTemplateWorkflowDefinitionExecute(r ApiTemplateWorkflowDefinitionDeleteTemplateWorkflowDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.TemplateWorkflowDefinitionDeleteTemplateWorkflowDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTemplateWorkflowDefinitionGetTemplateWorkflowDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	templateId string
}

func (r ApiTemplateWorkflowDefinitionGetTemplateWorkflowDefinitionRequest) Execute() (*Workflow, *http.Response, error) {
	return r.ApiService.TemplateWorkflowDefinitionGetTemplateWorkflowDefinitionExecute(r)
}

/*
TemplateWorkflowDefinitionGetTemplateWorkflowDefinition Returns the workflow definition for a template.

Returns the workflow definition for the template specified by `templateId`. If the template does not have a workflow object, this method returns a 404.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @return ApiTemplateWorkflowDefinitionGetTemplateWorkflowDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowDefinitionGetTemplateWorkflowDefinition(ctx context.Context, accountId string, templateId string) ApiTemplateWorkflowDefinitionGetTemplateWorkflowDefinitionRequest {
	return ApiTemplateWorkflowDefinitionGetTemplateWorkflowDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return Workflow
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowDefinitionGetTemplateWorkflowDefinitionExecute(r ApiTemplateWorkflowDefinitionGetTemplateWorkflowDefinitionRequest) (*Workflow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Workflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.TemplateWorkflowDefinitionGetTemplateWorkflowDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTemplateWorkflowDefinitionPutTemplateWorkflowDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	templateId string
	workflow *Workflow
}

func (r ApiTemplateWorkflowDefinitionPutTemplateWorkflowDefinitionRequest) Workflow(workflow Workflow) ApiTemplateWorkflowDefinitionPutTemplateWorkflowDefinitionRequest {
	r.workflow = &workflow
	return r
}

func (r ApiTemplateWorkflowDefinitionPutTemplateWorkflowDefinitionRequest) Execute() (*Workflow, *http.Response, error) {
	return r.ApiService.TemplateWorkflowDefinitionPutTemplateWorkflowDefinitionExecute(r)
}

/*
TemplateWorkflowDefinitionPutTemplateWorkflowDefinition Updates the workflow definition for a template.

Updates the specified template's workflow definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @return ApiTemplateWorkflowDefinitionPutTemplateWorkflowDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowDefinitionPutTemplateWorkflowDefinition(ctx context.Context, accountId string, templateId string) ApiTemplateWorkflowDefinitionPutTemplateWorkflowDefinitionRequest {
	return ApiTemplateWorkflowDefinitionPutTemplateWorkflowDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return Workflow
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowDefinitionPutTemplateWorkflowDefinitionExecute(r ApiTemplateWorkflowDefinitionPutTemplateWorkflowDefinitionRequest) (*Workflow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Workflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.TemplateWorkflowDefinitionPutTemplateWorkflowDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflow
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTemplateWorkflowDelayedRoutingDeleteTemplateDelayedRoutingDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	templateId string
	workflowStepId string
}

func (r ApiTemplateWorkflowDelayedRoutingDeleteTemplateDelayedRoutingDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.TemplateWorkflowDelayedRoutingDeleteTemplateDelayedRoutingDefinitionExecute(r)
}

/*
TemplateWorkflowDelayedRoutingDeleteTemplateDelayedRoutingDefinition Deletes the delayed routing rules for the specified template workflow step.

Deletes the delayed routing rules for the specified template workflow step.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @param workflowStepId The ID of the workflow step.
 @return ApiTemplateWorkflowDelayedRoutingDeleteTemplateDelayedRoutingDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowDelayedRoutingDeleteTemplateDelayedRoutingDefinition(ctx context.Context, accountId string, templateId string, workflowStepId string) ApiTemplateWorkflowDelayedRoutingDeleteTemplateDelayedRoutingDefinitionRequest {
	return ApiTemplateWorkflowDelayedRoutingDeleteTemplateDelayedRoutingDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
		workflowStepId: workflowStepId,
	}
}

// Execute executes the request
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowDelayedRoutingDeleteTemplateDelayedRoutingDefinitionExecute(r ApiTemplateWorkflowDelayedRoutingDeleteTemplateDelayedRoutingDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.TemplateWorkflowDelayedRoutingDeleteTemplateDelayedRoutingDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/workflow/steps/{workflowStepId}/delayedRouting"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflowStepId"+"}", url.PathEscape(parameterValueToString(r.workflowStepId, "workflowStepId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTemplateWorkflowDelayedRoutingGetTemplateDelayedRoutingDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	templateId string
	workflowStepId string
}

func (r ApiTemplateWorkflowDelayedRoutingGetTemplateDelayedRoutingDefinitionRequest) Execute() (*DelayedRouting, *http.Response, error) {
	return r.ApiService.TemplateWorkflowDelayedRoutingGetTemplateDelayedRoutingDefinitionExecute(r)
}

/*
TemplateWorkflowDelayedRoutingGetTemplateDelayedRoutingDefinition Returns the delayed routing rules for a template's workflow step definition.

Given a template and a workflow step, returns the delayed routing rules for that workflow step.

**Note:** If the workflow step does not have a delayed routing object, this method returns a 404.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @param workflowStepId The ID of the workflow step.
 @return ApiTemplateWorkflowDelayedRoutingGetTemplateDelayedRoutingDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowDelayedRoutingGetTemplateDelayedRoutingDefinition(ctx context.Context, accountId string, templateId string, workflowStepId string) ApiTemplateWorkflowDelayedRoutingGetTemplateDelayedRoutingDefinitionRequest {
	return ApiTemplateWorkflowDelayedRoutingGetTemplateDelayedRoutingDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
		workflowStepId: workflowStepId,
	}
}

// Execute executes the request
//  @return DelayedRouting
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowDelayedRoutingGetTemplateDelayedRoutingDefinitionExecute(r ApiTemplateWorkflowDelayedRoutingGetTemplateDelayedRoutingDefinitionRequest) (*DelayedRouting, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DelayedRouting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.TemplateWorkflowDelayedRoutingGetTemplateDelayedRoutingDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/workflow/steps/{workflowStepId}/delayedRouting"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflowStepId"+"}", url.PathEscape(parameterValueToString(r.workflowStepId, "workflowStepId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTemplateWorkflowDelayedRoutingPutTemplateDelayedRoutingDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	templateId string
	workflowStepId string
	delayedRouting *DelayedRouting
}

// A complex element that specifies the delayed routing settings for the workflow step.
func (r ApiTemplateWorkflowDelayedRoutingPutTemplateDelayedRoutingDefinitionRequest) DelayedRouting(delayedRouting DelayedRouting) ApiTemplateWorkflowDelayedRoutingPutTemplateDelayedRoutingDefinitionRequest {
	r.delayedRouting = &delayedRouting
	return r
}

func (r ApiTemplateWorkflowDelayedRoutingPutTemplateDelayedRoutingDefinitionRequest) Execute() (*DelayedRouting, *http.Response, error) {
	return r.ApiService.TemplateWorkflowDelayedRoutingPutTemplateDelayedRoutingDefinitionExecute(r)
}

/*
TemplateWorkflowDelayedRoutingPutTemplateDelayedRoutingDefinition Updates the delayed routing rules for a template's workflow step.

Updates the scheduled sending rules for a template's workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @param workflowStepId The ID of the workflow step.
 @return ApiTemplateWorkflowDelayedRoutingPutTemplateDelayedRoutingDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowDelayedRoutingPutTemplateDelayedRoutingDefinition(ctx context.Context, accountId string, templateId string, workflowStepId string) ApiTemplateWorkflowDelayedRoutingPutTemplateDelayedRoutingDefinitionRequest {
	return ApiTemplateWorkflowDelayedRoutingPutTemplateDelayedRoutingDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
		workflowStepId: workflowStepId,
	}
}

// Execute executes the request
//  @return DelayedRouting
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowDelayedRoutingPutTemplateDelayedRoutingDefinitionExecute(r ApiTemplateWorkflowDelayedRoutingPutTemplateDelayedRoutingDefinitionRequest) (*DelayedRouting, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DelayedRouting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.TemplateWorkflowDelayedRoutingPutTemplateDelayedRoutingDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/workflow/steps/{workflowStepId}/delayedRouting"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflowStepId"+"}", url.PathEscape(parameterValueToString(r.workflowStepId, "workflowStepId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.delayedRouting
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTemplateWorkflowScheduledSendingDeleteTemplateScheduledSendingDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	templateId string
}

func (r ApiTemplateWorkflowScheduledSendingDeleteTemplateScheduledSendingDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.TemplateWorkflowScheduledSendingDeleteTemplateScheduledSendingDefinitionExecute(r)
}

/*
TemplateWorkflowScheduledSendingDeleteTemplateScheduledSendingDefinition Deletes the scheduled sending rules for the template's workflow.

Deletes the scheduled sending rules for the template's workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @return ApiTemplateWorkflowScheduledSendingDeleteTemplateScheduledSendingDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowScheduledSendingDeleteTemplateScheduledSendingDefinition(ctx context.Context, accountId string, templateId string) ApiTemplateWorkflowScheduledSendingDeleteTemplateScheduledSendingDefinitionRequest {
	return ApiTemplateWorkflowScheduledSendingDeleteTemplateScheduledSendingDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowScheduledSendingDeleteTemplateScheduledSendingDefinitionExecute(r ApiTemplateWorkflowScheduledSendingDeleteTemplateScheduledSendingDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.TemplateWorkflowScheduledSendingDeleteTemplateScheduledSendingDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/workflow/scheduledSending"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTemplateWorkflowScheduledSendingGetTemplateScheduledSendingDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	templateId string
}

func (r ApiTemplateWorkflowScheduledSendingGetTemplateScheduledSendingDefinitionRequest) Execute() (*ScheduledSending, *http.Response, error) {
	return r.ApiService.TemplateWorkflowScheduledSendingGetTemplateScheduledSendingDefinitionExecute(r)
}

/*
TemplateWorkflowScheduledSendingGetTemplateScheduledSendingDefinition Returns the scheduled sending rules for a template's workflow definition.

Given a template specified by `templateId`, returns the scheduled sending rules for that template's workflow object.

**Note:** If the template's workflow does not have a scheduled sending object, this method returns a 404.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @return ApiTemplateWorkflowScheduledSendingGetTemplateScheduledSendingDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowScheduledSendingGetTemplateScheduledSendingDefinition(ctx context.Context, accountId string, templateId string) ApiTemplateWorkflowScheduledSendingGetTemplateScheduledSendingDefinitionRequest {
	return ApiTemplateWorkflowScheduledSendingGetTemplateScheduledSendingDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return ScheduledSending
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowScheduledSendingGetTemplateScheduledSendingDefinitionExecute(r ApiTemplateWorkflowScheduledSendingGetTemplateScheduledSendingDefinitionRequest) (*ScheduledSending, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScheduledSending
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.TemplateWorkflowScheduledSendingGetTemplateScheduledSendingDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/workflow/scheduledSending"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTemplateWorkflowScheduledSendingPutTemplateScheduledSendingDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	templateId string
	scheduledSending *ScheduledSending
}

// An object that describes the settings for scheduled sending.
func (r ApiTemplateWorkflowScheduledSendingPutTemplateScheduledSendingDefinitionRequest) ScheduledSending(scheduledSending ScheduledSending) ApiTemplateWorkflowScheduledSendingPutTemplateScheduledSendingDefinitionRequest {
	r.scheduledSending = &scheduledSending
	return r
}

func (r ApiTemplateWorkflowScheduledSendingPutTemplateScheduledSendingDefinitionRequest) Execute() (*ScheduledSending, *http.Response, error) {
	return r.ApiService.TemplateWorkflowScheduledSendingPutTemplateScheduledSendingDefinitionExecute(r)
}

/*
TemplateWorkflowScheduledSendingPutTemplateScheduledSendingDefinition Updates the scheduled sending rules for a template's workflow definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @return ApiTemplateWorkflowScheduledSendingPutTemplateScheduledSendingDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowScheduledSendingPutTemplateScheduledSendingDefinition(ctx context.Context, accountId string, templateId string) ApiTemplateWorkflowScheduledSendingPutTemplateScheduledSendingDefinitionRequest {
	return ApiTemplateWorkflowScheduledSendingPutTemplateScheduledSendingDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return ScheduledSending
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowScheduledSendingPutTemplateScheduledSendingDefinitionExecute(r ApiTemplateWorkflowScheduledSendingPutTemplateScheduledSendingDefinitionRequest) (*ScheduledSending, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScheduledSending
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.TemplateWorkflowScheduledSendingPutTemplateScheduledSendingDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/workflow/scheduledSending"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.scheduledSending
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTemplateWorkflowStepDeleteTemplateWorkflowStepDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	templateId string
	workflowStepId string
}

func (r ApiTemplateWorkflowStepDeleteTemplateWorkflowStepDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.TemplateWorkflowStepDeleteTemplateWorkflowStepDefinitionExecute(r)
}

/*
TemplateWorkflowStepDeleteTemplateWorkflowStepDefinition Deletes a workflow step from an template's workflow definition.

Deletes a workflow step from an template's workflow definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @param workflowStepId The ID of the workflow step.
 @return ApiTemplateWorkflowStepDeleteTemplateWorkflowStepDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowStepDeleteTemplateWorkflowStepDefinition(ctx context.Context, accountId string, templateId string, workflowStepId string) ApiTemplateWorkflowStepDeleteTemplateWorkflowStepDefinitionRequest {
	return ApiTemplateWorkflowStepDeleteTemplateWorkflowStepDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
		workflowStepId: workflowStepId,
	}
}

// Execute executes the request
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowStepDeleteTemplateWorkflowStepDefinitionExecute(r ApiTemplateWorkflowStepDeleteTemplateWorkflowStepDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.TemplateWorkflowStepDeleteTemplateWorkflowStepDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/workflow/steps/{workflowStepId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflowStepId"+"}", url.PathEscape(parameterValueToString(r.workflowStepId, "workflowStepId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTemplateWorkflowStepGetTemplateWorkflowStepDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	templateId string
	workflowStepId string
}

func (r ApiTemplateWorkflowStepGetTemplateWorkflowStepDefinitionRequest) Execute() (*WorkflowStep, *http.Response, error) {
	return r.ApiService.TemplateWorkflowStepGetTemplateWorkflowStepDefinitionExecute(r)
}

/*
TemplateWorkflowStepGetTemplateWorkflowStepDefinition Returns a specified workflow step for a specified envelope.

Returns a workflow step specified by `workflowStepId` for a template specified by `templateId`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @param workflowStepId The ID of the workflow step.
 @return ApiTemplateWorkflowStepGetTemplateWorkflowStepDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowStepGetTemplateWorkflowStepDefinition(ctx context.Context, accountId string, templateId string, workflowStepId string) ApiTemplateWorkflowStepGetTemplateWorkflowStepDefinitionRequest {
	return ApiTemplateWorkflowStepGetTemplateWorkflowStepDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
		workflowStepId: workflowStepId,
	}
}

// Execute executes the request
//  @return WorkflowStep
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowStepGetTemplateWorkflowStepDefinitionExecute(r ApiTemplateWorkflowStepGetTemplateWorkflowStepDefinitionRequest) (*WorkflowStep, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.TemplateWorkflowStepGetTemplateWorkflowStepDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/workflow/steps/{workflowStepId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflowStepId"+"}", url.PathEscape(parameterValueToString(r.workflowStepId, "workflowStepId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTemplateWorkflowStepPostTemplateWorkflowStepDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	templateId string
	workflowStep *WorkflowStep
}

func (r ApiTemplateWorkflowStepPostTemplateWorkflowStepDefinitionRequest) WorkflowStep(workflowStep WorkflowStep) ApiTemplateWorkflowStepPostTemplateWorkflowStepDefinitionRequest {
	r.workflowStep = &workflowStep
	return r
}

func (r ApiTemplateWorkflowStepPostTemplateWorkflowStepDefinitionRequest) Execute() (*WorkflowStep, *http.Response, error) {
	return r.ApiService.TemplateWorkflowStepPostTemplateWorkflowStepDefinitionExecute(r)
}

/*
TemplateWorkflowStepPostTemplateWorkflowStepDefinition Adds a new step to a template's workflow.

Adds a new step to a template's workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @return ApiTemplateWorkflowStepPostTemplateWorkflowStepDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowStepPostTemplateWorkflowStepDefinition(ctx context.Context, accountId string, templateId string) ApiTemplateWorkflowStepPostTemplateWorkflowStepDefinitionRequest {
	return ApiTemplateWorkflowStepPostTemplateWorkflowStepDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return WorkflowStep
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowStepPostTemplateWorkflowStepDefinitionExecute(r ApiTemplateWorkflowStepPostTemplateWorkflowStepDefinitionRequest) (*WorkflowStep, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.TemplateWorkflowStepPostTemplateWorkflowStepDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/workflow/steps"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflowStep
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTemplateWorkflowStepPutTemplateWorkflowStepDefinitionRequest struct {
	ctx context.Context
	ApiService *EnvelopeWorkflowDefinitionAPIService
	accountId string
	templateId string
	workflowStepId string
	workflowStep *WorkflowStep
}

func (r ApiTemplateWorkflowStepPutTemplateWorkflowStepDefinitionRequest) WorkflowStep(workflowStep WorkflowStep) ApiTemplateWorkflowStepPutTemplateWorkflowStepDefinitionRequest {
	r.workflowStep = &workflowStep
	return r
}

func (r ApiTemplateWorkflowStepPutTemplateWorkflowStepDefinitionRequest) Execute() (*WorkflowStep, *http.Response, error) {
	return r.ApiService.TemplateWorkflowStepPutTemplateWorkflowStepDefinitionExecute(r)
}

/*
TemplateWorkflowStepPutTemplateWorkflowStepDefinition Updates a specified workflow step for a template.

Updates a specified workflow step for a template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @param workflowStepId The ID of the workflow step.
 @return ApiTemplateWorkflowStepPutTemplateWorkflowStepDefinitionRequest
*/
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowStepPutTemplateWorkflowStepDefinition(ctx context.Context, accountId string, templateId string, workflowStepId string) ApiTemplateWorkflowStepPutTemplateWorkflowStepDefinitionRequest {
	return ApiTemplateWorkflowStepPutTemplateWorkflowStepDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
		workflowStepId: workflowStepId,
	}
}

// Execute executes the request
//  @return WorkflowStep
func (a *EnvelopeWorkflowDefinitionAPIService) TemplateWorkflowStepPutTemplateWorkflowStepDefinitionExecute(r ApiTemplateWorkflowStepPutTemplateWorkflowStepDefinitionRequest) (*WorkflowStep, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeWorkflowDefinitionAPIService.TemplateWorkflowStepPutTemplateWorkflowStepDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/workflow/steps/{workflowStepId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflowStepId"+"}", url.PathEscape(parameterValueToString(r.workflowStepId, "workflowStepId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflowStep
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
