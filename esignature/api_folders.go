/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// FoldersAPIService FoldersAPI service
type FoldersAPIService service

type ApiFoldersGetFolderItemsRequest struct {
	ctx context.Context
	ApiService *FoldersAPIService
	accountId string
	folderId string
	fromDate *string
	includeItems *string
	ownerEmail *string
	ownerName *string
	searchText *string
	startPosition *string
	status *string
	toDate *string
}

// Reserved for DocuSign.
func (r ApiFoldersGetFolderItemsRequest) FromDate(fromDate string) ApiFoldersGetFolderItemsRequest {
	r.fromDate = &fromDate
	return r
}

// Indicates whether folder items are included in the response. If this parameter is omitted, the default is false.
func (r ApiFoldersGetFolderItemsRequest) IncludeItems(includeItems string) ApiFoldersGetFolderItemsRequest {
	r.includeItems = &includeItems
	return r
}

// Reserved for DocuSign.
func (r ApiFoldersGetFolderItemsRequest) OwnerEmail(ownerEmail string) ApiFoldersGetFolderItemsRequest {
	r.ownerEmail = &ownerEmail
	return r
}

// Reserved for DocuSign.
func (r ApiFoldersGetFolderItemsRequest) OwnerName(ownerName string) ApiFoldersGetFolderItemsRequest {
	r.ownerName = &ownerName
	return r
}

// Reserved for DocuSign.
func (r ApiFoldersGetFolderItemsRequest) SearchText(searchText string) ApiFoldersGetFolderItemsRequest {
	r.searchText = &searchText
	return r
}

// Reserved for DocuSign.
func (r ApiFoldersGetFolderItemsRequest) StartPosition(startPosition string) ApiFoldersGetFolderItemsRequest {
	r.startPosition = &startPosition
	return r
}

// Reserved for DocuSign.
func (r ApiFoldersGetFolderItemsRequest) Status(status string) ApiFoldersGetFolderItemsRequest {
	r.status = &status
	return r
}

// Reserved for DocuSign.
func (r ApiFoldersGetFolderItemsRequest) ToDate(toDate string) ApiFoldersGetFolderItemsRequest {
	r.toDate = &toDate
	return r
}

func (r ApiFoldersGetFolderItemsRequest) Execute() (*FolderItemsResponse, *http.Response, error) {
	return r.ApiService.FoldersGetFolderItemsExecute(r)
}

/*
FoldersGetFolderItems Gets information about items in a specified folder. 

Gets information about items in the specified folder. 

To include a list of the items in the folder, set the `include_items` query parameter to **true.**

### Related topics

- [Searching for envelopes](/docs/esign-rest-api/esign101/concepts/envelopes/search/)
- [Sharing templates](/docs/esign-rest-api/esign101/concepts/templates/sharing/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param folderId The ID of the folder.
 @return ApiFoldersGetFolderItemsRequest
*/
func (a *FoldersAPIService) FoldersGetFolderItems(ctx context.Context, accountId string, folderId string) ApiFoldersGetFolderItemsRequest {
	return ApiFoldersGetFolderItemsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		folderId: folderId,
	}
}

// Execute executes the request
//  @return FolderItemsResponse
func (a *FoldersAPIService) FoldersGetFolderItemsExecute(r ApiFoldersGetFolderItemsRequest) (*FolderItemsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolderItemsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoldersAPIService.FoldersGetFolderItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/folders/{folderId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"folderId"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "")
	}
	if r.includeItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_items", r.includeItems, "")
	}
	if r.ownerEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner_email", r.ownerEmail, "")
	}
	if r.ownerName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner_name", r.ownerName, "")
	}
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_text", r.searchText, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_date", r.toDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFoldersGetFoldersRequest struct {
	ctx context.Context
	ApiService *FoldersAPIService
	accountId string
	count *string
	include *string
	includeItems *string
	startPosition *string
	subFolderDepth *string
	template *string
	userFilter *string
}

// The maximum number of results to return.
func (r ApiFoldersGetFoldersRequest) Count(count string) ApiFoldersGetFoldersRequest {
	r.count = &count
	return r
}

// A comma-separated list of folder types to include in the response. Valid values are:  - &#x60;envelope_folders&#x60;: Returns a list of envelope folders. (Default) - &#x60;template_folders&#x60;: Returns a list of template folders.  - &#x60;shared_template_folders&#x60;: Returns a list of shared template folders. 
func (r ApiFoldersGetFoldersRequest) Include(include string) ApiFoldersGetFoldersRequest {
	r.include = &include
	return r
}

// Indicates whether folder items are included in the response. If this parameter is omitted, the default is false.
func (r ApiFoldersGetFoldersRequest) IncludeItems(includeItems string) ApiFoldersGetFoldersRequest {
	r.includeItems = &includeItems
	return r
}

// The zero-based index of the result from which to start returning results.  The default value is &#x60;0&#x60;. 
func (r ApiFoldersGetFoldersRequest) StartPosition(startPosition string) ApiFoldersGetFoldersRequest {
	r.startPosition = &startPosition
	return r
}

// If missing or any value other than &#x60;-1&#x60;, the returned list contains only the top-level folders. A value of &#x60;-1&#x60; returns the complete folder hierarchy. 
func (r ApiFoldersGetFoldersRequest) SubFolderDepth(subFolderDepth string) ApiFoldersGetFoldersRequest {
	r.subFolderDepth = &subFolderDepth
	return r
}

// This parameter is deprecated as of version 2.1. Use &#x60;include&#x60; instead.
func (r ApiFoldersGetFoldersRequest) Template(template string) ApiFoldersGetFoldersRequest {
	r.template = &template
	return r
}

// Narrows down the resulting folder list by the following values:  - &#x60;all&#x60;: Returns all templates owned or shared with the user. (default) - &#x60;owned_by_me&#x60;: Returns only  templates the user owns. - &#x60;shared_with_me&#x60;: Returns only templates that are shared with the user. 
func (r ApiFoldersGetFoldersRequest) UserFilter(userFilter string) ApiFoldersGetFoldersRequest {
	r.userFilter = &userFilter
	return r
}

func (r ApiFoldersGetFoldersRequest) Execute() (*FoldersResponse, *http.Response, error) {
	return r.ApiService.FoldersGetFoldersExecute(r)
}

/*
FoldersGetFolders Returns a list of the account's folders.

Returns a list of the account's folders.

Use the `include` query parameter to specify the kinds of folders to return.

By default, only the first level of subfolders is shown.
Set the `sub_folder_depth` query parameter to `-1` to return the entire folder hierarchy.


<ds-column>

<ds-step open="false" hideIcon="true">

Default returns only top-level folders. Click to show.

<div>

`GET 'https://demo.docusign.net/restapi/v2.1/accounts/624e3e00-xxxx-xxxx-xxxx-43918c520dab/folders'`


```json
{
  "resultSetSize": "5",
  "startPosition": "0",
  "endPosition": "4",
  "totalSetSize": "5",
  "folders": [
    {
      "name": "Draft",
      "type": "draft",
      "itemCount": "1",
      "subFolderCount": "0",
      "hasSubFolders": "false"
    },
    {
      "name": "Inbox",
      "type": "inbox",
      "itemCount": "0",
      "subFolderCount": "1",
      "hasSubFolders": "true",
      "folders": [
        {
          "name": "Project Fair",
          "type": "normal",
          "hasSubFolders": "false",
          "parentFolderId": "3ed02ee3-xxxx-xxxx-xxxx-e6795f96a840",
          "parentFolderUri": "/folders/3ed02ee3-xxxx-xxxx-xxxx-e6795f96a840"
        }
      ]
    },
    {
      "name": "Deleted Items",
      "type": "recyclebin",
      "itemCount": "0",
      "subFolderCount": "0",
      "hasSubFolders": "false"
    },
    {
      "name": "Sent Items",
      "type": "sentitems",
      "itemCount": "3",
      "subFolderCount": "0",
      "hasSubFolders": "false"
    }
  ]
}

```

</div></ds-step>


<ds-step open="false" hideIcon="true">

Setting `sub_folder_depth` to `-1` returns the entire folder hierarchy.
Click to show.


<div>

`GET 'https://demo.docusign.net/restapi/v2.1/accounts/624e3e00-xxxx-xxxx-xxxx-43918c520dab/folders?sub_folder_depth=-1'`

One envelope has been moved from the `Inbox` folder to the
`Project Fair/Phase 1` folder, and the endpoint is invoked
with `sub_folder_depth=-1`.


```json
{
  "resultSetSize": "5",
  "startPosition": "0",
  "endPosition": "4",
  "totalSetSize": "4",
  "folders": [
    {
      "name": "Draft",
      "type": "draft",
      "itemCount": "1",
      "hasSubFolders": "false"
    },
    {
      "name": "Inbox",
      "type": "inbox",
      "itemCount": "0",
      "hasSubFolders": "true",
      "folders": [
        {
          "name": "Project Fair",
          "type": "normal",
          "itemCount": "0",
          "hasSubFolders": "true",
          "parentFolderId": "3ed02ee3-xxxx-xxxx-xxxx-e6795f96a840",
          "parentFolderUri": "/folders/3ed02ee3-xxxx-xxxx-xxxx-e6795f96a840",
          "folders": [
            {
              "name": "NDAs",
              "type": "normal",
              "itemCount": "0",
              "hasSubFolders": "false",
              "parentFolderId": "12882f2f-xxxx-xxxx-xxxx-e04a714f8e2d",
              "parentFolderUri": "/folders/12882f2f-xxxx-xxxx-xxxx-e04a714f8e2d"
            },
            {
              "name": "Phase 1",
              "type": "normal",
              "itemCount": "1",
              "hasSubFolders": "false",
              "parentFolderId": "12882f2f-xxxx-xxxx-xxxx-e04a714f8e2d",
              "parentFolderUri": "/folders/12882f2f-xxxx-xxxx-xxxx-e04a714f8e2d"
            }
          ]
        }
      ]
    },
    {
      "name": "Deleted Items",
      "type": "recyclebin",
      "itemCount": "0",
      "hasSubFolders": "false"
    },
    {
      "name": "Sent Items",
      "type": "sentitems",
      "itemCount": "1",
      "hasSubFolders": "false"
    }
  ]
}
```

</div></ds-step>
</ds-column>


### Related topics

- [Searching for envelopes](/docs/esign-rest-api/esign101/concepts/envelopes/search/)
- [Sharing templates](/docs/esign-rest-api/esign101/concepts/templates/sharing/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiFoldersGetFoldersRequest
*/
func (a *FoldersAPIService) FoldersGetFolders(ctx context.Context, accountId string) ApiFoldersGetFoldersRequest {
	return ApiFoldersGetFoldersRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return FoldersResponse
func (a *FoldersAPIService) FoldersGetFoldersExecute(r ApiFoldersGetFoldersRequest) (*FoldersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FoldersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoldersAPIService.FoldersGetFolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/folders"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	if r.includeItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_items", r.includeItems, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	if r.subFolderDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sub_folder_depth", r.subFolderDepth, "")
	}
	if r.template != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "template", r.template, "")
	}
	if r.userFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_filter", r.userFilter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFoldersPutFolderByIdRequest struct {
	ctx context.Context
	ApiService *FoldersAPIService
	accountId string
	folderId string
	foldersRequest *FoldersRequest
}

func (r ApiFoldersPutFolderByIdRequest) FoldersRequest(foldersRequest FoldersRequest) ApiFoldersPutFolderByIdRequest {
	r.foldersRequest = &foldersRequest
	return r
}

func (r ApiFoldersPutFolderByIdRequest) Execute() (*FoldersResponse, *http.Response, error) {
	return r.ApiService.FoldersPutFolderByIdExecute(r)
}

/*
FoldersPutFolderById Moves a set of envelopes from their current folder to another folder.

Moves a set of envelopes from their current folder to another folder.

The `folderId` path parameter is the destination folder.
The request body has an array of envelope IDs and the
ID of the source folder.

<ds-inlinemessage kind="warning"  markdown="1">
Do not use the <code>folders</code> property in the request body.

</ds-inlinemessage>

If `folderId` is the special value **`recyclebin`**
the envelopes are moved to the Deleted folder.
Moving an in-process envelope
(envelope status of `sent` or `delivered`)
to the **`recyclebin`**
voids the envelope.


### Related topics

- [Searching for envelopes](/docs/esign-rest-api/esign101/concepts/envelopes/search/)
- [Sharing templates](/docs/esign-rest-api/esign101/concepts/templates/sharing/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param folderId The ID of the folder.
 @return ApiFoldersPutFolderByIdRequest
*/
func (a *FoldersAPIService) FoldersPutFolderById(ctx context.Context, accountId string, folderId string) ApiFoldersPutFolderByIdRequest {
	return ApiFoldersPutFolderByIdRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		folderId: folderId,
	}
}

// Execute executes the request
//  @return FoldersResponse
func (a *FoldersAPIService) FoldersPutFolderByIdExecute(r ApiFoldersPutFolderByIdRequest) (*FoldersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FoldersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoldersAPIService.FoldersPutFolderById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/folders/{folderId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"folderId"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.foldersRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchFoldersGetSearchFolderContentsRequest struct {
	ctx context.Context
	ApiService *FoldersAPIService
	accountId string
	searchFolderId string
	all *string
	count *string
	fromDate *string
	includeRecipients *string
	order *string
	orderBy *string
	startPosition *string
	toDate *string
}

// Specifies that all envelopes that match the criteria are returned.
func (r ApiSearchFoldersGetSearchFolderContentsRequest) All(all string) ApiSearchFoldersGetSearchFolderContentsRequest {
	r.all = &all
	return r
}

// The maximum number of results to return.  Use &#x60;start_position&#x60; to specify the number of results to skip.  Valid values: &#x60;1&#x60; to &#x60;100&#x60; 
func (r ApiSearchFoldersGetSearchFolderContentsRequest) Count(count string) ApiSearchFoldersGetSearchFolderContentsRequest {
	r.count = &count
	return r
}

// Specifies the start of the date range to return. If no value is provided, the default search is the previous 30 days.
func (r ApiSearchFoldersGetSearchFolderContentsRequest) FromDate(fromDate string) ApiSearchFoldersGetSearchFolderContentsRequest {
	r.fromDate = &fromDate
	return r
}

// When **true,** the recipient information is returned in the response.
func (r ApiSearchFoldersGetSearchFolderContentsRequest) IncludeRecipients(includeRecipients string) ApiSearchFoldersGetSearchFolderContentsRequest {
	r.includeRecipients = &includeRecipients
	return r
}

// Specifies the order in which the list is returned. Valid values are: &#x60;asc&#x60; for ascending order, and &#x60;desc&#x60; for descending order.
func (r ApiSearchFoldersGetSearchFolderContentsRequest) Order(order string) ApiSearchFoldersGetSearchFolderContentsRequest {
	r.order = &order
	return r
}

// Specifies the property used to sort the list. Valid values are: &#x60;action_required&#x60;, &#x60;created&#x60;, &#x60;completed&#x60;, &#x60;sent&#x60;, &#x60;signer_list&#x60;, &#x60;status&#x60;, or &#x60;subject&#x60;.
func (r ApiSearchFoldersGetSearchFolderContentsRequest) OrderBy(orderBy string) ApiSearchFoldersGetSearchFolderContentsRequest {
	r.orderBy = &orderBy
	return r
}

// The zero-based index of the result from which to start returning results.  Use with &#x60;count&#x60; to limit the number of results.  The default value is &#x60;0&#x60;. 
func (r ApiSearchFoldersGetSearchFolderContentsRequest) StartPosition(startPosition string) ApiSearchFoldersGetSearchFolderContentsRequest {
	r.startPosition = &startPosition
	return r
}

// Specifies the end of the date range to return.
func (r ApiSearchFoldersGetSearchFolderContentsRequest) ToDate(toDate string) ApiSearchFoldersGetSearchFolderContentsRequest {
	r.toDate = &toDate
	return r
}

func (r ApiSearchFoldersGetSearchFolderContentsRequest) Execute() (*FolderItemResponse, *http.Response, error) {
	return r.ApiService.SearchFoldersGetSearchFolderContentsExecute(r)
}

/*
SearchFoldersGetSearchFolderContents Deprecated. Use Envelopes: listStatusChanges.

<ds-inlinemessage kind="warning"  markdown="1">
<strong>This method is deprecated in API v2.1</strong>

Use  [Envelopes: listStatusChanges](/docs/esign-rest-api/reference/envelopes/envelopes/liststatuschanges/) instead.
</ds-inlinemessage>


Retrieves a list of items that match the criteria specified in the query.

If the user ID of the user making the call is the
same as the user ID for any returned recipient,
then the `userId` property is added to the returned
information for those recipients.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param searchFolderId Specifies the envelope group that is searched by the request. These are logical groupings, not actual folder names. Valid values are: drafts, awaiting_my_signature, completed, out_for_signature.
 @return ApiSearchFoldersGetSearchFolderContentsRequest
*/
func (a *FoldersAPIService) SearchFoldersGetSearchFolderContents(ctx context.Context, accountId string, searchFolderId string) ApiSearchFoldersGetSearchFolderContentsRequest {
	return ApiSearchFoldersGetSearchFolderContentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		searchFolderId: searchFolderId,
	}
}

// Execute executes the request
//  @return FolderItemResponse
func (a *FoldersAPIService) SearchFoldersGetSearchFolderContentsExecute(r ApiSearchFoldersGetSearchFolderContentsRequest) (*FolderItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolderItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoldersAPIService.SearchFoldersGetSearchFolderContents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/search_folders/{searchFolderId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"searchFolderId"+"}", url.PathEscape(parameterValueToString(r.searchFolderId, "searchFolderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.all != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "all", r.all, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "")
	}
	if r.includeRecipients != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_recipients", r.includeRecipients, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_date", r.toDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
