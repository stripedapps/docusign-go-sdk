/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// AccountBrandsAPIService AccountBrandsAPI service
type AccountBrandsAPIService service

type ApiBrandDeleteBrandRequest struct {
	ctx context.Context
	ApiService *AccountBrandsAPIService
	accountId string
	brandId string
}

func (r ApiBrandDeleteBrandRequest) Execute() (*http.Response, error) {
	return r.ApiService.BrandDeleteBrandExecute(r)
}

/*
BrandDeleteBrand Deletes a brand.

This method deletes a brand from an account.

**Note:** Branding for either signing or sending must be enabled for the account (`canSelfBrandSend` , `canSelfBrandSign`, or both of these account settings must be **true**).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param brandId The ID of the brand.
 @return ApiBrandDeleteBrandRequest
*/
func (a *AccountBrandsAPIService) BrandDeleteBrand(ctx context.Context, accountId string, brandId string) ApiBrandDeleteBrandRequest {
	return ApiBrandDeleteBrandRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		brandId: brandId,
	}
}

// Execute executes the request
func (a *AccountBrandsAPIService) BrandDeleteBrandExecute(r ApiBrandDeleteBrandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountBrandsAPIService.BrandDeleteBrand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/brands/{brandId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"brandId"+"}", url.PathEscape(parameterValueToString(r.brandId, "brandId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBrandExportGetBrandExportFileRequest struct {
	ctx context.Context
	ApiService *AccountBrandsAPIService
	accountId string
	brandId string
}

func (r ApiBrandExportGetBrandExportFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.BrandExportGetBrandExportFileExecute(r)
}

/*
BrandExportGetBrandExportFile Exports a brand.

This method exports information about a brand to an XML file.

**Note:** Branding for either signing or sending must be enabled for the account (`canSelfBrandSend` , `canSelfBrandSign`, or both of these account settings must be **true**).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param brandId The ID of the brand.
 @return ApiBrandExportGetBrandExportFileRequest
*/
func (a *AccountBrandsAPIService) BrandExportGetBrandExportFile(ctx context.Context, accountId string, brandId string) ApiBrandExportGetBrandExportFileRequest {
	return ApiBrandExportGetBrandExportFileRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		brandId: brandId,
	}
}

// Execute executes the request
func (a *AccountBrandsAPIService) BrandExportGetBrandExportFileExecute(r ApiBrandExportGetBrandExportFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountBrandsAPIService.BrandExportGetBrandExportFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/brands/{brandId}/file"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"brandId"+"}", url.PathEscape(parameterValueToString(r.brandId, "brandId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBrandGetBrandRequest struct {
	ctx context.Context
	ApiService *AccountBrandsAPIService
	accountId string
	brandId string
	includeExternalReferences *string
	includeLogos *string
}

// When **true,** the landing pages and links associated with the brand are included in the response.
func (r ApiBrandGetBrandRequest) IncludeExternalReferences(includeExternalReferences string) ApiBrandGetBrandRequest {
	r.includeExternalReferences = &includeExternalReferences
	return r
}

// When **true,** the URIs for the logos associated with the brand are included in the response.
func (r ApiBrandGetBrandRequest) IncludeLogos(includeLogos string) ApiBrandGetBrandRequest {
	r.includeLogos = &includeLogos
	return r
}

func (r ApiBrandGetBrandRequest) Execute() (*Brand, *http.Response, error) {
	return r.ApiService.BrandGetBrandExecute(r)
}

/*
BrandGetBrand Gets information about a brand.

This method returns details about an account brand.

**Note:** Branding for either signing or sending must be enabled for the account (`canSelfBrandSend` , `canSelfBrandSign`, or both of these account settings must be **true**).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param brandId The ID of the brand.
 @return ApiBrandGetBrandRequest
*/
func (a *AccountBrandsAPIService) BrandGetBrand(ctx context.Context, accountId string, brandId string) ApiBrandGetBrandRequest {
	return ApiBrandGetBrandRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		brandId: brandId,
	}
}

// Execute executes the request
//  @return Brand
func (a *AccountBrandsAPIService) BrandGetBrandExecute(r ApiBrandGetBrandRequest) (*Brand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Brand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountBrandsAPIService.BrandGetBrand")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/brands/{brandId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"brandId"+"}", url.PathEscape(parameterValueToString(r.brandId, "brandId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeExternalReferences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_external_references", r.includeExternalReferences, "")
	}
	if r.includeLogos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_logos", r.includeLogos, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBrandLogoDeleteBrandLogoRequest struct {
	ctx context.Context
	ApiService *AccountBrandsAPIService
	accountId string
	brandId string
	logoType string
}

func (r ApiBrandLogoDeleteBrandLogoRequest) Execute() (*http.Response, error) {
	return r.ApiService.BrandLogoDeleteBrandLogoExecute(r)
}

/*
BrandLogoDeleteBrandLogo Deletes a brand logo.

This method deletes a single logo from an account brand.

**Note:** Branding for either signing or sending must be enabled for the account (`canSelfBrandSend` , `canSelfBrandSign`, or both of these account settings must be **true**).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param brandId The ID of the brand.
 @param logoType The type of logo. Valid values are:  - `primary`  - `secondary`  - `email`
 @return ApiBrandLogoDeleteBrandLogoRequest
*/
func (a *AccountBrandsAPIService) BrandLogoDeleteBrandLogo(ctx context.Context, accountId string, brandId string, logoType string) ApiBrandLogoDeleteBrandLogoRequest {
	return ApiBrandLogoDeleteBrandLogoRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		brandId: brandId,
		logoType: logoType,
	}
}

// Execute executes the request
func (a *AccountBrandsAPIService) BrandLogoDeleteBrandLogoExecute(r ApiBrandLogoDeleteBrandLogoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountBrandsAPIService.BrandLogoDeleteBrandLogo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/brands/{brandId}/logos/{logoType}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"brandId"+"}", url.PathEscape(parameterValueToString(r.brandId, "brandId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"logoType"+"}", url.PathEscape(parameterValueToString(r.logoType, "logoType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBrandLogoGetBrandLogoRequest struct {
	ctx context.Context
	ApiService *AccountBrandsAPIService
	accountId string
	brandId string
	logoType string
}

func (r ApiBrandLogoGetBrandLogoRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.BrandLogoGetBrandLogoExecute(r)
}

/*
BrandLogoGetBrandLogo Gets a brand logo.

This method returns a specific logo that is used in a brand.

**Note:** Branding for either signing or sending must be enabled for the account (`canSelfBrandSend` , `canSelfBrandSign`, or both of these account settings must be **true**).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param brandId The ID of the brand.
 @param logoType The type of logo. Valid values are:  - `primary`  - `secondary`  - `email`
 @return ApiBrandLogoGetBrandLogoRequest
*/
func (a *AccountBrandsAPIService) BrandLogoGetBrandLogo(ctx context.Context, accountId string, brandId string, logoType string) ApiBrandLogoGetBrandLogoRequest {
	return ApiBrandLogoGetBrandLogoRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		brandId: brandId,
		logoType: logoType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountBrandsAPIService) BrandLogoGetBrandLogoExecute(r ApiBrandLogoGetBrandLogoRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountBrandsAPIService.BrandLogoGetBrandLogo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/brands/{brandId}/logos/{logoType}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"brandId"+"}", url.PathEscape(parameterValueToString(r.brandId, "brandId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"logoType"+"}", url.PathEscape(parameterValueToString(r.logoType, "logoType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/png"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBrandLogoPutBrandLogoRequest struct {
	ctx context.Context
	ApiService *AccountBrandsAPIService
	accountId string
	brandId string
	logoType string
	logoFileBytes *os.File
}

// Brand logo binary Stream. Supported formats: JPG, GIF, PNG. Maximum file size: 300 KB. Recommended dimensions: 296 x 76 pixels (larger images will be resized). Changes may take up to one hour to display in all places
func (r ApiBrandLogoPutBrandLogoRequest) LogoFileBytes(logoFileBytes *os.File) ApiBrandLogoPutBrandLogoRequest {
	r.logoFileBytes = logoFileBytes
	return r
}

func (r ApiBrandLogoPutBrandLogoRequest) Execute() (*http.Response, error) {
	return r.ApiService.BrandLogoPutBrandLogoExecute(r)
}

/*
BrandLogoPutBrandLogo Updates a brand logo.

This method updates a single brand logo.

You pass in the new version of the resource in the `Content-Disposition` header. Example:

`Content-Disposition: form-data; name="file"; filename="logo.jpg"`

**Note:** Branding for either signing or sending must be enabled for the account (`canSelfBrandSend` , `canSelfBrandSign`, or both of these account settings must be **true**).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param brandId The ID of the brand.
 @param logoType The type of logo. Valid values are:  - `primary`  - `secondary`  - `email`
 @return ApiBrandLogoPutBrandLogoRequest
*/
func (a *AccountBrandsAPIService) BrandLogoPutBrandLogo(ctx context.Context, accountId string, brandId string, logoType string) ApiBrandLogoPutBrandLogoRequest {
	return ApiBrandLogoPutBrandLogoRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		brandId: brandId,
		logoType: logoType,
	}
}

// Execute executes the request
func (a *AccountBrandsAPIService) BrandLogoPutBrandLogoExecute(r ApiBrandLogoPutBrandLogoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountBrandsAPIService.BrandLogoPutBrandLogo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/brands/{brandId}/logos/{logoType}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"brandId"+"}", url.PathEscape(parameterValueToString(r.brandId, "brandId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"logoType"+"}", url.PathEscape(parameterValueToString(r.logoType, "logoType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.logoFileBytes == nil {
		return nil, reportError("logoFileBytes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"image/png"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.logoFileBytes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBrandPutBrandRequest struct {
	ctx context.Context
	ApiService *AccountBrandsAPIService
	accountId string
	brandId string
	replaceBrand *string
	brand *Brand
}

// When **true,** replaces the brand instead of updating it. The only unchanged value is the brand ID. The request body must be XML. The default value is **false.**
func (r ApiBrandPutBrandRequest) ReplaceBrand(replaceBrand string) ApiBrandPutBrandRequest {
	r.replaceBrand = &replaceBrand
	return r
}

func (r ApiBrandPutBrandRequest) Brand(brand Brand) ApiBrandPutBrandRequest {
	r.brand = &brand
	return r
}

func (r ApiBrandPutBrandRequest) Execute() (*Brand, *http.Response, error) {
	return r.ApiService.BrandPutBrandExecute(r)
}

/*
BrandPutBrand Updates an existing brand.

This method updates an account brand. 

**Note:** Branding for either signing or sending must be enabled for the account (`canSelfBrandSend` , `canSelfBrandSign`, or both of these account settings must be **true**).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param brandId The ID of the brand.
 @return ApiBrandPutBrandRequest
*/
func (a *AccountBrandsAPIService) BrandPutBrand(ctx context.Context, accountId string, brandId string) ApiBrandPutBrandRequest {
	return ApiBrandPutBrandRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		brandId: brandId,
	}
}

// Execute executes the request
//  @return Brand
func (a *AccountBrandsAPIService) BrandPutBrandExecute(r ApiBrandPutBrandRequest) (*Brand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Brand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountBrandsAPIService.BrandPutBrand")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/brands/{brandId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"brandId"+"}", url.PathEscape(parameterValueToString(r.brandId, "brandId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.replaceBrand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replace_brand", r.replaceBrand, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.brand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBrandResourcesGetBrandResourcesRequest struct {
	ctx context.Context
	ApiService *AccountBrandsAPIService
	accountId string
	brandId string
	resourceContentType string
	langcode *string
	returnMaster *string
}

// The ISO 3166-1 alpha-2 codes for the languages that the brand supports.
func (r ApiBrandResourcesGetBrandResourcesRequest) Langcode(langcode string) ApiBrandResourcesGetBrandResourcesRequest {
	r.langcode = &langcode
	return r
}

// Specifies which resource file data to return. When **true,** only the master resource file is returned. When **false,** only the elements that you modified are returned.
func (r ApiBrandResourcesGetBrandResourcesRequest) ReturnMaster(returnMaster string) ApiBrandResourcesGetBrandResourcesRequest {
	r.returnMaster = &returnMaster
	return r
}

func (r ApiBrandResourcesGetBrandResourcesRequest) Execute() (*http.Response, error) {
	return r.ApiService.BrandResourcesGetBrandResourcesExecute(r)
}

/*
BrandResourcesGetBrandResources Returns a branding resource file.

This method returns a specific branding resource file.

A brand uses a set of brand resource files to control the sending, signing, email message, and captive (embedded) signing experiences.  You can modify the default email messages and formats in these files and upload them to your brand to customize the user experience.

**Important:** When you upload a modified resource file, only the elements that differ from the master resource file are saved as your resource file. Similarly, when you download your resource files, only the modified elements are included in the file. 

**Note:** Branding for either signing or sending must be enabled for the account (`canSelfBrandSend` , `canSelfBrandSign`, or both of these account settings must be **true**).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param brandId The ID of the brand.
 @param resourceContentType The type of brand resource file to return. Valid values are:  - `sending` - `signing` - `email` - `signing_captive`
 @return ApiBrandResourcesGetBrandResourcesRequest
*/
func (a *AccountBrandsAPIService) BrandResourcesGetBrandResources(ctx context.Context, accountId string, brandId string, resourceContentType string) ApiBrandResourcesGetBrandResourcesRequest {
	return ApiBrandResourcesGetBrandResourcesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		brandId: brandId,
		resourceContentType: resourceContentType,
	}
}

// Execute executes the request
func (a *AccountBrandsAPIService) BrandResourcesGetBrandResourcesExecute(r ApiBrandResourcesGetBrandResourcesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountBrandsAPIService.BrandResourcesGetBrandResources")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/brands/{brandId}/resources/{resourceContentType}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"brandId"+"}", url.PathEscape(parameterValueToString(r.brandId, "brandId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resourceContentType"+"}", url.PathEscape(parameterValueToString(r.resourceContentType, "resourceContentType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.langcode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "langcode", r.langcode, "")
	}
	if r.returnMaster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "return_master", r.returnMaster, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBrandResourcesGetBrandResourcesListRequest struct {
	ctx context.Context
	ApiService *AccountBrandsAPIService
	accountId string
	brandId string
}

func (r ApiBrandResourcesGetBrandResourcesListRequest) Execute() (*BrandResourcesList, *http.Response, error) {
	return r.ApiService.BrandResourcesGetBrandResourcesListExecute(r)
}

/*
BrandResourcesGetBrandResourcesList Returns metadata about the branding resources for an account.

This method returns metadata about the branding resources that are associated with an account.

**Note:** Branding for either signing or sending must be enabled for the account (`canSelfBrandSend` , `canSelfBrandSign`, or both of these account settings must be **true**).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param brandId The ID of the brand.
 @return ApiBrandResourcesGetBrandResourcesListRequest
*/
func (a *AccountBrandsAPIService) BrandResourcesGetBrandResourcesList(ctx context.Context, accountId string, brandId string) ApiBrandResourcesGetBrandResourcesListRequest {
	return ApiBrandResourcesGetBrandResourcesListRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		brandId: brandId,
	}
}

// Execute executes the request
//  @return BrandResourcesList
func (a *AccountBrandsAPIService) BrandResourcesGetBrandResourcesListExecute(r ApiBrandResourcesGetBrandResourcesListRequest) (*BrandResourcesList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BrandResourcesList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountBrandsAPIService.BrandResourcesGetBrandResourcesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/brands/{brandId}/resources"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"brandId"+"}", url.PathEscape(parameterValueToString(r.brandId, "brandId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBrandResourcesPutBrandResourcesRequest struct {
	ctx context.Context
	ApiService *AccountBrandsAPIService
	accountId string
	brandId string
	resourceContentType string
	fileXml *os.File
}

// Brand resource XML file.
func (r ApiBrandResourcesPutBrandResourcesRequest) FileXml(fileXml *os.File) ApiBrandResourcesPutBrandResourcesRequest {
	r.fileXml = fileXml
	return r
}

func (r ApiBrandResourcesPutBrandResourcesRequest) Execute() (*BrandResources, *http.Response, error) {
	return r.ApiService.BrandResourcesPutBrandResourcesExecute(r)
}

/*
BrandResourcesPutBrandResources Updates a branding resource file.

This method updates a branding resource file.

You pass in the new version of the resource file in the `Content-Disposition` header. Example:

`Content-Disposition: form-data; name="file"; filename="DocuSign_SigningResource_4328673.xml"`

**Note:** Branding for either signing or sending must be enabled for the account (`canSelfBrandSend` , `canSelfBrandSign`, or both of these account settings must be **true**).

**Important:** Customizing resource files is an advanced branding configuration option which can significantly impact your account, and should be done only by someone with expertise in XML and HTML. The master resource files are subject to change without notice. If you customize your resource files, after each release, DocuSign recommends you review any changes and update your custom files as needed.

When you upload a modified resource file, only the elements that differ from the master resource file are saved as your resource file. Similarly, when you download your resource files, only the modified elements are included in the file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param brandId The ID of the brand.
 @param resourceContentType The type of brand resource file that you are updating. Valid values are:  - `sending` - `signing` - `email` - `signing_captive`
 @return ApiBrandResourcesPutBrandResourcesRequest
*/
func (a *AccountBrandsAPIService) BrandResourcesPutBrandResources(ctx context.Context, accountId string, brandId string, resourceContentType string) ApiBrandResourcesPutBrandResourcesRequest {
	return ApiBrandResourcesPutBrandResourcesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		brandId: brandId,
		resourceContentType: resourceContentType,
	}
}

// Execute executes the request
//  @return BrandResources
func (a *AccountBrandsAPIService) BrandResourcesPutBrandResourcesExecute(r ApiBrandResourcesPutBrandResourcesRequest) (*BrandResources, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BrandResources
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountBrandsAPIService.BrandResourcesPutBrandResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/brands/{brandId}/resources/{resourceContentType}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"brandId"+"}", url.PathEscape(parameterValueToString(r.brandId, "brandId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resourceContentType"+"}", url.PathEscape(parameterValueToString(r.resourceContentType, "resourceContentType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileXml == nil {
		return localVarReturnValue, nil, reportError("fileXml is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileXmlLocalVarFormFileName string
	var fileXmlLocalVarFileName     string
	var fileXmlLocalVarFileBytes    []byte

	fileXmlLocalVarFormFileName = "file.xml"


	fileXmlLocalVarFile := r.fileXml

	if fileXmlLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileXmlLocalVarFile)

		fileXmlLocalVarFileBytes = fbs
		fileXmlLocalVarFileName = fileXmlLocalVarFile.Name()
		fileXmlLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileXmlLocalVarFileBytes, fileName: fileXmlLocalVarFileName, formFileName: fileXmlLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBrandsDeleteBrandsRequest struct {
	ctx context.Context
	ApiService *AccountBrandsAPIService
	accountId string
	brandsRequest *BrandsRequest
}

func (r ApiBrandsDeleteBrandsRequest) BrandsRequest(brandsRequest BrandsRequest) ApiBrandsDeleteBrandsRequest {
	r.brandsRequest = &brandsRequest
	return r
}

func (r ApiBrandsDeleteBrandsRequest) Execute() (*AccountBrands, *http.Response, error) {
	return r.ApiService.BrandsDeleteBrandsExecute(r)
}

/*
BrandsDeleteBrands Deletes one or more brand profiles.

This method deletes one or more brand profiles from an account, based on the brand IDs that you include in the `brandsRequest`.

Either or both of the following settings must be enabled for the account to use this method:

- `canSelfBrandSign`
- `canSelfBrandSend`

### Related topics

- [How to create a brand](/docs/esign-rest-api/how-to/create-brand/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiBrandsDeleteBrandsRequest
*/
func (a *AccountBrandsAPIService) BrandsDeleteBrands(ctx context.Context, accountId string) ApiBrandsDeleteBrandsRequest {
	return ApiBrandsDeleteBrandsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return AccountBrands
func (a *AccountBrandsAPIService) BrandsDeleteBrandsExecute(r ApiBrandsDeleteBrandsRequest) (*AccountBrands, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountBrands
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountBrandsAPIService.BrandsDeleteBrands")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/brands"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.brandsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBrandsGetBrandsRequest struct {
	ctx context.Context
	ApiService *AccountBrandsAPIService
	accountId string
	excludeDistributorBrand *string
	includeLogos *string
}

// When **true,** excludes distributor brand information from the response set.
func (r ApiBrandsGetBrandsRequest) ExcludeDistributorBrand(excludeDistributorBrand string) ApiBrandsGetBrandsRequest {
	r.excludeDistributorBrand = &excludeDistributorBrand
	return r
}

// When **true,** returns the logos associated with the brand.
func (r ApiBrandsGetBrandsRequest) IncludeLogos(includeLogos string) ApiBrandsGetBrandsRequest {
	r.includeLogos = &includeLogos
	return r
}

func (r ApiBrandsGetBrandsRequest) Execute() (*AccountBrands, *http.Response, error) {
	return r.ApiService.BrandsGetBrandsExecute(r)
}

/*
BrandsGetBrands Gets a list of brands.

This method returns details about all of the brands associated with an account,
including the default brand profiles.

Either or both of the following settings must be enabled for the account to use this method:

- `canSelfBrandSign`
- `canSelfBrandSend`

### Related topics

- [How to create a brand](/docs/esign-rest-api/how-to/create-brand/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiBrandsGetBrandsRequest
*/
func (a *AccountBrandsAPIService) BrandsGetBrands(ctx context.Context, accountId string) ApiBrandsGetBrandsRequest {
	return ApiBrandsGetBrandsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return AccountBrands
func (a *AccountBrandsAPIService) BrandsGetBrandsExecute(r ApiBrandsGetBrandsRequest) (*AccountBrands, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountBrands
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountBrandsAPIService.BrandsGetBrands")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/brands"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.excludeDistributorBrand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_distributor_brand", r.excludeDistributorBrand, "")
	}
	if r.includeLogos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_logos", r.includeLogos, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBrandsPostBrandsRequest struct {
	ctx context.Context
	ApiService *AccountBrandsAPIService
	accountId string
	brand *Brand
}

func (r ApiBrandsPostBrandsRequest) Brand(brand Brand) ApiBrandsPostBrandsRequest {
	r.brand = &brand
	return r
}

func (r ApiBrandsPostBrandsRequest) Execute() (*AccountBrands, *http.Response, error) {
	return r.ApiService.BrandsPostBrandsExecute(r)
}

/*
BrandsPostBrands Creates one or more brand profiles for an account.

This method creates one or more brand profile files for an account.

To specify logos for the brand,
use the
[AccountBrands: updateLogo](/docs/esign-rest-api/reference/accounts/accountbrands/updatelogo/)
method
after you create the brand.


Either or both of the following settings must be enabled for the account to use this method:

- `canSelfBrandSign`
- `canSelfBrandSend`

### Related topics

- [How to create a brand](/docs/esign-rest-api/how-to/create-brand/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiBrandsPostBrandsRequest
*/
func (a *AccountBrandsAPIService) BrandsPostBrands(ctx context.Context, accountId string) ApiBrandsPostBrandsRequest {
	return ApiBrandsPostBrandsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return AccountBrands
func (a *AccountBrandsAPIService) BrandsPostBrandsExecute(r ApiBrandsPostBrandsRequest) (*AccountBrands, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountBrands
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountBrandsAPIService.BrandsPostBrands")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/brands"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.brand
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
