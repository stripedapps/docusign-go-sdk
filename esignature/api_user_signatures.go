/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// UserSignaturesAPIService UserSignaturesAPI service
type UserSignaturesAPIService service

type ApiUserSignaturesDeleteUserSignatureRequest struct {
	ctx context.Context
	ApiService *UserSignaturesAPIService
	accountId string
	signatureId string
	userId string
}

func (r ApiUserSignaturesDeleteUserSignatureRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserSignaturesDeleteUserSignatureExecute(r)
}

/*
UserSignaturesDeleteUserSignature Removes removes signature information for the specified user.

Removes the signature information for the user.

The userId parameter specified in the endpoint must match the authenticated user's user ID and the user must be a member of the account.

The `signatureId` accepts a signature ID or a signature name. DocuSign recommends you use signature ID (`signatureId`), since some names contain characters that do not properly encode into a URL. If you use the user name, it is likely that the name includes spaces. In that case, URL encode the name before using it in the endpoint. 

For example encode "Bob Smith" as "Bob%20Smith".

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param signatureId The ID of the account stamp.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserSignaturesDeleteUserSignatureRequest
*/
func (a *UserSignaturesAPIService) UserSignaturesDeleteUserSignature(ctx context.Context, accountId string, signatureId string, userId string) ApiUserSignaturesDeleteUserSignatureRequest {
	return ApiUserSignaturesDeleteUserSignatureRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		signatureId: signatureId,
		userId: userId,
	}
}

// Execute executes the request
func (a *UserSignaturesAPIService) UserSignaturesDeleteUserSignatureExecute(r ApiUserSignaturesDeleteUserSignatureRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserSignaturesAPIService.UserSignaturesDeleteUserSignature")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/signatures/{signatureId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signatureId"+"}", url.PathEscape(parameterValueToString(r.signatureId, "signatureId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserSignaturesDeleteUserSignatureImageRequest struct {
	ctx context.Context
	ApiService *UserSignaturesAPIService
	accountId string
	imageType string
	signatureId string
	userId string
}

func (r ApiUserSignaturesDeleteUserSignatureImageRequest) Execute() (*UserSignature, *http.Response, error) {
	return r.ApiService.UserSignaturesDeleteUserSignatureImageExecute(r)
}

/*
UserSignaturesDeleteUserSignatureImage Deletes the user initials image or the  user signature image for the specified user.

Deletes the specified initials image or signature image for the specified user.

The function deletes one or the other of the image types, to delete both the initials image and signature image you must call the endpoint twice.

The userId parameter specified in the endpoint must match the authenticated user's user ID and the user must be a member of the account.

The `signatureId` parameter accepts a signature ID or a signature name. DocuSign recommends you use signature ID (`signatureId`), since some names contain characters that do not properly encode into a URL. If you use the user name, it is likely that the name includes spaces. In that case, URL encode the name before using it in the endpoint. 

For example encode "Bob Smith" as "Bob%20Smith".

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param imageType Specificies the type of image. Valid values:  - `stamp_image` - `signature_image` - `initials_image`
 @param signatureId The ID of the account stamp.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserSignaturesDeleteUserSignatureImageRequest
*/
func (a *UserSignaturesAPIService) UserSignaturesDeleteUserSignatureImage(ctx context.Context, accountId string, imageType string, signatureId string, userId string) ApiUserSignaturesDeleteUserSignatureImageRequest {
	return ApiUserSignaturesDeleteUserSignatureImageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		imageType: imageType,
		signatureId: signatureId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserSignature
func (a *UserSignaturesAPIService) UserSignaturesDeleteUserSignatureImageExecute(r ApiUserSignaturesDeleteUserSignatureImageRequest) (*UserSignature, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserSignature
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserSignaturesAPIService.UserSignaturesDeleteUserSignatureImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/signatures/{signatureId}/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signatureId"+"}", url.PathEscape(parameterValueToString(r.signatureId, "signatureId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSignaturesGetUserSignatureRequest struct {
	ctx context.Context
	ApiService *UserSignaturesAPIService
	accountId string
	signatureId string
	userId string
}

func (r ApiUserSignaturesGetUserSignatureRequest) Execute() (*UserSignature, *http.Response, error) {
	return r.ApiService.UserSignaturesGetUserSignatureExecute(r)
}

/*
UserSignaturesGetUserSignature Gets the user signature information for the specified user.

Retrieves the structure of a single signature with a known signature name.

The userId specified in the endpoint must match the authenticated user's user ID and the user must be a member of the account.

The `signatureId` parameter accepts a signature ID or a signature name. DocuSign recommends you use signature ID (`signatureId`), since some names contain characters that do not properly encode into a URL. If you use the user name, it is likely that the name includes spaces. In that case, URL encode the name before using it in the endpoint. 

For example encode "Bob Smith" as "Bob%20Smith".

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param signatureId The ID of the account stamp.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserSignaturesGetUserSignatureRequest
*/
func (a *UserSignaturesAPIService) UserSignaturesGetUserSignature(ctx context.Context, accountId string, signatureId string, userId string) ApiUserSignaturesGetUserSignatureRequest {
	return ApiUserSignaturesGetUserSignatureRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		signatureId: signatureId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserSignature
func (a *UserSignaturesAPIService) UserSignaturesGetUserSignatureExecute(r ApiUserSignaturesGetUserSignatureRequest) (*UserSignature, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserSignature
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserSignaturesAPIService.UserSignaturesGetUserSignature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/signatures/{signatureId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signatureId"+"}", url.PathEscape(parameterValueToString(r.signatureId, "signatureId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSignaturesGetUserSignatureImageRequest struct {
	ctx context.Context
	ApiService *UserSignaturesAPIService
	accountId string
	imageType string
	signatureId string
	userId string
	includeChrome *string
}

// When **true,** the chrome (or frame containing the added line and identifier) is included with the signature image.
func (r ApiUserSignaturesGetUserSignatureImageRequest) IncludeChrome(includeChrome string) ApiUserSignaturesGetUserSignatureImageRequest {
	r.includeChrome = &includeChrome
	return r
}

func (r ApiUserSignaturesGetUserSignatureImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.UserSignaturesGetUserSignatureImageExecute(r)
}

/*
UserSignaturesGetUserSignatureImage Retrieves the user initials image or the  user signature image for the specified user.

Retrieves the specified initials image or signature image for the specified user. The image is returned in the same format in which it was uploaded. In the request you can specify if the chrome (the added line and identifier around the initial image) is returned with the image.

The userId property specified in the endpoint must match the authenticated user's user ID and the user must be a member of the account.

The `signatureId` parameter accepts a signature ID or a signature name. DocuSign recommends you use signature ID (`signatureId`), since some names contain characters that do not properly encode into a URL. If you use the user name, it is likely that the name includes spaces. In that case, URL encode the name before using it in the endpoint.

For example encode "Bob Smith" as "Bob%20Smith".

**Note:** Older envelopes might only have chromed images. If getting the non-chromed image fails, try getting the chromed image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param imageType Specificies the type of image. Valid values:  - `stamp_image` - `signature_image` - `initials_image`
 @param signatureId The ID of the account stamp.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserSignaturesGetUserSignatureImageRequest
*/
func (a *UserSignaturesAPIService) UserSignaturesGetUserSignatureImage(ctx context.Context, accountId string, imageType string, signatureId string, userId string) ApiUserSignaturesGetUserSignatureImageRequest {
	return ApiUserSignaturesGetUserSignatureImageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		imageType: imageType,
		signatureId: signatureId,
		userId: userId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *UserSignaturesAPIService) UserSignaturesGetUserSignatureImageExecute(r ApiUserSignaturesGetUserSignatureImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserSignaturesAPIService.UserSignaturesGetUserSignatureImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/signatures/{signatureId}/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signatureId"+"}", url.PathEscape(parameterValueToString(r.signatureId, "signatureId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeChrome != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_chrome", r.includeChrome, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/gif"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSignaturesGetUserSignaturesRequest struct {
	ctx context.Context
	ApiService *UserSignaturesAPIService
	accountId string
	userId string
	stampType *string
}

// The type of stamps to return. Valid values are:  - &#x60;signature&#x60;: Returns information about signature images only. This is the default value. - &#x60;stamp&#x60;: Returns information about eHanko and custom stamps only. - null
func (r ApiUserSignaturesGetUserSignaturesRequest) StampType(stampType string) ApiUserSignaturesGetUserSignaturesRequest {
	r.stampType = &stampType
	return r
}

func (r ApiUserSignaturesGetUserSignaturesRequest) Execute() (*UserSignaturesInformation, *http.Response, error) {
	return r.ApiService.UserSignaturesGetUserSignaturesExecute(r)
}

/*
UserSignaturesGetUserSignatures Retrieves a list of signature definitions for a user.

This method retrieves the signature definitions for the user that you specify.

The `userId` parameter specified in the endpoint must match the authenticated user's user ID, and the user must be a member of the account.

The `signatureId` parameter accepts a signature ID or a signature name. DocuSign recommends you use signature ID (`signatureId`), since some names contain characters that do not properly encode into a URL. If you use the user name, it is likely that the name includes spaces. In that case, URL encode the name before using it in the endpoint. 

For example, encode "Bob Smith" as "Bob%20Smith".

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserSignaturesGetUserSignaturesRequest
*/
func (a *UserSignaturesAPIService) UserSignaturesGetUserSignatures(ctx context.Context, accountId string, userId string) ApiUserSignaturesGetUserSignaturesRequest {
	return ApiUserSignaturesGetUserSignaturesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserSignaturesInformation
func (a *UserSignaturesAPIService) UserSignaturesGetUserSignaturesExecute(r ApiUserSignaturesGetUserSignaturesRequest) (*UserSignaturesInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserSignaturesInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserSignaturesAPIService.UserSignaturesGetUserSignatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/signatures"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.stampType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stamp_type", r.stampType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSignaturesPostUserSignaturesRequest struct {
	ctx context.Context
	ApiService *UserSignaturesAPIService
	accountId string
	userId string
	userSignaturesInformation *UserSignaturesInformation
}

func (r ApiUserSignaturesPostUserSignaturesRequest) UserSignaturesInformation(userSignaturesInformation UserSignaturesInformation) ApiUserSignaturesPostUserSignaturesRequest {
	r.userSignaturesInformation = &userSignaturesInformation
	return r
}

func (r ApiUserSignaturesPostUserSignaturesRequest) Execute() (*UserSignaturesInformation, *http.Response, error) {
	return r.ApiService.UserSignaturesPostUserSignaturesExecute(r)
}

/*
UserSignaturesPostUserSignatures Adds user Signature and initials images to a Signature.

Adds a user signature image and/or user initials image to the specified user. 

The userId property specified in the endpoint must match the authenticated user's `userId` and the user must be a member of the account.

The rules and processes associated with this are:

* If `Content-Type` is set to `application/json`, then the default behavior for creating a default signature image, based on the name and a DocuSign font, is used.
* If `Content-Type` is set to `multipart/form-data`, then the request must contain a first part with the user signature information, followed by parts that contain the images.

For each Image part, the Content-Disposition header has a "filename" value that is used to map to the `signatureName` and/or `signatureInitials` properties in the JSON to the image. 

For example: 
`Content-Disposition: file; filename="Ron Test20121127083900"`

If no matching image (by filename value) is found, then the image is not set. One, both, or neither of the signature and initials images can be set with this call.

The Content-Transfer-Encoding: base64 header, set in the header for the part containing the image, can be set to indicate that the images are formatted as base64 instead of as binary.

If successful, 200-OK is returned, and a JSON structure containing the signature information is provided, note that the signatureId can change with each API POST, PUT, or DELETE since the changes to the signature structure cause the current signature to be closed, and a new signature record to be created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserSignaturesPostUserSignaturesRequest
*/
func (a *UserSignaturesAPIService) UserSignaturesPostUserSignatures(ctx context.Context, accountId string, userId string) ApiUserSignaturesPostUserSignaturesRequest {
	return ApiUserSignaturesPostUserSignaturesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserSignaturesInformation
func (a *UserSignaturesAPIService) UserSignaturesPostUserSignaturesExecute(r ApiUserSignaturesPostUserSignaturesRequest) (*UserSignaturesInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserSignaturesInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserSignaturesAPIService.UserSignaturesPostUserSignatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/signatures"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userSignaturesInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSignaturesPutUserSignatureRequest struct {
	ctx context.Context
	ApiService *UserSignaturesAPIService
	accountId string
	userId string
	userSignaturesInformation *UserSignaturesInformation
}

func (r ApiUserSignaturesPutUserSignatureRequest) UserSignaturesInformation(userSignaturesInformation UserSignaturesInformation) ApiUserSignaturesPutUserSignatureRequest {
	r.userSignaturesInformation = &userSignaturesInformation
	return r
}

func (r ApiUserSignaturesPutUserSignatureRequest) Execute() (*UserSignaturesInformation, *http.Response, error) {
	return r.ApiService.UserSignaturesPutUserSignatureExecute(r)
}

/*
UserSignaturesPutUserSignature Adds/updates a user signature.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserSignaturesPutUserSignatureRequest
*/
func (a *UserSignaturesAPIService) UserSignaturesPutUserSignature(ctx context.Context, accountId string, userId string) ApiUserSignaturesPutUserSignatureRequest {
	return ApiUserSignaturesPutUserSignatureRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserSignaturesInformation
func (a *UserSignaturesAPIService) UserSignaturesPutUserSignatureExecute(r ApiUserSignaturesPutUserSignatureRequest) (*UserSignaturesInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserSignaturesInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserSignaturesAPIService.UserSignaturesPutUserSignature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/signatures"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userSignaturesInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSignaturesPutUserSignatureByIdRequest struct {
	ctx context.Context
	ApiService *UserSignaturesAPIService
	accountId string
	signatureId string
	userId string
	closeExistingSignature *string
	userSignatureDefinition *UserSignatureDefinition
}

// When **true,** closes the current signature.
func (r ApiUserSignaturesPutUserSignatureByIdRequest) CloseExistingSignature(closeExistingSignature string) ApiUserSignaturesPutUserSignatureByIdRequest {
	r.closeExistingSignature = &closeExistingSignature
	return r
}

func (r ApiUserSignaturesPutUserSignatureByIdRequest) UserSignatureDefinition(userSignatureDefinition UserSignatureDefinition) ApiUserSignaturesPutUserSignatureByIdRequest {
	r.userSignatureDefinition = &userSignatureDefinition
	return r
}

func (r ApiUserSignaturesPutUserSignatureByIdRequest) Execute() (*UserSignature, *http.Response, error) {
	return r.ApiService.UserSignaturesPutUserSignatureByIdExecute(r)
}

/*
UserSignaturesPutUserSignatureById Updates the user signature for a specified user.

Creates, or updates, the signature font and initials for the specified user. When creating a signature, you use this resource to create the signature name and then add the signature and initials images into the signature.

**Note:** This will also create a default signature for the user when one does not exist.

The userId property specified in the endpoint must match the authenticated user's user ID and the user must be a member of the account.

The `signatureId` parameter accepts a signature ID. DocuSign recommends you use signature ID (`signatureId`), since some names contain characters that do not properly encode into a URL. If you use the user name, it is likely that the name includes spaces. In that case, URL encode the name before using it in the endpoint.

For example encode "Bob Smith" as "Bob%20Smith".

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param signatureId The ID of the account stamp.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserSignaturesPutUserSignatureByIdRequest
*/
func (a *UserSignaturesAPIService) UserSignaturesPutUserSignatureById(ctx context.Context, accountId string, signatureId string, userId string) ApiUserSignaturesPutUserSignatureByIdRequest {
	return ApiUserSignaturesPutUserSignatureByIdRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		signatureId: signatureId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserSignature
func (a *UserSignaturesAPIService) UserSignaturesPutUserSignatureByIdExecute(r ApiUserSignaturesPutUserSignatureByIdRequest) (*UserSignature, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserSignature
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserSignaturesAPIService.UserSignaturesPutUserSignatureById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/signatures/{signatureId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signatureId"+"}", url.PathEscape(parameterValueToString(r.signatureId, "signatureId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.closeExistingSignature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "close_existing_signature", r.closeExistingSignature, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userSignatureDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSignaturesPutUserSignatureImageRequest struct {
	ctx context.Context
	ApiService *UserSignaturesAPIService
	accountId string
	imageType string
	signatureId string
	userId string
	transparentPng *string
}

func (r ApiUserSignaturesPutUserSignatureImageRequest) TransparentPng(transparentPng string) ApiUserSignaturesPutUserSignatureImageRequest {
	r.transparentPng = &transparentPng
	return r
}

func (r ApiUserSignaturesPutUserSignatureImageRequest) Execute() (*UserSignature, *http.Response, error) {
	return r.ApiService.UserSignaturesPutUserSignatureImageExecute(r)
}

/*
UserSignaturesPutUserSignatureImage Updates the user signature image or user initials image for the specified user.

Updates the user signature image or user initials image for the specified user. The supported image formats for this file are: gif, png, jpeg, and bmp. The file must be less than 200K.

The userId property specified in the endpoint must match the authenticated user's user ID and the user must be a member of the account.

The `signatureId` parameter accepts a signature ID or a signature name. DocuSign recommends you use signature ID (`signatureId`), since some names contain characters that do not properly encode into a URL. If you use the user name, it is likely that the name includes spaces. In that case, URL encode the name before using it in the endpoint. 

For example encode "Bob Smith" as "Bob%20Smith".


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param imageType Specificies the type of image. Valid values:  - `stamp_image` - `signature_image` - `initials_image`
 @param signatureId The ID of the account stamp.
 @param userId The ID of the user to access.  **Note:** Users can only access their own information. A user, even one with Admin rights, cannot access another user's settings.
 @return ApiUserSignaturesPutUserSignatureImageRequest
*/
func (a *UserSignaturesAPIService) UserSignaturesPutUserSignatureImage(ctx context.Context, accountId string, imageType string, signatureId string, userId string) ApiUserSignaturesPutUserSignatureImageRequest {
	return ApiUserSignaturesPutUserSignatureImageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		imageType: imageType,
		signatureId: signatureId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserSignature
func (a *UserSignaturesAPIService) UserSignaturesPutUserSignatureImageExecute(r ApiUserSignaturesPutUserSignatureImageRequest) (*UserSignature, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserSignature
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserSignaturesAPIService.UserSignaturesPutUserSignatureImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/signatures/{signatureId}/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signatureId"+"}", url.PathEscape(parameterValueToString(r.signatureId, "signatureId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transparentPng != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transparent_png", r.transparentPng, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
