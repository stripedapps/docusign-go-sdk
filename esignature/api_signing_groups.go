/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SigningGroupsAPIService SigningGroupsAPI service
type SigningGroupsAPIService service

type ApiSigningGroupsDeleteSigningGroupsRequest struct {
	ctx context.Context
	ApiService *SigningGroupsAPIService
	accountId string
	signingGroupInformation *SigningGroupInformation
}

func (r ApiSigningGroupsDeleteSigningGroupsRequest) SigningGroupInformation(signingGroupInformation SigningGroupInformation) ApiSigningGroupsDeleteSigningGroupsRequest {
	r.signingGroupInformation = &signingGroupInformation
	return r
}

func (r ApiSigningGroupsDeleteSigningGroupsRequest) Execute() (*SigningGroupInformation, *http.Response, error) {
	return r.ApiService.SigningGroupsDeleteSigningGroupsExecute(r)
}

/*
SigningGroupsDeleteSigningGroups Deletes one or more signing groups.

Deletes one or more signing groups in the specified account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiSigningGroupsDeleteSigningGroupsRequest
*/
func (a *SigningGroupsAPIService) SigningGroupsDeleteSigningGroups(ctx context.Context, accountId string) ApiSigningGroupsDeleteSigningGroupsRequest {
	return ApiSigningGroupsDeleteSigningGroupsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return SigningGroupInformation
func (a *SigningGroupsAPIService) SigningGroupsDeleteSigningGroupsExecute(r ApiSigningGroupsDeleteSigningGroupsRequest) (*SigningGroupInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SigningGroupInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SigningGroupsAPIService.SigningGroupsDeleteSigningGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/signing_groups"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signingGroupInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSigningGroupsGetSigningGroupRequest struct {
	ctx context.Context
	ApiService *SigningGroupsAPIService
	accountId string
	signingGroupId string
}

func (r ApiSigningGroupsGetSigningGroupRequest) Execute() (*SigningGroup, *http.Response, error) {
	return r.ApiService.SigningGroupsGetSigningGroupExecute(r)
}

/*
SigningGroupsGetSigningGroup Gets information about a signing group. 

Retrieves information, including group member information, for the specified signing group. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param signingGroupId The ID of the [signing group](https://support.docusign.com/s/document-item?bundleId=gav1643676262430&topicId=zgn1578456447934.html). 
 @return ApiSigningGroupsGetSigningGroupRequest
*/
func (a *SigningGroupsAPIService) SigningGroupsGetSigningGroup(ctx context.Context, accountId string, signingGroupId string) ApiSigningGroupsGetSigningGroupRequest {
	return ApiSigningGroupsGetSigningGroupRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		signingGroupId: signingGroupId,
	}
}

// Execute executes the request
//  @return SigningGroup
func (a *SigningGroupsAPIService) SigningGroupsGetSigningGroupExecute(r ApiSigningGroupsGetSigningGroupRequest) (*SigningGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SigningGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SigningGroupsAPIService.SigningGroupsGetSigningGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/signing_groups/{signingGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signingGroupId"+"}", url.PathEscape(parameterValueToString(r.signingGroupId, "signingGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSigningGroupsGetSigningGroupsRequest struct {
	ctx context.Context
	ApiService *SigningGroupsAPIService
	accountId string
	groupType *string
	includeUsers *string
}

// Filters by the type of signing group. Valid values: * &#x60;sharedSigningGroup&#x60; * &#x60;privateSigningGroup&#x60; * &#x60;systemSigningGroup&#x60;
func (r ApiSigningGroupsGetSigningGroupsRequest) GroupType(groupType string) ApiSigningGroupsGetSigningGroupsRequest {
	r.groupType = &groupType
	return r
}

// When **true,** the response includes the signing group members. 
func (r ApiSigningGroupsGetSigningGroupsRequest) IncludeUsers(includeUsers string) ApiSigningGroupsGetSigningGroupsRequest {
	r.includeUsers = &includeUsers
	return r
}

func (r ApiSigningGroupsGetSigningGroupsRequest) Execute() (*SigningGroupInformation, *http.Response, error) {
	return r.ApiService.SigningGroupsGetSigningGroupsExecute(r)
}

/*
SigningGroupsGetSigningGroups Gets a list of the Signing Groups in an account.

Retrieves a list of all signing groups in the specified account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiSigningGroupsGetSigningGroupsRequest
*/
func (a *SigningGroupsAPIService) SigningGroupsGetSigningGroups(ctx context.Context, accountId string) ApiSigningGroupsGetSigningGroupsRequest {
	return ApiSigningGroupsGetSigningGroupsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return SigningGroupInformation
func (a *SigningGroupsAPIService) SigningGroupsGetSigningGroupsExecute(r ApiSigningGroupsGetSigningGroupsRequest) (*SigningGroupInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SigningGroupInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SigningGroupsAPIService.SigningGroupsGetSigningGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/signing_groups"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.groupType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_type", r.groupType, "")
	}
	if r.includeUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_users", r.includeUsers, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSigningGroupsPostSigningGroupsRequest struct {
	ctx context.Context
	ApiService *SigningGroupsAPIService
	accountId string
	signingGroupInformation *SigningGroupInformation
}

func (r ApiSigningGroupsPostSigningGroupsRequest) SigningGroupInformation(signingGroupInformation SigningGroupInformation) ApiSigningGroupsPostSigningGroupsRequest {
	r.signingGroupInformation = &signingGroupInformation
	return r
}

func (r ApiSigningGroupsPostSigningGroupsRequest) Execute() (*SigningGroupInformation, *http.Response, error) {
	return r.ApiService.SigningGroupsPostSigningGroupsExecute(r)
}

/*
SigningGroupsPostSigningGroups Creates a signing group. 

Creates one or more signing groups. 

Multiple signing groups can be created in one call. Only users with account administrator privileges can create signing groups. 

An account can have a maximum of 50 signing groups. Each signing group can have a maximum of 50 group members.
 
Signing groups can be used by any account user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiSigningGroupsPostSigningGroupsRequest
*/
func (a *SigningGroupsAPIService) SigningGroupsPostSigningGroups(ctx context.Context, accountId string) ApiSigningGroupsPostSigningGroupsRequest {
	return ApiSigningGroupsPostSigningGroupsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return SigningGroupInformation
func (a *SigningGroupsAPIService) SigningGroupsPostSigningGroupsExecute(r ApiSigningGroupsPostSigningGroupsRequest) (*SigningGroupInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SigningGroupInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SigningGroupsAPIService.SigningGroupsPostSigningGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/signing_groups"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signingGroupInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSigningGroupsPutSigningGroupRequest struct {
	ctx context.Context
	ApiService *SigningGroupsAPIService
	accountId string
	signingGroupId string
	signingGroup *SigningGroup
}

func (r ApiSigningGroupsPutSigningGroupRequest) SigningGroup(signingGroup SigningGroup) ApiSigningGroupsPutSigningGroupRequest {
	r.signingGroup = &signingGroup
	return r
}

func (r ApiSigningGroupsPutSigningGroupRequest) Execute() (*SigningGroup, *http.Response, error) {
	return r.ApiService.SigningGroupsPutSigningGroupExecute(r)
}

/*
SigningGroupsPutSigningGroup Updates a signing group. 

Updates signing group name and member information. You can also add new members to the signing group. A signing group can have a maximum of 50 members. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param signingGroupId The ID of the [signing group](https://support.docusign.com/s/document-item?bundleId=gav1643676262430&topicId=zgn1578456447934.html). 
 @return ApiSigningGroupsPutSigningGroupRequest
*/
func (a *SigningGroupsAPIService) SigningGroupsPutSigningGroup(ctx context.Context, accountId string, signingGroupId string) ApiSigningGroupsPutSigningGroupRequest {
	return ApiSigningGroupsPutSigningGroupRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		signingGroupId: signingGroupId,
	}
}

// Execute executes the request
//  @return SigningGroup
func (a *SigningGroupsAPIService) SigningGroupsPutSigningGroupExecute(r ApiSigningGroupsPutSigningGroupRequest) (*SigningGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SigningGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SigningGroupsAPIService.SigningGroupsPutSigningGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/signing_groups/{signingGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signingGroupId"+"}", url.PathEscape(parameterValueToString(r.signingGroupId, "signingGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signingGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSigningGroupsPutSigningGroupsRequest struct {
	ctx context.Context
	ApiService *SigningGroupsAPIService
	accountId string
	signingGroupInformation *SigningGroupInformation
}

func (r ApiSigningGroupsPutSigningGroupsRequest) SigningGroupInformation(signingGroupInformation SigningGroupInformation) ApiSigningGroupsPutSigningGroupsRequest {
	r.signingGroupInformation = &signingGroupInformation
	return r
}

func (r ApiSigningGroupsPutSigningGroupsRequest) Execute() (*SigningGroupInformation, *http.Response, error) {
	return r.ApiService.SigningGroupsPutSigningGroupsExecute(r)
}

/*
SigningGroupsPutSigningGroups Updates signing group names.

Updates the name of one or more existing signing groups. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiSigningGroupsPutSigningGroupsRequest
*/
func (a *SigningGroupsAPIService) SigningGroupsPutSigningGroups(ctx context.Context, accountId string) ApiSigningGroupsPutSigningGroupsRequest {
	return ApiSigningGroupsPutSigningGroupsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return SigningGroupInformation
func (a *SigningGroupsAPIService) SigningGroupsPutSigningGroupsExecute(r ApiSigningGroupsPutSigningGroupsRequest) (*SigningGroupInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SigningGroupInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SigningGroupsAPIService.SigningGroupsPutSigningGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/signing_groups"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signingGroupInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
