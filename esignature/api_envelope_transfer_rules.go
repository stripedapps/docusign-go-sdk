/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// EnvelopeTransferRulesAPIService EnvelopeTransferRulesAPI service
type EnvelopeTransferRulesAPIService service

type ApiEnvelopeTransferRulesDeleteEnvelopeTransferRulesRequest struct {
	ctx context.Context
	ApiService *EnvelopeTransferRulesAPIService
	accountId string
	envelopeTransferRuleId string
}

func (r ApiEnvelopeTransferRulesDeleteEnvelopeTransferRulesRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvelopeTransferRulesDeleteEnvelopeTransferRulesExecute(r)
}

/*
EnvelopeTransferRulesDeleteEnvelopeTransferRules Deletes an envelope transfer rule.

This method deletes an envelope transfer rule.

**Note:** Only Administrators can delete envelope transfer rules. In addition, to use envelope transfer rules, the **Transfer Custody** feature must be enabled for your account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeTransferRuleId The ID of the envelope transfer rule. The system generates this ID when the rule is first created.
 @return ApiEnvelopeTransferRulesDeleteEnvelopeTransferRulesRequest
*/
func (a *EnvelopeTransferRulesAPIService) EnvelopeTransferRulesDeleteEnvelopeTransferRules(ctx context.Context, accountId string, envelopeTransferRuleId string) ApiEnvelopeTransferRulesDeleteEnvelopeTransferRulesRequest {
	return ApiEnvelopeTransferRulesDeleteEnvelopeTransferRulesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeTransferRuleId: envelopeTransferRuleId,
	}
}

// Execute executes the request
func (a *EnvelopeTransferRulesAPIService) EnvelopeTransferRulesDeleteEnvelopeTransferRulesExecute(r ApiEnvelopeTransferRulesDeleteEnvelopeTransferRulesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeTransferRulesAPIService.EnvelopeTransferRulesDeleteEnvelopeTransferRules")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/transfer_rules/{envelopeTransferRuleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeTransferRuleId"+"}", url.PathEscape(parameterValueToString(r.envelopeTransferRuleId, "envelopeTransferRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvelopeTransferRulesGetEnvelopeTransferRulesRequest struct {
	ctx context.Context
	ApiService *EnvelopeTransferRulesAPIService
	accountId string
	count *string
	startPosition *string
}

// The maximum number of results to return.  Use &#x60;start_position&#x60; to specify the number of results to skip. 
func (r ApiEnvelopeTransferRulesGetEnvelopeTransferRulesRequest) Count(count string) ApiEnvelopeTransferRulesGetEnvelopeTransferRulesRequest {
	r.count = &count
	return r
}

// The zero-based index of the result from which to start returning results.  Use with &#x60;count&#x60; to limit the number of results.  The default value is &#x60;0&#x60;. 
func (r ApiEnvelopeTransferRulesGetEnvelopeTransferRulesRequest) StartPosition(startPosition string) ApiEnvelopeTransferRulesGetEnvelopeTransferRulesRequest {
	r.startPosition = &startPosition
	return r
}

func (r ApiEnvelopeTransferRulesGetEnvelopeTransferRulesRequest) Execute() (*EnvelopeTransferRuleInformation, *http.Response, error) {
	return r.ApiService.EnvelopeTransferRulesGetEnvelopeTransferRulesExecute(r)
}

/*
EnvelopeTransferRulesGetEnvelopeTransferRules Gets envelope transfer rules.

This method retrieves a list of envelope transfer rules associated with an account.

**Note:** Only Administrators can create and use envelope transfer rules. In addition, to use envelope transfer rules, the **Transfer Custody** feature must be enabled for your account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiEnvelopeTransferRulesGetEnvelopeTransferRulesRequest
*/
func (a *EnvelopeTransferRulesAPIService) EnvelopeTransferRulesGetEnvelopeTransferRules(ctx context.Context, accountId string) ApiEnvelopeTransferRulesGetEnvelopeTransferRulesRequest {
	return ApiEnvelopeTransferRulesGetEnvelopeTransferRulesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return EnvelopeTransferRuleInformation
func (a *EnvelopeTransferRulesAPIService) EnvelopeTransferRulesGetEnvelopeTransferRulesExecute(r ApiEnvelopeTransferRulesGetEnvelopeTransferRulesRequest) (*EnvelopeTransferRuleInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeTransferRuleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeTransferRulesAPIService.EnvelopeTransferRulesGetEnvelopeTransferRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/transfer_rules"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopeTransferRulesPostEnvelopeTransferRulesRequest struct {
	ctx context.Context
	ApiService *EnvelopeTransferRulesAPIService
	accountId string
	envelopeTransferRuleRequest *EnvelopeTransferRuleRequest
}

func (r ApiEnvelopeTransferRulesPostEnvelopeTransferRulesRequest) EnvelopeTransferRuleRequest(envelopeTransferRuleRequest EnvelopeTransferRuleRequest) ApiEnvelopeTransferRulesPostEnvelopeTransferRulesRequest {
	r.envelopeTransferRuleRequest = &envelopeTransferRuleRequest
	return r
}

func (r ApiEnvelopeTransferRulesPostEnvelopeTransferRulesRequest) Execute() (*EnvelopeTransferRuleInformation, *http.Response, error) {
	return r.ApiService.EnvelopeTransferRulesPostEnvelopeTransferRulesExecute(r)
}

/*
EnvelopeTransferRulesPostEnvelopeTransferRules Creates an envelope transfer rule.

This method creates an envelope transfer rule.

When you create an envelope transfer rule, you specify the following properties: 

- `eventType`
- `fromGroups`
- `toUser`
- `toFolder`
- `carbonCopyOriginalOwner`
- `enabled`

**Note:** Only Administrators can create envelope transfer rules. In addition, to use envelope transfer rules, the **Transfer Custody** feature must be enabled for your account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiEnvelopeTransferRulesPostEnvelopeTransferRulesRequest
*/
func (a *EnvelopeTransferRulesAPIService) EnvelopeTransferRulesPostEnvelopeTransferRules(ctx context.Context, accountId string) ApiEnvelopeTransferRulesPostEnvelopeTransferRulesRequest {
	return ApiEnvelopeTransferRulesPostEnvelopeTransferRulesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return EnvelopeTransferRuleInformation
func (a *EnvelopeTransferRulesAPIService) EnvelopeTransferRulesPostEnvelopeTransferRulesExecute(r ApiEnvelopeTransferRulesPostEnvelopeTransferRulesRequest) (*EnvelopeTransferRuleInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeTransferRuleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeTransferRulesAPIService.EnvelopeTransferRulesPostEnvelopeTransferRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/transfer_rules"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeTransferRuleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopeTransferRulesPutEnvelopeTransferRuleRequest struct {
	ctx context.Context
	ApiService *EnvelopeTransferRulesAPIService
	accountId string
	envelopeTransferRuleId string
	envelopeTransferRule *EnvelopeTransferRule
}

func (r ApiEnvelopeTransferRulesPutEnvelopeTransferRuleRequest) EnvelopeTransferRule(envelopeTransferRule EnvelopeTransferRule) ApiEnvelopeTransferRulesPutEnvelopeTransferRuleRequest {
	r.envelopeTransferRule = &envelopeTransferRule
	return r
}

func (r ApiEnvelopeTransferRulesPutEnvelopeTransferRuleRequest) Execute() (*EnvelopeTransferRule, *http.Response, error) {
	return r.ApiService.EnvelopeTransferRulesPutEnvelopeTransferRuleExecute(r)
}

/*
EnvelopeTransferRulesPutEnvelopeTransferRule Changes the status of an envelope transfer rule.

This method changes the status of an envelope transfer rule. You use this method to change whether or not the rule is enabled.

You must include the `envelopeTransferRuleId` both as a query parameter, and in the request body.

**Note:** You cannot change any other information about the envelope transfer rule. Only Administrators can update an envelope transfer rule. In addition, to use envelope transfer rules, the **Transfer Custody** feature must be enabled for your account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeTransferRuleId The ID of the envelope transfer rule. The system generates this ID when the rule is first created.
 @return ApiEnvelopeTransferRulesPutEnvelopeTransferRuleRequest
*/
func (a *EnvelopeTransferRulesAPIService) EnvelopeTransferRulesPutEnvelopeTransferRule(ctx context.Context, accountId string, envelopeTransferRuleId string) ApiEnvelopeTransferRulesPutEnvelopeTransferRuleRequest {
	return ApiEnvelopeTransferRulesPutEnvelopeTransferRuleRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeTransferRuleId: envelopeTransferRuleId,
	}
}

// Execute executes the request
//  @return EnvelopeTransferRule
func (a *EnvelopeTransferRulesAPIService) EnvelopeTransferRulesPutEnvelopeTransferRuleExecute(r ApiEnvelopeTransferRulesPutEnvelopeTransferRuleRequest) (*EnvelopeTransferRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeTransferRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeTransferRulesAPIService.EnvelopeTransferRulesPutEnvelopeTransferRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/transfer_rules/{envelopeTransferRuleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeTransferRuleId"+"}", url.PathEscape(parameterValueToString(r.envelopeTransferRuleId, "envelopeTransferRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeTransferRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvelopeTransferRulesPutEnvelopeTransferRulesRequest struct {
	ctx context.Context
	ApiService *EnvelopeTransferRulesAPIService
	accountId string
	envelopeTransferRuleInformation *EnvelopeTransferRuleInformation
}

func (r ApiEnvelopeTransferRulesPutEnvelopeTransferRulesRequest) EnvelopeTransferRuleInformation(envelopeTransferRuleInformation EnvelopeTransferRuleInformation) ApiEnvelopeTransferRulesPutEnvelopeTransferRulesRequest {
	r.envelopeTransferRuleInformation = &envelopeTransferRuleInformation
	return r
}

func (r ApiEnvelopeTransferRulesPutEnvelopeTransferRulesRequest) Execute() (*EnvelopeTransferRuleInformation, *http.Response, error) {
	return r.ApiService.EnvelopeTransferRulesPutEnvelopeTransferRulesExecute(r)
}

/*
EnvelopeTransferRulesPutEnvelopeTransferRules Changes the status of multiple envelope transfer rules.

This method changes the status for one or more envelope transfer rules based on the `envelopeTransferRuleId`s in the request body. You use this method to change whether or not the rules are enabled.

**Note:** You cannot change any other information about the envelope transfer rule. Only Administrators can update envelope transfer rules. In addition, to use envelope transfer rules, the **Transfer Custody** feature must be enabled for your account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiEnvelopeTransferRulesPutEnvelopeTransferRulesRequest
*/
func (a *EnvelopeTransferRulesAPIService) EnvelopeTransferRulesPutEnvelopeTransferRules(ctx context.Context, accountId string) ApiEnvelopeTransferRulesPutEnvelopeTransferRulesRequest {
	return ApiEnvelopeTransferRulesPutEnvelopeTransferRulesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return EnvelopeTransferRuleInformation
func (a *EnvelopeTransferRulesAPIService) EnvelopeTransferRulesPutEnvelopeTransferRulesExecute(r ApiEnvelopeTransferRulesPutEnvelopeTransferRulesRequest) (*EnvelopeTransferRuleInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeTransferRuleInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeTransferRulesAPIService.EnvelopeTransferRulesPutEnvelopeTransferRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/transfer_rules"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeTransferRuleInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
