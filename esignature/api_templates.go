/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// TemplatesAPIService TemplatesAPI service
type TemplatesAPIService service

type ApiNotificationGetTemplatesTemplateIdNotificationRequest struct {
	ctx context.Context
	ApiService *TemplatesAPIService
	accountId string
	templateId string
}

func (r ApiNotificationGetTemplatesTemplateIdNotificationRequest) Execute() (*Notification, *http.Response, error) {
	return r.ApiService.NotificationGetTemplatesTemplateIdNotificationExecute(r)
}

/*
NotificationGetTemplatesTemplateIdNotification Gets template notification information.

Retrieves the envelope notification, reminders and expirations, information for an existing template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @return ApiNotificationGetTemplatesTemplateIdNotificationRequest
*/
func (a *TemplatesAPIService) NotificationGetTemplatesTemplateIdNotification(ctx context.Context, accountId string, templateId string) ApiNotificationGetTemplatesTemplateIdNotificationRequest {
	return ApiNotificationGetTemplatesTemplateIdNotificationRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return Notification
func (a *TemplatesAPIService) NotificationGetTemplatesTemplateIdNotificationExecute(r ApiNotificationGetTemplatesTemplateIdNotificationRequest) (*Notification, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Notification
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesAPIService.NotificationGetTemplatesTemplateIdNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/notification"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNotificationPutTemplatesTemplateIdNotificationRequest struct {
	ctx context.Context
	ApiService *TemplatesAPIService
	accountId string
	templateId string
	templateNotificationRequest *TemplateNotificationRequest
}

func (r ApiNotificationPutTemplatesTemplateIdNotificationRequest) TemplateNotificationRequest(templateNotificationRequest TemplateNotificationRequest) ApiNotificationPutTemplatesTemplateIdNotificationRequest {
	r.templateNotificationRequest = &templateNotificationRequest
	return r
}

func (r ApiNotificationPutTemplatesTemplateIdNotificationRequest) Execute() (*Notification, *http.Response, error) {
	return r.ApiService.NotificationPutTemplatesTemplateIdNotificationExecute(r)
}

/*
NotificationPutTemplatesTemplateIdNotification Updates the notification  structure for an existing template.

Updates the notification structure for an existing template. Use this endpoint to set reminder and expiration notifications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @return ApiNotificationPutTemplatesTemplateIdNotificationRequest
*/
func (a *TemplatesAPIService) NotificationPutTemplatesTemplateIdNotification(ctx context.Context, accountId string, templateId string) ApiNotificationPutTemplatesTemplateIdNotificationRequest {
	return ApiNotificationPutTemplatesTemplateIdNotificationRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return Notification
func (a *TemplatesAPIService) NotificationPutTemplatesTemplateIdNotificationExecute(r ApiNotificationPutTemplatesTemplateIdNotificationRequest) (*Notification, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Notification
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesAPIService.NotificationPutTemplatesTemplateIdNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/notification"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.templateNotificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPagesDeleteTemplatePageRequest struct {
	ctx context.Context
	ApiService *TemplatesAPIService
	accountId string
	documentId string
	pageNumber string
	templateId string
	pageRequest *PageRequest
}

func (r ApiPagesDeleteTemplatePageRequest) PageRequest(pageRequest PageRequest) ApiPagesDeleteTemplatePageRequest {
	r.pageRequest = &pageRequest
	return r
}

func (r ApiPagesDeleteTemplatePageRequest) Execute() (*http.Response, error) {
	return r.ApiService.PagesDeleteTemplatePageExecute(r)
}

/*
PagesDeleteTemplatePage Deletes a page from a document in an template.

Deletes a page from a document in a template based on the page number.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param documentId The unique ID of the document within the envelope.  Unlike other IDs in the eSignature API, you specify the `documentId` yourself. Typically the first document has the ID `1`, the second document `2`, and so on, but you can use any numbering scheme that fits within a 32-bit signed integer (1 through 2147483647).   Tab objects have a `documentId` property that specifies the document on which to place the tab. 
 @param pageNumber The page number being accessed.
 @param templateId The ID of the template.
 @return ApiPagesDeleteTemplatePageRequest
*/
func (a *TemplatesAPIService) PagesDeleteTemplatePage(ctx context.Context, accountId string, documentId string, pageNumber string, templateId string) ApiPagesDeleteTemplatePageRequest {
	return ApiPagesDeleteTemplatePageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		documentId: documentId,
		pageNumber: pageNumber,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *TemplatesAPIService) PagesDeleteTemplatePageExecute(r ApiPagesDeleteTemplatePageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesAPIService.PagesDeleteTemplatePage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/documents/{documentId}/pages/{pageNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", url.PathEscape(parameterValueToString(r.pageNumber, "pageNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPagesGetTemplatePageImageRequest struct {
	ctx context.Context
	ApiService *TemplatesAPIService
	accountId string
	documentId string
	pageNumber string
	templateId string
	dpi *string
	maxHeight *string
	maxWidth *string
	showChanges *string
}

// The number of dots per inch (DPI) for the resulting images. Valid values are 1-310 DPI. The default value is 94.
func (r ApiPagesGetTemplatePageImageRequest) Dpi(dpi string) ApiPagesGetTemplatePageImageRequest {
	r.dpi = &dpi
	return r
}

// Sets the maximum height of the returned images in pixels.
func (r ApiPagesGetTemplatePageImageRequest) MaxHeight(maxHeight string) ApiPagesGetTemplatePageImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Sets the maximum width of the returned images in pixels.
func (r ApiPagesGetTemplatePageImageRequest) MaxWidth(maxWidth string) ApiPagesGetTemplatePageImageRequest {
	r.maxWidth = &maxWidth
	return r
}

func (r ApiPagesGetTemplatePageImageRequest) ShowChanges(showChanges string) ApiPagesGetTemplatePageImageRequest {
	r.showChanges = &showChanges
	return r
}

func (r ApiPagesGetTemplatePageImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.PagesGetTemplatePageImageExecute(r)
}

/*
PagesGetTemplatePageImage Gets a page image from a template for display.

Retrieves a page image for display from the specified template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param documentId The unique ID of the document within the envelope.  Unlike other IDs in the eSignature API, you specify the `documentId` yourself. Typically the first document has the ID `1`, the second document `2`, and so on, but you can use any numbering scheme that fits within a 32-bit signed integer (1 through 2147483647).   Tab objects have a `documentId` property that specifies the document on which to place the tab. 
 @param pageNumber The page number being accessed.
 @param templateId The ID of the template.
 @return ApiPagesGetTemplatePageImageRequest
*/
func (a *TemplatesAPIService) PagesGetTemplatePageImage(ctx context.Context, accountId string, documentId string, pageNumber string, templateId string) ApiPagesGetTemplatePageImageRequest {
	return ApiPagesGetTemplatePageImageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		documentId: documentId,
		pageNumber: pageNumber,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TemplatesAPIService) PagesGetTemplatePageImageExecute(r ApiPagesGetTemplatePageImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesAPIService.PagesGetTemplatePageImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/documents/{documentId}/pages/{pageNumber}/page_image"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", url.PathEscape(parameterValueToString(r.pageNumber, "pageNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dpi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dpi", r.dpi, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_height", r.maxHeight, "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_width", r.maxWidth, "")
	}
	if r.showChanges != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_changes", r.showChanges, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/png"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPagesGetTemplatePageImagesRequest struct {
	ctx context.Context
	ApiService *TemplatesAPIService
	accountId string
	documentId string
	templateId string
	count *string
	dpi *string
	maxHeight *string
	maxWidth *string
	nocache *string
	showChanges *string
	startPosition *string
}

// The maximum number of results to return.
func (r ApiPagesGetTemplatePageImagesRequest) Count(count string) ApiPagesGetTemplatePageImagesRequest {
	r.count = &count
	return r
}

// The number of dots per inch (DPI) for the resulting images. Valid values are 1-310 DPI. The default value is 94.
func (r ApiPagesGetTemplatePageImagesRequest) Dpi(dpi string) ApiPagesGetTemplatePageImagesRequest {
	r.dpi = &dpi
	return r
}

// Sets the maximum height of the returned images in pixels.
func (r ApiPagesGetTemplatePageImagesRequest) MaxHeight(maxHeight string) ApiPagesGetTemplatePageImagesRequest {
	r.maxHeight = &maxHeight
	return r
}

// Sets the maximum width of the returned images in pixels.
func (r ApiPagesGetTemplatePageImagesRequest) MaxWidth(maxWidth string) ApiPagesGetTemplatePageImagesRequest {
	r.maxWidth = &maxWidth
	return r
}

// When **true,** using cache is disabled and image information is retrieved from a database. **True** is the default value. 
func (r ApiPagesGetTemplatePageImagesRequest) Nocache(nocache string) ApiPagesGetTemplatePageImagesRequest {
	r.nocache = &nocache
	return r
}

// When **true,** changes display in the user interface.
func (r ApiPagesGetTemplatePageImagesRequest) ShowChanges(showChanges string) ApiPagesGetTemplatePageImagesRequest {
	r.showChanges = &showChanges
	return r
}

// The position within the total result set from which to start returning values. The value **thumbnail** may be used to return the page image.
func (r ApiPagesGetTemplatePageImagesRequest) StartPosition(startPosition string) ApiPagesGetTemplatePageImagesRequest {
	r.startPosition = &startPosition
	return r
}

func (r ApiPagesGetTemplatePageImagesRequest) Execute() (*PageImages, *http.Response, error) {
	return r.ApiService.PagesGetTemplatePageImagesExecute(r)
}

/*
PagesGetTemplatePageImages Returns document page images based on input.

Returns images of the pages in a template document for display based on the parameters that you specify.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId (Required) The external account number (int) or account ID GUID.
 @param documentId (Required) The ID of the document.
 @param templateId (Required) The ID of the template.
 @return ApiPagesGetTemplatePageImagesRequest
*/
func (a *TemplatesAPIService) PagesGetTemplatePageImages(ctx context.Context, accountId string, documentId string, templateId string) ApiPagesGetTemplatePageImagesRequest {
	return ApiPagesGetTemplatePageImagesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		documentId: documentId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return PageImages
func (a *TemplatesAPIService) PagesGetTemplatePageImagesExecute(r ApiPagesGetTemplatePageImagesRequest) (*PageImages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageImages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesAPIService.PagesGetTemplatePageImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/documents/{documentId}/pages"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.dpi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dpi", r.dpi, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_height", r.maxHeight, "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_width", r.maxWidth, "")
	}
	if r.nocache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nocache", r.nocache, "")
	}
	if r.showChanges != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_changes", r.showChanges, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPagesPutTemplatePageImageRequest struct {
	ctx context.Context
	ApiService *TemplatesAPIService
	accountId string
	documentId string
	pageNumber string
	templateId string
	pageRequest *PageRequest
}

func (r ApiPagesPutTemplatePageImageRequest) PageRequest(pageRequest PageRequest) ApiPagesPutTemplatePageImageRequest {
	r.pageRequest = &pageRequest
	return r
}

func (r ApiPagesPutTemplatePageImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.PagesPutTemplatePageImageExecute(r)
}

/*
PagesPutTemplatePageImage Rotates page image from a template for display.

Rotates page image from a template for display. The page image can be rotated to the left or right.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param documentId The unique ID of the document within the envelope.  Unlike other IDs in the eSignature API, you specify the `documentId` yourself. Typically the first document has the ID `1`, the second document `2`, and so on, but you can use any numbering scheme that fits within a 32-bit signed integer (1 through 2147483647).   Tab objects have a `documentId` property that specifies the document on which to place the tab. 
 @param pageNumber The page number being accessed.
 @param templateId The ID of the template.
 @return ApiPagesPutTemplatePageImageRequest
*/
func (a *TemplatesAPIService) PagesPutTemplatePageImage(ctx context.Context, accountId string, documentId string, pageNumber string, templateId string) ApiPagesPutTemplatePageImageRequest {
	return ApiPagesPutTemplatePageImageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		documentId: documentId,
		pageNumber: pageNumber,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *TemplatesAPIService) PagesPutTemplatePageImageExecute(r ApiPagesPutTemplatePageImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesAPIService.PagesPutTemplatePageImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/documents/{documentId}/pages/{pageNumber}/page_image"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageNumber"+"}", url.PathEscape(parameterValueToString(r.pageNumber, "pageNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTemplatesDeleteTemplatePartRequest struct {
	ctx context.Context
	ApiService *TemplatesAPIService
	accountId string
	templateId string
	templatePart string
	groupInformation *GroupInformation
}

func (r ApiTemplatesDeleteTemplatePartRequest) GroupInformation(groupInformation GroupInformation) ApiTemplatesDeleteTemplatePartRequest {
	r.groupInformation = &groupInformation
	return r
}

func (r ApiTemplatesDeleteTemplatePartRequest) Execute() (*GroupInformation, *http.Response, error) {
	return r.ApiService.TemplatesDeleteTemplatePartExecute(r)
}

/*
TemplatesDeleteTemplatePart Removes a member group's sharing permissions for a template.

Removes a member group's sharing permissions for a specified template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @param templatePart Currently, the only defined part is **groups.**
 @return ApiTemplatesDeleteTemplatePartRequest
*/
func (a *TemplatesAPIService) TemplatesDeleteTemplatePart(ctx context.Context, accountId string, templateId string, templatePart string) ApiTemplatesDeleteTemplatePartRequest {
	return ApiTemplatesDeleteTemplatePartRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
		templatePart: templatePart,
	}
}

// Execute executes the request
//  @return GroupInformation
func (a *TemplatesAPIService) TemplatesDeleteTemplatePartExecute(r ApiTemplatesDeleteTemplatePartRequest) (*GroupInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesAPIService.TemplatesDeleteTemplatePart")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/{templatePart}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templatePart"+"}", url.PathEscape(parameterValueToString(r.templatePart, "templatePart")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTemplatesGetTemplateRequest struct {
	ctx context.Context
	ApiService *TemplatesAPIService
	accountId string
	templateId string
	include *string
}

// A comma-separated list of additional template attributes to include in the response. Valid values are:  - &#x60;powerforms&#x60;: Includes information about PowerForms. - &#x60;tabs&#x60;: Includes information about tabs. - &#x60;documents&#x60;: Includes information about documents. - &#x60;favorite_template_status&#x60;: : Includes the template &#x60;favoritedByMe&#x60; property in the response. **Note:** You can mark a template as a favorite only in eSignature v2.1.
func (r ApiTemplatesGetTemplateRequest) Include(include string) ApiTemplatesGetTemplateRequest {
	r.include = &include
	return r
}

func (r ApiTemplatesGetTemplateRequest) Execute() (*EnvelopeTemplate, *http.Response, error) {
	return r.ApiService.TemplatesGetTemplateExecute(r)
}

/*
TemplatesGetTemplate Gets a specific template associated with a specified account.

Retrieves the definition of the specified template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @return ApiTemplatesGetTemplateRequest
*/
func (a *TemplatesAPIService) TemplatesGetTemplate(ctx context.Context, accountId string, templateId string) ApiTemplatesGetTemplateRequest {
	return ApiTemplatesGetTemplateRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return EnvelopeTemplate
func (a *TemplatesAPIService) TemplatesGetTemplateExecute(r ApiTemplatesGetTemplateRequest) (*EnvelopeTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesAPIService.TemplatesGetTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTemplatesGetTemplatesRequest struct {
	ctx context.Context
	ApiService *TemplatesAPIService
	accountId string
	count *string
	createdFromDate *string
	createdToDate *string
	folderIds *string
	folderTypes *string
	fromDate *string
	include *string
	isDeletedTemplateOnly *string
	isDownload *string
	modifiedFromDate *string
	modifiedToDate *string
	order *string
	orderBy *string
	searchFields *string
	searchText *string
	sharedByMe *string
	startPosition *string
	templateIds *string
	toDate *string
	usedFromDate *string
	usedToDate *string
	userFilter *string
	userId *string
}

// The maximum number of results to return.  Use &#x60;start_position&#x60; to specify the number of results to skip. 
func (r ApiTemplatesGetTemplatesRequest) Count(count string) ApiTemplatesGetTemplatesRequest {
	r.count = &count
	return r
}

// Lists templates created on or after this date.
func (r ApiTemplatesGetTemplatesRequest) CreatedFromDate(createdFromDate string) ApiTemplatesGetTemplatesRequest {
	r.createdFromDate = &createdFromDate
	return r
}

// Lists templates modified before this date.
func (r ApiTemplatesGetTemplatesRequest) CreatedToDate(createdToDate string) ApiTemplatesGetTemplatesRequest {
	r.createdToDate = &createdToDate
	return r
}

// A comma-separated list of folder ID GUIDs.
func (r ApiTemplatesGetTemplatesRequest) FolderIds(folderIds string) ApiTemplatesGetTemplatesRequest {
	r.folderIds = &folderIds
	return r
}

// The type of folder to return templates for. Possible values are:  - &#x60;templates&#x60;: Templates in the **My Templates** folder.   Templates in the **Shared Templates**  and **All Template** folders (if the request ID from and Admin) are excluded. - &#x60;templates_root&#x60;: Templates in the root level of the **My Templates** folder, but not in an actual folder. Note that the **My Templates** folder is not a real folder. - &#x60;recylebin&#x60;: Templates that have been deleted. 
func (r ApiTemplatesGetTemplatesRequest) FolderTypes(folderTypes string) ApiTemplatesGetTemplatesRequest {
	r.folderTypes = &folderTypes
	return r
}

// Start of the search date range. Only returns templates created on or after this date/time. If no value is specified, there is no limit on the earliest date created.
func (r ApiTemplatesGetTemplatesRequest) FromDate(fromDate string) ApiTemplatesGetTemplatesRequest {
	r.fromDate = &fromDate
	return r
}

// A comma-separated list of additional template attributes to include in the response. Valid values are:  - &#x60;powerforms&#x60;: Includes details about the PowerForms associated with the templates. - &#x60;documents&#x60;: Includes information about template documents. - &#x60;folders&#x60;: Includes information about the folder that holds the template. - &#x60;favorite_template_status&#x60;: Includes the template &#x60;favoritedByMe&#x60; property. **Note:** You can mark a template as a favorite only in eSignature v2.1. - &#x60;advanced_templates&#x60;: Includes information about advanced templates. - &#x60;recipients&#x60;: Includes information about template recipients. - &#x60;custom_fields&#x60;: Includes information about template custom fields. - &#x60;notifications&#x60;: Includes information about the notification settings for templates.
func (r ApiTemplatesGetTemplatesRequest) Include(include string) ApiTemplatesGetTemplatesRequest {
	r.include = &include
	return r
}

// When **true,** retrieves templates that have been permanently deleted. The default is **false.**  **Note:** After you delete a template, you can see it in the &#x60;Deleted&#x60; bin in the UI for 24 hours. After 24 hours, the template is permanently deleted. 
func (r ApiTemplatesGetTemplatesRequest) IsDeletedTemplateOnly(isDeletedTemplateOnly string) ApiTemplatesGetTemplatesRequest {
	r.isDeletedTemplateOnly = &isDeletedTemplateOnly
	return r
}

// When **true,** downloads the templates listed in &#x60;template_ids&#x60; as a collection of JSON definitions in a single zip file.  The &#x60;Content-Disposition&#x60; header is set in the response. The value of the header provides the filename of the file.  The default is **false.**  **Note:** This parameter only works when you specify a list of templates in the &#x60;template_ids&#x60; parameter.
func (r ApiTemplatesGetTemplatesRequest) IsDownload(isDownload string) ApiTemplatesGetTemplatesRequest {
	r.isDownload = &isDownload
	return r
}

// Lists templates modified on or after this date.
func (r ApiTemplatesGetTemplatesRequest) ModifiedFromDate(modifiedFromDate string) ApiTemplatesGetTemplatesRequest {
	r.modifiedFromDate = &modifiedFromDate
	return r
}

// Lists templates modified before this date.
func (r ApiTemplatesGetTemplatesRequest) ModifiedToDate(modifiedToDate string) ApiTemplatesGetTemplatesRequest {
	r.modifiedToDate = &modifiedToDate
	return r
}

// Specifies the sort order of the search results. Valid values are:  - &#x60;asc&#x60;: Ascending (A to Z) - &#x60;desc&#x60;: Descending (Z to A)
func (r ApiTemplatesGetTemplatesRequest) Order(order string) ApiTemplatesGetTemplatesRequest {
	r.order = &order
	return r
}

// Specifies how the search results are listed. Valid values are:  - &#x60;name&#x60;: template name - &#x60;modified&#x60;: date/time template was last modified - &#x60;used&#x60;: date/time the template was last used.
func (r ApiTemplatesGetTemplatesRequest) OrderBy(orderBy string) ApiTemplatesGetTemplatesRequest {
	r.orderBy = &orderBy
	return r
}

// A comma-separated list of additional template properties to search.   - &#x60;sender&#x60;: Include sender name and email in the search. - &#x60;recipients&#x60;: Include recipient names and emails in the search. - &#x60;envelope&#x60;: Not used in template searches. 
func (r ApiTemplatesGetTemplatesRequest) SearchFields(searchFields string) ApiTemplatesGetTemplatesRequest {
	r.searchFields = &searchFields
	return r
}

// The text to use to search the names of templates.  Limit: 48 characters.
func (r ApiTemplatesGetTemplatesRequest) SearchText(searchText string) ApiTemplatesGetTemplatesRequest {
	r.searchText = &searchText
	return r
}

// When **true,** the response only includes templates shared by the user. When **false,** the response only returns template not shared by the user. If not specified, templates are returned whether or not they have been shared by the user.
func (r ApiTemplatesGetTemplatesRequest) SharedByMe(sharedByMe string) ApiTemplatesGetTemplatesRequest {
	r.sharedByMe = &sharedByMe
	return r
}

// The zero-based index of the result from which to start returning results.  Use with &#x60;count&#x60; to limit the number of results.  The default value is &#x60;0&#x60;. 
func (r ApiTemplatesGetTemplatesRequest) StartPosition(startPosition string) ApiTemplatesGetTemplatesRequest {
	r.startPosition = &startPosition
	return r
}

// A comma-separated list of template IDs to download. This value is valid only when &#x60;is_download&#x60; is **true.**
func (r ApiTemplatesGetTemplatesRequest) TemplateIds(templateIds string) ApiTemplatesGetTemplatesRequest {
	r.templateIds = &templateIds
	return r
}

// The end of a search date range in UTC DateTime format. When you use this parameter, only templates created up to this date and time are returned.  **Note:** If this property is null, the value defaults to the current date.
func (r ApiTemplatesGetTemplatesRequest) ToDate(toDate string) ApiTemplatesGetTemplatesRequest {
	r.toDate = &toDate
	return r
}

// Start of the search date range. Only returns templates used or edited on or after this date/time. If no value is specified, there is no limit on the earliest date used.
func (r ApiTemplatesGetTemplatesRequest) UsedFromDate(usedFromDate string) ApiTemplatesGetTemplatesRequest {
	r.usedFromDate = &usedFromDate
	return r
}

// End of the search date range. Only returns templates used or edited up to this date/time. If no value is provided, this defaults to the current date.
func (r ApiTemplatesGetTemplatesRequest) UsedToDate(usedToDate string) ApiTemplatesGetTemplatesRequest {
	r.usedToDate = &usedToDate
	return r
}

// Filters the templates in the response. Valid values are:   - &#x60;owned_by_me&#x60;: Results include only templates owned by the user. - &#x60;shared_with_me&#x60;: Results include only templates shared with the user.   - &#x60;all&#x60;:  Results include all templates owned or shared with the user.
func (r ApiTemplatesGetTemplatesRequest) UserFilter(userFilter string) ApiTemplatesGetTemplatesRequest {
	r.userFilter = &userFilter
	return r
}

// The ID of the user.
func (r ApiTemplatesGetTemplatesRequest) UserId(userId string) ApiTemplatesGetTemplatesRequest {
	r.userId = &userId
	return r
}

func (r ApiTemplatesGetTemplatesRequest) Execute() (*EnvelopeTemplateResults, *http.Response, error) {
	return r.ApiService.TemplatesGetTemplatesExecute(r)
}

/*
TemplatesGetTemplates Gets the list of templates.

Retrieves the list of templates for the specified account. The request can be limited to a specific folder.

### Related topics

- [How to create a template](/docs/esign-rest-api/how-to/create-template/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiTemplatesGetTemplatesRequest
*/
func (a *TemplatesAPIService) TemplatesGetTemplates(ctx context.Context, accountId string) ApiTemplatesGetTemplatesRequest {
	return ApiTemplatesGetTemplatesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return EnvelopeTemplateResults
func (a *TemplatesAPIService) TemplatesGetTemplatesExecute(r ApiTemplatesGetTemplatesRequest) (*EnvelopeTemplateResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeTemplateResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesAPIService.TemplatesGetTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.createdFromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_from_date", r.createdFromDate, "")
	}
	if r.createdToDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_to_date", r.createdToDate, "")
	}
	if r.folderIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folder_ids", r.folderIds, "")
	}
	if r.folderTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folder_types", r.folderTypes, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	if r.isDeletedTemplateOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_deleted_template_only", r.isDeletedTemplateOnly, "")
	}
	if r.isDownload != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_download", r.isDownload, "")
	}
	if r.modifiedFromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_from_date", r.modifiedFromDate, "")
	}
	if r.modifiedToDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_to_date", r.modifiedToDate, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.searchFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_fields", r.searchFields, "")
	}
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_text", r.searchText, "")
	}
	if r.sharedByMe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shared_by_me", r.sharedByMe, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	if r.templateIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "template_ids", r.templateIds, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_date", r.toDate, "")
	}
	if r.usedFromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "used_from_date", r.usedFromDate, "")
	}
	if r.usedToDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "used_to_date", r.usedToDate, "")
	}
	if r.userFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_filter", r.userFilter, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTemplatesPostTemplatesRequest struct {
	ctx context.Context
	ApiService *TemplatesAPIService
	accountId string
	envelopeTemplate *EnvelopeTemplate
}

func (r ApiTemplatesPostTemplatesRequest) EnvelopeTemplate(envelopeTemplate EnvelopeTemplate) ApiTemplatesPostTemplatesRequest {
	r.envelopeTemplate = &envelopeTemplate
	return r
}

func (r ApiTemplatesPostTemplatesRequest) Execute() (*TemplateSummary, *http.Response, error) {
	return r.ApiService.TemplatesPostTemplatesExecute(r)
}

/*
TemplatesPostTemplates Creates one or more templates.

Creates one or more template definitions, using a multipart
request for each template.

[Templates](/docs/esign-rest-api/esign101/concepts/templates/)
help streamline the sending process when you frequently
send the same or similar documents, or send different documents
to the same group of people.

When you create a template, you define placeholder roles. Rather
than specifying a person, you specify a role that regularly
participates in a transaction that uses the template. Then, when
you create or send an envelope based on the template, you assign
actual recipients to the template roles. The recipients
automatically inherit all of the workflow that is defined for
that role in the template, such as the tabs and routing
information.

## Template Email Subject Merge Fields

Placeholder roles have associated merge fields that personalize
the email notification that DocuSign sends. For example, the
template automatically personalizes the email message by adding
placeholders for the recipient's name and email address within
the email subject line, based on the recipient's role. When the
sender adds the name and email information for the recipient and
sends the envelope, the recipient information is automatically
merged into the appropriate fields in the email subject line.

Both the sender and the recipients will see the information in
the email subject line for any emails associated with the
template. This provides an easy way for senders to organize their
envelope emails without having to open an envelope to find out
who the recipient is.



Use the following placeholders
to insert a recipient's name or
email address in the subject line

To insert a recipient's name into the subject line,
use the `[[<roleName>_UserName]]` placeholder
in the  `emailSubject` property when you create the
template:

To include a recipient's name
or email address in the subject line,
use the following placeholders
in the `emailSubject` property:

- `[[<roleName>_UserName]]`
- `[[<roleName>_Email]]`


For example, if the role name is `Signer 1`,
you might set `emailSubject` to one of these strings:

- `"[[Signer 1_UserName]], Please sign this NDA"`
- `"[[Signer 1_Email]], Please sign this NDA"`


**Note:** The maximum length of the
subject line is 100 characters,
including any merged text.


## Creating multiple templates

To create multiple templates, you provide a zip file of JSON
files. You can also use the Templates::ListTemplates method with
the `is_download` query parameter to download a zip file
containing your existing templates and use that as a guide. The
API supports both .zip and .gzip file formats as input.

You also need to set the
`Content-Length`,
`Content-Type`,
and
`Content-Disposition`
headers:


```
Content-Length: 71068
Content-Type: application/zip
Content-Disposition: file; filename="DocuSignTemplates_Nov_25_2019_20_40_21.zip"; fileExtension=.zip
```

### Related topics

- [How to create a template](/docs/esign-rest-api/how-to/create-template/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId (Required) The external account number (int) or account ID GUID.
 @return ApiTemplatesPostTemplatesRequest
*/
func (a *TemplatesAPIService) TemplatesPostTemplates(ctx context.Context, accountId string) ApiTemplatesPostTemplatesRequest {
	return ApiTemplatesPostTemplatesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return TemplateSummary
func (a *TemplatesAPIService) TemplatesPostTemplatesExecute(r ApiTemplatesPostTemplatesRequest) (*TemplateSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesAPIService.TemplatesPostTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeTemplate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTemplatesPutTemplateRequest struct {
	ctx context.Context
	ApiService *TemplatesAPIService
	accountId string
	templateId string
	envelopeTemplate *EnvelopeTemplate
}

func (r ApiTemplatesPutTemplateRequest) EnvelopeTemplate(envelopeTemplate EnvelopeTemplate) ApiTemplatesPutTemplateRequest {
	r.envelopeTemplate = &envelopeTemplate
	return r
}

func (r ApiTemplatesPutTemplateRequest) Execute() (*TemplateUpdateSummary, *http.Response, error) {
	return r.ApiService.TemplatesPutTemplateExecute(r)
}

/*
TemplatesPutTemplate Updates an existing template.

Updates an existing template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @return ApiTemplatesPutTemplateRequest
*/
func (a *TemplatesAPIService) TemplatesPutTemplate(ctx context.Context, accountId string, templateId string) ApiTemplatesPutTemplateRequest {
	return ApiTemplatesPutTemplateRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return TemplateUpdateSummary
func (a *TemplatesAPIService) TemplatesPutTemplateExecute(r ApiTemplatesPutTemplateRequest) (*TemplateUpdateSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateUpdateSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesAPIService.TemplatesPutTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeTemplate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTemplatesPutTemplatePartRequest struct {
	ctx context.Context
	ApiService *TemplatesAPIService
	accountId string
	templateId string
	templatePart string
	groupInformation *GroupInformation
}

func (r ApiTemplatesPutTemplatePartRequest) GroupInformation(groupInformation GroupInformation) ApiTemplatesPutTemplatePartRequest {
	r.groupInformation = &groupInformation
	return r
}

func (r ApiTemplatesPutTemplatePartRequest) Execute() (*GroupInformation, *http.Response, error) {
	return r.ApiService.TemplatesPutTemplatePartExecute(r)
}

/*
TemplatesPutTemplatePart Shares a template with a group.

Shares a template with the specified members group.

**Note:** For a newer version of this functionality, see [Accounts: Update Shared Access](/docs/esign-rest-api/reference/accounts/accounts/updatesharedaccess/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @param templatePart Currently, the only defined part is **groups.**
 @return ApiTemplatesPutTemplatePartRequest
*/
func (a *TemplatesAPIService) TemplatesPutTemplatePart(ctx context.Context, accountId string, templateId string, templatePart string) ApiTemplatesPutTemplatePartRequest {
	return ApiTemplatesPutTemplatePartRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
		templatePart: templatePart,
	}
}

// Execute executes the request
//  @return GroupInformation
func (a *TemplatesAPIService) TemplatesPutTemplatePartExecute(r ApiTemplatesPutTemplatePartRequest) (*GroupInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesAPIService.TemplatesPutTemplatePart")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/{templatePart}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templatePart"+"}", url.PathEscape(parameterValueToString(r.templatePart, "templatePart")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
