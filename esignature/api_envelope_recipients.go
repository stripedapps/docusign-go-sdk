/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// EnvelopeRecipientsAPIService EnvelopeRecipientsAPI service
type EnvelopeRecipientsAPIService service

type ApiRecipientsDeleteRecipientRequest struct {
	ctx context.Context
	ApiService *EnvelopeRecipientsAPIService
	accountId string
	envelopeId string
	recipientId string
}

func (r ApiRecipientsDeleteRecipientRequest) Execute() (*EnvelopeRecipients, *http.Response, error) {
	return r.ApiService.RecipientsDeleteRecipientExecute(r)
}

/*
RecipientsDeleteRecipient Deletes a recipient from an envelope.

Deletes a recipient from a `draft` or `sent` envelope.

If the envelope is "In Process" (has been sent and is not completed or voided), recipients that have completed their actions cannot be deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param recipientId A local reference used to map recipients to other objects, such as specific document tabs.  A `recipientId` must be either an integer or a GUID, and the `recipientId` must be unique within an envelope.  For example, many envelopes assign the first recipient a `recipientId` of `1`. 
 @return ApiRecipientsDeleteRecipientRequest
*/
func (a *EnvelopeRecipientsAPIService) RecipientsDeleteRecipient(ctx context.Context, accountId string, envelopeId string, recipientId string) ApiRecipientsDeleteRecipientRequest {
	return ApiRecipientsDeleteRecipientRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
		recipientId: recipientId,
	}
}

// Execute executes the request
//  @return EnvelopeRecipients
func (a *EnvelopeRecipientsAPIService) RecipientsDeleteRecipientExecute(r ApiRecipientsDeleteRecipientRequest) (*EnvelopeRecipients, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeRecipients
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeRecipientsAPIService.RecipientsDeleteRecipient")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/recipients/{recipientId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recipientId"+"}", url.PathEscape(parameterValueToString(r.recipientId, "recipientId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecipientsDeleteRecipientsRequest struct {
	ctx context.Context
	ApiService *EnvelopeRecipientsAPIService
	accountId string
	envelopeId string
	envelopeRecipients *EnvelopeRecipients
}

func (r ApiRecipientsDeleteRecipientsRequest) EnvelopeRecipients(envelopeRecipients EnvelopeRecipients) ApiRecipientsDeleteRecipientsRequest {
	r.envelopeRecipients = &envelopeRecipients
	return r
}

func (r ApiRecipientsDeleteRecipientsRequest) Execute() (*EnvelopeRecipients, *http.Response, error) {
	return r.ApiService.RecipientsDeleteRecipientsExecute(r)
}

/*
RecipientsDeleteRecipients Deletes recipients from an envelope.

Deletes one or more recipients from a draft or sent envelope. List the recipients that you want to delete in the body of the request. This method uses the `recipientId` as the key for deleting recipients.

If the envelope is `In Process`, meaning that it has been sent and has not been completed or voided, recipients that have completed their actions cannot be deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiRecipientsDeleteRecipientsRequest
*/
func (a *EnvelopeRecipientsAPIService) RecipientsDeleteRecipients(ctx context.Context, accountId string, envelopeId string) ApiRecipientsDeleteRecipientsRequest {
	return ApiRecipientsDeleteRecipientsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return EnvelopeRecipients
func (a *EnvelopeRecipientsAPIService) RecipientsDeleteRecipientsExecute(r ApiRecipientsDeleteRecipientsRequest) (*EnvelopeRecipients, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeRecipients
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeRecipientsAPIService.RecipientsDeleteRecipients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/recipients"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeRecipients
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecipientsGetRecipientsRequest struct {
	ctx context.Context
	ApiService *EnvelopeRecipientsAPIService
	accountId string
	envelopeId string
	includeAnchorTabLocations *string
	includeExtended *string
	includeMetadata *string
	includeTabs *string
}

//  When **true** and &#x60;include_tabs&#x60; value is set to **true,** all tabs with anchor tab properties are included in the response. 
func (r ApiRecipientsGetRecipientsRequest) IncludeAnchorTabLocations(includeAnchorTabLocations string) ApiRecipientsGetRecipientsRequest {
	r.includeAnchorTabLocations = &includeAnchorTabLocations
	return r
}

//  When **true,** the extended properties are included in the response. 
func (r ApiRecipientsGetRecipientsRequest) IncludeExtended(includeExtended string) ApiRecipientsGetRecipientsRequest {
	r.includeExtended = &includeExtended
	return r
}

// Boolean value that specifies whether to include metadata associated with the recipients (for envelopes only, not templates).
func (r ApiRecipientsGetRecipientsRequest) IncludeMetadata(includeMetadata string) ApiRecipientsGetRecipientsRequest {
	r.includeMetadata = &includeMetadata
	return r
}

// When **true,** the tab information associated with the recipient is included in the response.
func (r ApiRecipientsGetRecipientsRequest) IncludeTabs(includeTabs string) ApiRecipientsGetRecipientsRequest {
	r.includeTabs = &includeTabs
	return r
}

func (r ApiRecipientsGetRecipientsRequest) Execute() (*EnvelopeRecipients, *http.Response, error) {
	return r.ApiService.RecipientsGetRecipientsExecute(r)
}

/*
RecipientsGetRecipients Gets the status of recipients for an envelope.

Retrieves the status of all recipients in a single envelope and identifies the current recipient in the routing list. This method can also be used to retrieve the tab values.

The `currentRoutingOrder` property of the response contains the `routingOrder` value of the current recipient indicating that the envelope has been sent to the recipient, but the recipient has not completed their actions.

### Related topics

- [How to list envelope recipients](/docs/esign-rest-api/how-to/get-envelope-recipients/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiRecipientsGetRecipientsRequest
*/
func (a *EnvelopeRecipientsAPIService) RecipientsGetRecipients(ctx context.Context, accountId string, envelopeId string) ApiRecipientsGetRecipientsRequest {
	return ApiRecipientsGetRecipientsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return EnvelopeRecipients
func (a *EnvelopeRecipientsAPIService) RecipientsGetRecipientsExecute(r ApiRecipientsGetRecipientsRequest) (*EnvelopeRecipients, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeRecipients
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeRecipientsAPIService.RecipientsGetRecipients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/recipients"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeAnchorTabLocations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_anchor_tab_locations", r.includeAnchorTabLocations, "")
	}
	if r.includeExtended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_extended", r.includeExtended, "")
	}
	if r.includeMetadata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_metadata", r.includeMetadata, "")
	}
	if r.includeTabs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_tabs", r.includeTabs, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecipientsPostRecipientProofFileResourceTokenRequest struct {
	ctx context.Context
	ApiService *EnvelopeRecipientsAPIService
	accountId string
	envelopeId string
	recipientId string
}

func (r ApiRecipientsPostRecipientProofFileResourceTokenRequest) Execute() (*IdEvidenceResourceToken, *http.Response, error) {
	return r.ApiService.RecipientsPostRecipientProofFileResourceTokenExecute(r)
}

/*
RecipientsPostRecipientProofFileResourceToken Creates a resource token for a sender to request ID Evidence data. 

Creates a resource token for a sender. This token allows a sender to return identification data for a recipient using the [ID Evidence API](/docs/idevidence-api/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The account ID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param recipientId The `recipientIdGuid`.
 @return ApiRecipientsPostRecipientProofFileResourceTokenRequest
*/
func (a *EnvelopeRecipientsAPIService) RecipientsPostRecipientProofFileResourceToken(ctx context.Context, accountId string, envelopeId string, recipientId string) ApiRecipientsPostRecipientProofFileResourceTokenRequest {
	return ApiRecipientsPostRecipientProofFileResourceTokenRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
		recipientId: recipientId,
	}
}

// Execute executes the request
//  @return IdEvidenceResourceToken
func (a *EnvelopeRecipientsAPIService) RecipientsPostRecipientProofFileResourceTokenExecute(r ApiRecipientsPostRecipientProofFileResourceTokenRequest) (*IdEvidenceResourceToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdEvidenceResourceToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeRecipientsAPIService.RecipientsPostRecipientProofFileResourceToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/recipients/{recipientId}/identity_proof_token"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recipientId"+"}", url.PathEscape(parameterValueToString(r.recipientId, "recipientId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecipientsPostRecipientsRequest struct {
	ctx context.Context
	ApiService *EnvelopeRecipientsAPIService
	accountId string
	envelopeId string
	resendEnvelope *string
	envelopeRecipients *EnvelopeRecipients
}

// When **true,** forces the envelope to be resent if it would not be resent otherwise.  Ordinarily, if the recipient&#39;s routing order is before or the same as the envelope&#39;s next recipient, the envelope is not resent.  Setting this query parameter to **false** has no effect and is the same as omitting it altogether. 
func (r ApiRecipientsPostRecipientsRequest) ResendEnvelope(resendEnvelope string) ApiRecipientsPostRecipientsRequest {
	r.resendEnvelope = &resendEnvelope
	return r
}

func (r ApiRecipientsPostRecipientsRequest) EnvelopeRecipients(envelopeRecipients EnvelopeRecipients) ApiRecipientsPostRecipientsRequest {
	r.envelopeRecipients = &envelopeRecipients
	return r
}

func (r ApiRecipientsPostRecipientsRequest) Execute() (*EnvelopeRecipients, *http.Response, error) {
	return r.ApiService.RecipientsPostRecipientsExecute(r)
}

/*
RecipientsPostRecipients Adds one or more recipients to an envelope.

Adds one or more recipients to an envelope.

For an in-process envelope,
one that has been sent and has not been completed or voided,
an email is sent to a new recipient
when they are reached in the routing order.
If the new recipient's routing order
is before or the same as the envelope's
next recipient,
an email is only sent if the optional
`resend_envelope` query string is set to **true.**


**Note:** This method works on recipients only.
To add recipient tabs,
use methods from the [EnvelopeRecipientTabs][recipientTabs] resource.
For example, this request body will add a recipient (`astanton@example.com`)
but **NOT** the Sign Here recipient tab.

```json
{
  "signers": [
    {
      "email": "astanton@example.com",
      "name": "Anne Stanton",
      "recipientId": "1",
      "tabs": {           // These tabs will NOT be added
        "signHereTabs": [ // with this method. See note above.
          {
            "anchorString": "below",
            "tooltip": "please sign here"
          },
          . . .
        ]
      }
    }
  ]
}
```

[recipientTabs]: /docs/esign-rest-api/reference/envelopes/enveloperecipienttabs/


### Related topics

- [How to bulk send envelopes](/docs/esign-rest-api/how-to/bulk-send-envelopes/)





 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiRecipientsPostRecipientsRequest
*/
func (a *EnvelopeRecipientsAPIService) RecipientsPostRecipients(ctx context.Context, accountId string, envelopeId string) ApiRecipientsPostRecipientsRequest {
	return ApiRecipientsPostRecipientsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return EnvelopeRecipients
func (a *EnvelopeRecipientsAPIService) RecipientsPostRecipientsExecute(r ApiRecipientsPostRecipientsRequest) (*EnvelopeRecipients, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeRecipients
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeRecipientsAPIService.RecipientsPostRecipients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/recipients"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.resendEnvelope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resend_envelope", r.resendEnvelope, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeRecipients
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecipientsPutRecipientsRequest struct {
	ctx context.Context
	ApiService *EnvelopeRecipientsAPIService
	accountId string
	envelopeId string
	combineSameOrderRecipients *string
	offlineSigning *string
	resendEnvelope *string
	envelopeRecipients *EnvelopeRecipients
}

// When **true,** recipients are combined or merged with matching recipients. Recipient matching occurs as part of [template matching](https://support.docusign.com/s/document-item?bundleId&#x3D;jux1643235969954&amp;topicId&#x3D;fxo1578456612662.html), and is based on Recipient Role and Routing Order.
func (r ApiRecipientsPutRecipientsRequest) CombineSameOrderRecipients(combineSameOrderRecipients string) ApiRecipientsPutRecipientsRequest {
	r.combineSameOrderRecipients = &combineSameOrderRecipients
	return r
}

// Indicates if offline signing is enabled for the recipient when a network connection is unavailable. 
func (r ApiRecipientsPutRecipientsRequest) OfflineSigning(offlineSigning string) ApiRecipientsPutRecipientsRequest {
	r.offlineSigning = &offlineSigning
	return r
}

// When **true,** forces the envelope to be resent if it would not be resent otherwise.  Ordinarily, if the recipient&#39;s routing order is before or the same as the envelope&#39;s next recipient, the envelope is not resent.  Setting this query parameter to **false** has no effect and is the same as omitting it altogether. 
func (r ApiRecipientsPutRecipientsRequest) ResendEnvelope(resendEnvelope string) ApiRecipientsPutRecipientsRequest {
	r.resendEnvelope = &resendEnvelope
	return r
}

func (r ApiRecipientsPutRecipientsRequest) EnvelopeRecipients(envelopeRecipients EnvelopeRecipients) ApiRecipientsPutRecipientsRequest {
	r.envelopeRecipients = &envelopeRecipients
	return r
}

func (r ApiRecipientsPutRecipientsRequest) Execute() (*RecipientsUpdateSummary, *http.Response, error) {
	return r.ApiService.RecipientsPutRecipientsExecute(r)
}

/*
RecipientsPutRecipients Updates recipients in a draft envelope or corrects recipient information for an in-process envelope.

Updates the recipients of a draft envelope or corrects recipient information for an in-process envelope.

If you send information for a recipient that does not already
exist in a draft envelope, the recipient is added to the envelope
(similar to the [EnvelopeRecipients: Create][EnvelopeRecipients-create] method).

You can also use this method to resend an envelope to a recipient
by using the `resend_envelope` option.

**Updating Sent Envelopes**

After an envelope has been sent, you can edit only the following properties:

- `accessCode`
- `agentCanEditName`
- `agentCanEditEmail`
- `customFields`
- `deliveryMethod`
- `documentVisibility`
- `email` (If you provide an email address in this method, it will be treated as a new email address, even if it is exactly the same as the current address. Do not provide an email address if you do not want a correction email sent.)
- `emailNotification`
- `idCheckConfigurationName`
- `identityVerification`
- `name`
- `note`
- `phoneAuthentication`
- `recipientType` (For this to work, you must also change the recipient object to match the recipient type.)
- `requireIdLookup`
- `routingOrder`
- `routingOrder`
- `signingGroupId` (You can change this ID to switch to a different signing group and its corresponding set of recipients.)
- `smsAuthentication`
- `suppressEmails`
- `userName`

If the recipient has signed,
but the envelope is still active,
the method will return success,
but the `recipientUpdateResults` property
in the response will include an error
that the recipient could not be updated:

```
{
  "recipientUpdateResults": [
    {
      "recipientId": "999",
      "errorDetails": {
        "errorCode": "RECIPIENT_UPDATE_FAILED",
        "message": "The recipient could not be updated.  Recipient not in state that allows correction."
      }
    }
  ]
}
```

If the envelope is completed,
and you try to change a recipient's address,
the method will fail with this error:

```
{
  "errorCode": "ENVELOPE_INVALID_STATUS",
  "message": "Invalid envelope status. Envelope status is not one of: Created, Sent, Delivered, Correct."
}
```

**Note:** This method works on recipients only.
To add recipient tabs,
use methods from the [EnvelopeRecipientTabs][recipientTabs] resource.
For example, this request body will add a recipient (`astanton@example.com`)
but **NOT** the Sign Here recipient tab.

```json
{
  "signers": [
    {
      "email": "astanton@example.com",
      "name": "Anne Stanton",
      "recipientId": "1",
// THIS WILL NOT WORK
      "tabs": {
        "signHereTabs": [
          {
            "anchorString": "below",
            "tooltip": "please sign here3"
          },
          . . .
        ]
      }
    }
  ]
}
```


[EnvelopeRecipients-create]: /docs/esign-rest-api/reference/envelopes/enveloperecipients/create/
[recipientTabs]: /docs/esign-rest-api/reference/envelopes/enveloperecipienttabs/



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiRecipientsPutRecipientsRequest
*/
func (a *EnvelopeRecipientsAPIService) RecipientsPutRecipients(ctx context.Context, accountId string, envelopeId string) ApiRecipientsPutRecipientsRequest {
	return ApiRecipientsPutRecipientsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return RecipientsUpdateSummary
func (a *EnvelopeRecipientsAPIService) RecipientsPutRecipientsExecute(r ApiRecipientsPutRecipientsRequest) (*RecipientsUpdateSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RecipientsUpdateSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeRecipientsAPIService.RecipientsPutRecipients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/recipients"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.combineSameOrderRecipients != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "combine_same_order_recipients", r.combineSameOrderRecipients, "")
	}
	if r.offlineSigning != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offline_signing", r.offlineSigning, "")
	}
	if r.resendEnvelope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resend_envelope", r.resendEnvelope, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeRecipients
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiViewsPostEnvelopeRecipientPreviewRequest struct {
	ctx context.Context
	ApiService *EnvelopeRecipientsAPIService
	accountId string
	envelopeId string
	recipientPreviewRequest *RecipientPreviewRequest
}

func (r ApiViewsPostEnvelopeRecipientPreviewRequest) RecipientPreviewRequest(recipientPreviewRequest RecipientPreviewRequest) ApiViewsPostEnvelopeRecipientPreviewRequest {
	r.recipientPreviewRequest = &recipientPreviewRequest
	return r
}

func (r ApiViewsPostEnvelopeRecipientPreviewRequest) Execute() (*ViewUrl, *http.Response, error) {
	return r.ApiService.ViewsPostEnvelopeRecipientPreviewExecute(r)
}

/*
ViewsPostEnvelopeRecipientPreview Creates an envelope recipient preview.

Returns a URL to preview the recipients' view of a draft envelope or template. You can embed this view in your application to enable the sender to preview the recipients' experience.

For more information, see [Preview and Send](https://support.docusign.com/s/document-item?bundleId=ulp1643236876813&topicId=oeg1578456408976.html).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiViewsPostEnvelopeRecipientPreviewRequest
*/
func (a *EnvelopeRecipientsAPIService) ViewsPostEnvelopeRecipientPreview(ctx context.Context, accountId string, envelopeId string) ApiViewsPostEnvelopeRecipientPreviewRequest {
	return ApiViewsPostEnvelopeRecipientPreviewRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return ViewUrl
func (a *EnvelopeRecipientsAPIService) ViewsPostEnvelopeRecipientPreviewExecute(r ApiViewsPostEnvelopeRecipientPreviewRequest) (*ViewUrl, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewUrl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeRecipientsAPIService.ViewsPostEnvelopeRecipientPreview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/views/recipient_preview"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.recipientPreviewRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiViewsPostRecipientManualReviewViewRequest struct {
	ctx context.Context
	ApiService *EnvelopeRecipientsAPIService
	accountId string
	envelopeId string
	recipientId string
}

func (r ApiViewsPostRecipientManualReviewViewRequest) Execute() (*ViewUrl, *http.Response, error) {
	return r.ApiService.ViewsPostRecipientManualReviewViewExecute(r)
}

/*
ViewsPostRecipientManualReviewView Create the link to the page for manually reviewing IDs.

This method returns the URL of the page that allows a sender to [manually review](https://support.docusign.com/s/document-item?bundleId=ced1643229641057&topicId=lyp1578456530647.html) the ID of a recipient. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId A value that identifies your account. This value is automatically generated by DocuSign for any account you create. Copy the value from the API Account ID field in the [AppsI and Keys](https://support.docusign.com/s/document-item?bundleId=pik1583277475390&topicId=pmp1583277397015.html) page.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @param recipientId A GUID value that DocuSign assigns to identify each recipient in an envelope. This value is globally unique for all recipients, not just those in your account.  The specified recipient must belong to a workflow that allows the [manual review](https://support.docusign.com/s/document-item?bundleId=pik1583277475390&topicId=eya1583277454804.html) of IDs. In addition, the status of the automatic verification for this recipient must return `Failed` and the value of the `vendorFailureStatusCode` field must be `MANUAL_REVIEW_STARTED` as shown in the following extract of a response to the [GET ENVELOPE](/docs/esign-rest-api/reference/envelopes/envelopes/get/) method: <p>  ``` \"recipientAuthenticationStatus\": {        \"identityVerificationResult\": {               \"status\": \"Failed\",              \"eventTimestamp\": \"2020-09-04T16:59:42.8045667Z\",              \"vendorFailureStatusCode\": \"MANUAL_REVIEW_STARTED\"         }   } ```
 @return ApiViewsPostRecipientManualReviewViewRequest
*/
func (a *EnvelopeRecipientsAPIService) ViewsPostRecipientManualReviewView(ctx context.Context, accountId string, envelopeId string, recipientId string) ApiViewsPostRecipientManualReviewViewRequest {
	return ApiViewsPostRecipientManualReviewViewRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
		recipientId: recipientId,
	}
}

// Execute executes the request
//  @return ViewUrl
func (a *EnvelopeRecipientsAPIService) ViewsPostRecipientManualReviewViewExecute(r ApiViewsPostRecipientManualReviewViewRequest) (*ViewUrl, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewUrl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeRecipientsAPIService.ViewsPostRecipientManualReviewView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/recipients/{recipientId}/views/identity_manual_review"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recipientId"+"}", url.PathEscape(parameterValueToString(r.recipientId, "recipientId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
