/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// TemplateDocumentsAPIService TemplateDocumentsAPI service
type TemplateDocumentsAPIService service

type ApiDocumentsDeleteTemplateDocumentsRequest struct {
	ctx context.Context
	ApiService *TemplateDocumentsAPIService
	accountId string
	templateId string
	envelopeDefinition *EnvelopeDefinition
}

func (r ApiDocumentsDeleteTemplateDocumentsRequest) EnvelopeDefinition(envelopeDefinition EnvelopeDefinition) ApiDocumentsDeleteTemplateDocumentsRequest {
	r.envelopeDefinition = &envelopeDefinition
	return r
}

func (r ApiDocumentsDeleteTemplateDocumentsRequest) Execute() (*TemplateDocumentsResult, *http.Response, error) {
	return r.ApiService.DocumentsDeleteTemplateDocumentsExecute(r)
}

/*
DocumentsDeleteTemplateDocuments Deletes documents from a template.

This method deletes one or more documents from an existing template.

To delete a document, use only the relevant parts of the [`envelopeDefinition`](#envelopeDefinition).
For example, this request body specifies that you want to delete the document whose `documentId` is "1".


```text
{
  "documents": [
    {
      "documentId": "1"
    }
  ]
}
```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @return ApiDocumentsDeleteTemplateDocumentsRequest
*/
func (a *TemplateDocumentsAPIService) DocumentsDeleteTemplateDocuments(ctx context.Context, accountId string, templateId string) ApiDocumentsDeleteTemplateDocumentsRequest {
	return ApiDocumentsDeleteTemplateDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return TemplateDocumentsResult
func (a *TemplateDocumentsAPIService) DocumentsDeleteTemplateDocumentsExecute(r ApiDocumentsDeleteTemplateDocumentsRequest) (*TemplateDocumentsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateDocumentsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplateDocumentsAPIService.DocumentsDeleteTemplateDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsGetTemplateDocumentRequest struct {
	ctx context.Context
	ApiService *TemplateDocumentsAPIService
	accountId string
	documentId string
	templateId string
	encrypt *string
	fileType *string
	showChanges *string
}

// When **true,** the PDF bytes returned in the response are encrypted for all the key managers configured on your DocuSign account. You can decrypt the documents by using the Key Manager DecryptDocument API method. For more information about Key Manager, see the DocuSign Security Appliance Installation Guide that your organization received from DocuSign.
func (r ApiDocumentsGetTemplateDocumentRequest) Encrypt(encrypt string) ApiDocumentsGetTemplateDocumentRequest {
	r.encrypt = &encrypt
	return r
}

func (r ApiDocumentsGetTemplateDocumentRequest) FileType(fileType string) ApiDocumentsGetTemplateDocumentRequest {
	r.fileType = &fileType
	return r
}

// When **true,** any document fields that a recipient changed are highlighted in yellow in the returned PDF document, and optional signatures or initials are outlined in red.
func (r ApiDocumentsGetTemplateDocumentRequest) ShowChanges(showChanges string) ApiDocumentsGetTemplateDocumentRequest {
	r.showChanges = &showChanges
	return r
}

func (r ApiDocumentsGetTemplateDocumentRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DocumentsGetTemplateDocumentExecute(r)
}

/*
DocumentsGetTemplateDocument Gets PDF documents from a template.

This method retrieves one or more PDF documents from the template that you specify.

You can specify the ID of the document to retrieve, or pass in the value `combined` to retrieve all documents in the template as a single PDF file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param documentId The unique ID of the document within the envelope.  Unlike other IDs in the eSignature API, you specify the `documentId` yourself. Typically the first document has the ID `1`, the second document `2`, and so on, but you can use any numbering scheme that fits within a 32-bit signed integer (1 through 2147483647).   Tab objects have a `documentId` property that specifies the document on which to place the tab. 
 @param templateId The ID of the template.
 @return ApiDocumentsGetTemplateDocumentRequest
*/
func (a *TemplateDocumentsAPIService) DocumentsGetTemplateDocument(ctx context.Context, accountId string, documentId string, templateId string) ApiDocumentsGetTemplateDocumentRequest {
	return ApiDocumentsGetTemplateDocumentRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		documentId: documentId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TemplateDocumentsAPIService) DocumentsGetTemplateDocumentExecute(r ApiDocumentsGetTemplateDocumentRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplateDocumentsAPIService.DocumentsGetTemplateDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/documents/{documentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.encrypt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encrypt", r.encrypt, "")
	}
	if r.fileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "file_type", r.fileType, "")
	}
	if r.showChanges != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_changes", r.showChanges, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsGetTemplateDocumentsRequest struct {
	ctx context.Context
	ApiService *TemplateDocumentsAPIService
	accountId string
	templateId string
	includeTabs *string
}

// Reserved for DocuSign.
func (r ApiDocumentsGetTemplateDocumentsRequest) IncludeTabs(includeTabs string) ApiDocumentsGetTemplateDocumentsRequest {
	r.includeTabs = &includeTabs
	return r
}

func (r ApiDocumentsGetTemplateDocumentsRequest) Execute() (*TemplateDocumentsResult, *http.Response, error) {
	return r.ApiService.DocumentsGetTemplateDocumentsExecute(r)
}

/*
DocumentsGetTemplateDocuments Gets a list of documents associated with a template.

Retrieves a list of documents associated with the specified template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @return ApiDocumentsGetTemplateDocumentsRequest
*/
func (a *TemplateDocumentsAPIService) DocumentsGetTemplateDocuments(ctx context.Context, accountId string, templateId string) ApiDocumentsGetTemplateDocumentsRequest {
	return ApiDocumentsGetTemplateDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return TemplateDocumentsResult
func (a *TemplateDocumentsAPIService) DocumentsGetTemplateDocumentsExecute(r ApiDocumentsGetTemplateDocumentsRequest) (*TemplateDocumentsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateDocumentsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplateDocumentsAPIService.DocumentsGetTemplateDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeTabs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_tabs", r.includeTabs, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsPutTemplateDocumentRequest struct {
	ctx context.Context
	ApiService *TemplateDocumentsAPIService
	accountId string
	documentId string
	templateId string
	isEnvelopeDefinition *string
	envelopeDefinition *EnvelopeDefinition
}

func (r ApiDocumentsPutTemplateDocumentRequest) IsEnvelopeDefinition(isEnvelopeDefinition string) ApiDocumentsPutTemplateDocumentRequest {
	r.isEnvelopeDefinition = &isEnvelopeDefinition
	return r
}

func (r ApiDocumentsPutTemplateDocumentRequest) EnvelopeDefinition(envelopeDefinition EnvelopeDefinition) ApiDocumentsPutTemplateDocumentRequest {
	r.envelopeDefinition = &envelopeDefinition
	return r
}

func (r ApiDocumentsPutTemplateDocumentRequest) Execute() (*EnvelopeDocument, *http.Response, error) {
	return r.ApiService.DocumentsPutTemplateDocumentExecute(r)
}

/*
DocumentsPutTemplateDocument Updates a template document.

This methods updates an existing template document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param documentId The unique ID of the document within the envelope.  Unlike other IDs in the eSignature API, you specify the `documentId` yourself. Typically the first document has the ID `1`, the second document `2`, and so on, but you can use any numbering scheme that fits within a 32-bit signed integer (1 through 2147483647).   Tab objects have a `documentId` property that specifies the document on which to place the tab. 
 @param templateId The ID of the template.
 @return ApiDocumentsPutTemplateDocumentRequest
*/
func (a *TemplateDocumentsAPIService) DocumentsPutTemplateDocument(ctx context.Context, accountId string, documentId string, templateId string) ApiDocumentsPutTemplateDocumentRequest {
	return ApiDocumentsPutTemplateDocumentRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		documentId: documentId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return EnvelopeDocument
func (a *TemplateDocumentsAPIService) DocumentsPutTemplateDocumentExecute(r ApiDocumentsPutTemplateDocumentRequest) (*EnvelopeDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplateDocumentsAPIService.DocumentsPutTemplateDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/documents/{documentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isEnvelopeDefinition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_envelope_definition", r.isEnvelopeDefinition, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsPutTemplateDocumentsRequest struct {
	ctx context.Context
	ApiService *TemplateDocumentsAPIService
	accountId string
	templateId string
	envelopeDefinition *EnvelopeDefinition
}

func (r ApiDocumentsPutTemplateDocumentsRequest) EnvelopeDefinition(envelopeDefinition EnvelopeDefinition) ApiDocumentsPutTemplateDocumentsRequest {
	r.envelopeDefinition = &envelopeDefinition
	return r
}

func (r ApiDocumentsPutTemplateDocumentsRequest) Execute() (*TemplateDocumentsResult, *http.Response, error) {
	return r.ApiService.DocumentsPutTemplateDocumentsExecute(r)
}

/*
DocumentsPutTemplateDocuments Adds documents to a template document.

Adds one or more documents to an existing template document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param templateId The ID of the template.
 @return ApiDocumentsPutTemplateDocumentsRequest
*/
func (a *TemplateDocumentsAPIService) DocumentsPutTemplateDocuments(ctx context.Context, accountId string, templateId string) ApiDocumentsPutTemplateDocumentsRequest {
	return ApiDocumentsPutTemplateDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return TemplateDocumentsResult
func (a *TemplateDocumentsAPIService) DocumentsPutTemplateDocumentsExecute(r ApiDocumentsPutTemplateDocumentsRequest) (*TemplateDocumentsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateDocumentsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplateDocumentsAPIService.DocumentsPutTemplateDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/templates/{templateId}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
