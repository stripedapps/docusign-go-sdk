/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// GroupsAPIService GroupsAPI service
type GroupsAPIService service

type ApiGroupsDeleteGroupsRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	accountId string
	groupInformation *GroupInformation
}

func (r ApiGroupsDeleteGroupsRequest) GroupInformation(groupInformation GroupInformation) ApiGroupsDeleteGroupsRequest {
	r.groupInformation = &groupInformation
	return r
}

func (r ApiGroupsDeleteGroupsRequest) Execute() (*GroupInformation, *http.Response, error) {
	return r.ApiService.GroupsDeleteGroupsExecute(r)
}

/*
GroupsDeleteGroups Deletes an existing user group.

Deletes an existing user group.

When you delete a group, you include only the `groupId` in the request body.

Example:

```
{
  "groups": [
    {
      "groupId": "12345"
    }
}
```


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiGroupsDeleteGroupsRequest
*/
func (a *GroupsAPIService) GroupsDeleteGroups(ctx context.Context, accountId string) ApiGroupsDeleteGroupsRequest {
	return ApiGroupsDeleteGroupsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return GroupInformation
func (a *GroupsAPIService) GroupsDeleteGroupsExecute(r ApiGroupsDeleteGroupsRequest) (*GroupInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.GroupsDeleteGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsGetGroupsRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	accountId string
	count *string
	groupType *string
	includeUsercount *string
	searchText *string
	startPosition *string
}

// The maximum number of results to return.  Use &#x60;start_position&#x60; to specify the number of results to skip.  Valid values: &#x60;1&#x60; to &#x60;100&#x60;
func (r ApiGroupsGetGroupsRequest) Count(count string) ApiGroupsGetGroupsRequest {
	r.count = &count
	return r
}

// The type of group to return. Valid values:  * &#x60;AdminGroup&#x60; * &#x60;CustomGroup&#x60; * &#x60;EveryoneGroup&#x60;
func (r ApiGroupsGetGroupsRequest) GroupType(groupType string) ApiGroupsGetGroupsRequest {
	r.groupType = &groupType
	return r
}

// When **true,** every group returned in the response includes a &#x60;userCount&#x60; property that contains the total number of users in the group. The default is **true.**
func (r ApiGroupsGetGroupsRequest) IncludeUsercount(includeUsercount string) ApiGroupsGetGroupsRequest {
	r.includeUsercount = &includeUsercount
	return r
}

// Filters the results of a GET request based on the text that you specify.
func (r ApiGroupsGetGroupsRequest) SearchText(searchText string) ApiGroupsGetGroupsRequest {
	r.searchText = &searchText
	return r
}

// The zero-based index of the result from which to start returning results.  Use with &#x60;count&#x60; to limit the number of results.  The default value is &#x60;0&#x60;. 
func (r ApiGroupsGetGroupsRequest) StartPosition(startPosition string) ApiGroupsGetGroupsRequest {
	r.startPosition = &startPosition
	return r
}

func (r ApiGroupsGetGroupsRequest) Execute() (*GroupInformation, *http.Response, error) {
	return r.ApiService.GroupsGetGroupsExecute(r)
}

/*
GroupsGetGroups Gets information about groups associated with the account.

Gets information about groups associated with the account.


<ds-inlinemessage kind="information" markdown="1">
To get the users in a group:

1. Use this endpoint to get the group ID.
2. Use [listGroupUsers](/docs/esign-rest-api/reference/usergroups/groupusers/list/)
   to get the list of users.
</ds-inlinemessage>

### Related topics

- [How to set a permission profile](/docs/esign-rest-api/how-to/permission-profile-setting/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiGroupsGetGroupsRequest
*/
func (a *GroupsAPIService) GroupsGetGroups(ctx context.Context, accountId string) ApiGroupsGetGroupsRequest {
	return ApiGroupsGetGroupsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return GroupInformation
func (a *GroupsAPIService) GroupsGetGroupsExecute(r ApiGroupsGetGroupsRequest) (*GroupInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.GroupsGetGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.groupType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_type", r.groupType, "")
	}
	if r.includeUsercount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_usercount", r.includeUsercount, "")
	}
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_text", r.searchText, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPostGroupsRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	accountId string
	groupInformation *GroupInformation
}

func (r ApiGroupsPostGroupsRequest) GroupInformation(groupInformation GroupInformation) ApiGroupsPostGroupsRequest {
	r.groupInformation = &groupInformation
	return r
}

func (r ApiGroupsPostGroupsRequest) Execute() (*GroupInformation, *http.Response, error) {
	return r.ApiService.GroupsPostGroupsExecute(r)
}

/*
GroupsPostGroups Creates one or more groups for the account.

Creates one or more groups for the account.

Groups help you manage users.
For example, you can use groups
to limit user access to templates.

You can associate a group with a
[permission profile](/docs/esign-rest-api/esign101/concepts/permissions/),
which sets the user permissions for users in that group
without having to set the `userSettings` property for each user.
You are not required to set permission profiles for a group,
but it makes it easier to manage user permissions
for a large number of users.


<ds-inlinemessage kind="warning" markdown="1">
This endpoint uses only
the <code>groupName</code> and
<code>permissionProfileId</code>
properties in the request body.
All other properties are ignored.
</ds-inlinemessage>


Example request:
```json
{
  "groups": [
    { "groupName": "montagues" },
    { "groupName": "capulets" },
    { "groupName": "nobles",
       "permissionProfileId": 1597 }
  ]
}
```

Use [AccountPermissionProfiles: list](/docs/esign-rest-api/reference/accounts/accountpermissionprofiles/list/)
to get a list of permission profiles and their IDs.
It is an error if the `permissionProfileId` does not exist.


### Related topics

- [How-To Set Up a Permission Profile](/docs/esign-rest-api/how-to/permission-profile-setting/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiGroupsPostGroupsRequest
*/
func (a *GroupsAPIService) GroupsPostGroups(ctx context.Context, accountId string) ApiGroupsPostGroupsRequest {
	return ApiGroupsPostGroupsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return GroupInformation
func (a *GroupsAPIService) GroupsPostGroupsExecute(r ApiGroupsPostGroupsRequest) (*GroupInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.GroupsPostGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPutGroupsRequest struct {
	ctx context.Context
	ApiService *GroupsAPIService
	accountId string
	groupInformation *GroupInformation
}

func (r ApiGroupsPutGroupsRequest) GroupInformation(groupInformation GroupInformation) ApiGroupsPutGroupsRequest {
	r.groupInformation = &groupInformation
	return r
}

func (r ApiGroupsPutGroupsRequest) Execute() (*GroupInformation, *http.Response, error) {
	return r.ApiService.GroupsPutGroupsExecute(r)
}

/*
GroupsPutGroups Updates the group information for a group.

Updates the group name and modifies, or sets, the permission profile for the group.

### Related topics

- [How-To Set Up a Permission Profile](/docs/esign-rest-api/how-to/permission-profile-setting/)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiGroupsPutGroupsRequest
*/
func (a *GroupsAPIService) GroupsPutGroups(ctx context.Context, accountId string) ApiGroupsPutGroupsRequest {
	return ApiGroupsPutGroupsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return GroupInformation
func (a *GroupsAPIService) GroupsPutGroupsExecute(r ApiGroupsPutGroupsRequest) (*GroupInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsAPIService.GroupsPutGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
