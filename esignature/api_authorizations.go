/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AuthorizationsAPIService AuthorizationsAPI service
type AuthorizationsAPIService service

type ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest struct {
	ctx context.Context
	ApiService *AuthorizationsAPIService
	accountId string
	userId string
	activeOnly *string
	count *string
	emailSubstring *string
	includeClosedUsers *string
	permissions *string
	startPosition *string
	userNameSubstring *string
}

// When **true,** only active users are returned. The default value is **false.**
func (r ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest) ActiveOnly(activeOnly string) ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest {
	r.activeOnly = &activeOnly
	return r
}

// The maximum number of results to return.
func (r ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest) Count(count string) ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest {
	r.count = &count
	return r
}

// Filters returned user records by full email address or a substring of email address.
func (r ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest) EmailSubstring(emailSubstring string) ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest {
	r.emailSubstring = &emailSubstring
	return r
}

// When **true,** returns active and scheduled authorizations of closed users. The default value is **true.** This value is only applied when &#x60;active_only&#x60; is **false.**
func (r ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest) IncludeClosedUsers(includeClosedUsers string) ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest {
	r.includeClosedUsers = &includeClosedUsers
	return r
}

func (r ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest) Permissions(permissions string) ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest {
	r.permissions = &permissions
	return r
}

// The position within the total result set from which to start returning values. The value **thumbnail** may be used to return the page image.
func (r ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest) StartPosition(startPosition string) ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest {
	r.startPosition = &startPosition
	return r
}

// Filters results based on a full or partial user name.  **Note:** When you enter a partial user name, you do not use a wildcard character.
func (r ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest) UserNameSubstring(userNameSubstring string) ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest {
	r.userNameSubstring = &userNameSubstring
	return r
}

func (r ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest) Execute() (*UserAuthorizations, *http.Response, error) {
	return r.ApiService.UserAgentAuthorizationsGetAgentUserAuthorizationsExecute(r)
}

/*
UserAgentAuthorizationsGetAgentUserAuthorizations Returns the authorizations for which the specified user is the agent user.

Returns the user authorizations for which the user specified by `userId` is the agent user.

If the calling user is an account administrator, the full results will be returned. Otherwise, only authorizations for which the calling user is the principal user will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The user who is acting as the agent.
 @return ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest
*/
func (a *AuthorizationsAPIService) UserAgentAuthorizationsGetAgentUserAuthorizations(ctx context.Context, accountId string, userId string) ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest {
	return ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserAuthorizations
func (a *AuthorizationsAPIService) UserAgentAuthorizationsGetAgentUserAuthorizationsExecute(r ApiUserAgentAuthorizationsGetAgentUserAuthorizationsRequest) (*UserAuthorizations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserAuthorizations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationsAPIService.UserAgentAuthorizationsGetAgentUserAuthorizations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/authorizations/agent"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_only", r.activeOnly, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.emailSubstring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email_substring", r.emailSubstring, "")
	}
	if r.includeClosedUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_closed_users", r.includeClosedUsers, "")
	}
	if r.permissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissions", r.permissions, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	if r.userNameSubstring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_name_substring", r.userNameSubstring, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserAuthorizationCreateUserAuthorizationRequest struct {
	ctx context.Context
	ApiService *AuthorizationsAPIService
	accountId string
	userId string
	userAuthorizationCreateRequest *UserAuthorizationCreateRequest
}

func (r ApiUserAuthorizationCreateUserAuthorizationRequest) UserAuthorizationCreateRequest(userAuthorizationCreateRequest UserAuthorizationCreateRequest) ApiUserAuthorizationCreateUserAuthorizationRequest {
	r.userAuthorizationCreateRequest = &userAuthorizationCreateRequest
	return r
}

func (r ApiUserAuthorizationCreateUserAuthorizationRequest) Execute() (*UserAuthorization, *http.Response, error) {
	return r.ApiService.UserAuthorizationCreateUserAuthorizationExecute(r)
}

/*
UserAuthorizationCreateUserAuthorization Creates a user authorization.

Creates an authorization allowing one user to send and/or manage envelopes on behalf of another user.

The _agent_ user acts on behalf of the _principal_ user. The principal user is specified by the `userId` path parameter. The agent user is specified in the request body. Each principal user can only share signing permission with one agent user.

Specify in the request the level of access to share with the agent user. If you share signing access, the agent user will receive an email notification.

To call this endpoint:
* You must be an account administrator or you must be the principal user.
* The agent user and principal user must belong to the same account.
* At least one of the following account settings must be enabled: `AllowDelegatedSigning`, `AllowManagingEnvelopesOnBehalfOfOthers`, `AllowEditingEnvelopesOnBehalfOfOthers`, `AllowSendingEnvelopesOnBehalfOfOthers`. These settings correspond to the level of access you can set for the authorization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The ID of the principal user.
 @return ApiUserAuthorizationCreateUserAuthorizationRequest
*/
func (a *AuthorizationsAPIService) UserAuthorizationCreateUserAuthorization(ctx context.Context, accountId string, userId string) ApiUserAuthorizationCreateUserAuthorizationRequest {
	return ApiUserAuthorizationCreateUserAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserAuthorization
func (a *AuthorizationsAPIService) UserAuthorizationCreateUserAuthorizationExecute(r ApiUserAuthorizationCreateUserAuthorizationRequest) (*UserAuthorization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationsAPIService.UserAuthorizationCreateUserAuthorization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/authorization"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userAuthorizationCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserAuthorizationDeleteUserAuthorizationRequest struct {
	ctx context.Context
	ApiService *AuthorizationsAPIService
	accountId string
	authorizationId string
	userId string
}

func (r ApiUserAuthorizationDeleteUserAuthorizationRequest) Execute() (*http.Response, error) {
	return r.ApiService.UserAuthorizationDeleteUserAuthorizationExecute(r)
}

/*
UserAuthorizationDeleteUserAuthorization Deletes the user authorization. 

Deletes the user authorization specified by the `authorizationId`.

To call this endpoint, you must be an account administrator or you must be the principal user for the specified authorization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param authorizationId The ID of the user authorization.
 @param userId The ID of the principal user.
 @return ApiUserAuthorizationDeleteUserAuthorizationRequest
*/
func (a *AuthorizationsAPIService) UserAuthorizationDeleteUserAuthorization(ctx context.Context, accountId string, authorizationId string, userId string) ApiUserAuthorizationDeleteUserAuthorizationRequest {
	return ApiUserAuthorizationDeleteUserAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		authorizationId: authorizationId,
		userId: userId,
	}
}

// Execute executes the request
func (a *AuthorizationsAPIService) UserAuthorizationDeleteUserAuthorizationExecute(r ApiUserAuthorizationDeleteUserAuthorizationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationsAPIService.UserAuthorizationDeleteUserAuthorization")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/authorization/{authorizationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorizationId"+"}", url.PathEscape(parameterValueToString(r.authorizationId, "authorizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserAuthorizationGetUserAuthorizationRequest struct {
	ctx context.Context
	ApiService *AuthorizationsAPIService
	accountId string
	authorizationId string
	userId string
}

func (r ApiUserAuthorizationGetUserAuthorizationRequest) Execute() (*UserAuthorization, *http.Response, error) {
	return r.ApiService.UserAuthorizationGetUserAuthorizationExecute(r)
}

/*
UserAuthorizationGetUserAuthorization Returns the user authorization for a given authorization ID. 

Returns the details for the user authorization specified by the `authorizationId`.

To call this endpoint, you must be an account administrator or you must be the principal user for the specified authorization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param authorizationId The ID of the user authorization.
 @param userId The ID of the principal user.
 @return ApiUserAuthorizationGetUserAuthorizationRequest
*/
func (a *AuthorizationsAPIService) UserAuthorizationGetUserAuthorization(ctx context.Context, accountId string, authorizationId string, userId string) ApiUserAuthorizationGetUserAuthorizationRequest {
	return ApiUserAuthorizationGetUserAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		authorizationId: authorizationId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserAuthorization
func (a *AuthorizationsAPIService) UserAuthorizationGetUserAuthorizationExecute(r ApiUserAuthorizationGetUserAuthorizationRequest) (*UserAuthorization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationsAPIService.UserAuthorizationGetUserAuthorization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/authorization/{authorizationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorizationId"+"}", url.PathEscape(parameterValueToString(r.authorizationId, "authorizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserAuthorizationUpdateUserAuthorizationRequest struct {
	ctx context.Context
	ApiService *AuthorizationsAPIService
	accountId string
	authorizationId string
	userId string
	userAuthorizationUpdateRequest *UserAuthorizationUpdateRequest
}

func (r ApiUserAuthorizationUpdateUserAuthorizationRequest) UserAuthorizationUpdateRequest(userAuthorizationUpdateRequest UserAuthorizationUpdateRequest) ApiUserAuthorizationUpdateUserAuthorizationRequest {
	r.userAuthorizationUpdateRequest = &userAuthorizationUpdateRequest
	return r
}

func (r ApiUserAuthorizationUpdateUserAuthorizationRequest) Execute() (*UserAuthorization, *http.Response, error) {
	return r.ApiService.UserAuthorizationUpdateUserAuthorizationExecute(r)
}

/*
UserAuthorizationUpdateUserAuthorization Updates the start or end date for a user authorization.

Updates the start and/or end date for a given user authorization. Specify the user authorization and principal user with the path parameters.

To call this endpoint, you must be an account administrator or you must be the principal user for the specified authorization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param authorizationId The ID of the user authorization.
 @param userId The ID of the principal user.
 @return ApiUserAuthorizationUpdateUserAuthorizationRequest
*/
func (a *AuthorizationsAPIService) UserAuthorizationUpdateUserAuthorization(ctx context.Context, accountId string, authorizationId string, userId string) ApiUserAuthorizationUpdateUserAuthorizationRequest {
	return ApiUserAuthorizationUpdateUserAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		authorizationId: authorizationId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserAuthorization
func (a *AuthorizationsAPIService) UserAuthorizationUpdateUserAuthorizationExecute(r ApiUserAuthorizationUpdateUserAuthorizationRequest) (*UserAuthorization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationsAPIService.UserAuthorizationUpdateUserAuthorization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/authorization/{authorizationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorizationId"+"}", url.PathEscape(parameterValueToString(r.authorizationId, "authorizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userAuthorizationUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserAuthorizationsDeleteUserAuthorizationsRequest struct {
	ctx context.Context
	ApiService *AuthorizationsAPIService
	accountId string
	userId string
	userAuthorizationsDeleteRequest *UserAuthorizationsDeleteRequest
}

func (r ApiUserAuthorizationsDeleteUserAuthorizationsRequest) UserAuthorizationsDeleteRequest(userAuthorizationsDeleteRequest UserAuthorizationsDeleteRequest) ApiUserAuthorizationsDeleteUserAuthorizationsRequest {
	r.userAuthorizationsDeleteRequest = &userAuthorizationsDeleteRequest
	return r
}

func (r ApiUserAuthorizationsDeleteUserAuthorizationsRequest) Execute() (*UserAuthorizationsDeleteResponse, *http.Response, error) {
	return r.ApiService.UserAuthorizationsDeleteUserAuthorizationsExecute(r)
}

/*
UserAuthorizationsDeleteUserAuthorizations Delete multiple user authorizations.

Delete one or more user authorizations for a given principal user. The principal user is specified by the `userId` path parameter.

To call this endpoint, you must be an account administrator or you must be the principal user for the specified authorizations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The ID of the principal user.
 @return ApiUserAuthorizationsDeleteUserAuthorizationsRequest
*/
func (a *AuthorizationsAPIService) UserAuthorizationsDeleteUserAuthorizations(ctx context.Context, accountId string, userId string) ApiUserAuthorizationsDeleteUserAuthorizationsRequest {
	return ApiUserAuthorizationsDeleteUserAuthorizationsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserAuthorizationsDeleteResponse
func (a *AuthorizationsAPIService) UserAuthorizationsDeleteUserAuthorizationsExecute(r ApiUserAuthorizationsDeleteUserAuthorizationsRequest) (*UserAuthorizationsDeleteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserAuthorizationsDeleteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationsAPIService.UserAuthorizationsDeleteUserAuthorizations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/authorizations"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userAuthorizationsDeleteRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest struct {
	ctx context.Context
	ApiService *AuthorizationsAPIService
	accountId string
	userId string
	activeOnly *string
	count *string
	emailSubstring *string
	includeClosedUsers *string
	permissions *string
	startPosition *string
	userNameSubstring *string
}

// When **true,** return only active authorizations. The default value is **true.**
func (r ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest) ActiveOnly(activeOnly string) ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest {
	r.activeOnly = &activeOnly
	return r
}

// The maximum number of results to return.
func (r ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest) Count(count string) ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest {
	r.count = &count
	return r
}

// Filters returned user records by full email address or a substring of email address.
func (r ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest) EmailSubstring(emailSubstring string) ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest {
	r.emailSubstring = &emailSubstring
	return r
}

// When **true,** returns active and scheduled authorizations of closed users. The default value is **true.** This value is only applied when &#x60;active_only&#x60; is **false.**
func (r ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest) IncludeClosedUsers(includeClosedUsers string) ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest {
	r.includeClosedUsers = &includeClosedUsers
	return r
}

// Filters results by authorization permission. Valid values: * &#x60;Send&#x60; * &#x60;Manage&#x60; * &#x60;Sign&#x60;
func (r ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest) Permissions(permissions string) ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest {
	r.permissions = &permissions
	return r
}

// The position within the total result set from which to start returning values. The value **thumbnail** may be used to return the page image.
func (r ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest) StartPosition(startPosition string) ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest {
	r.startPosition = &startPosition
	return r
}

// Filters results based on a full or partial user name.  **Note:** When you enter a partial user name, you do not use a wildcard character.
func (r ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest) UserNameSubstring(userNameSubstring string) ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest {
	r.userNameSubstring = &userNameSubstring
	return r
}

func (r ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest) Execute() (*UserAuthorizations, *http.Response, error) {
	return r.ApiService.UserAuthorizationsGetPrincipalUserAuthorizationsExecute(r)
}

/*
UserAuthorizationsGetPrincipalUserAuthorizations Returns the authorizations for which the specified user is the principal user.

Returns the user authorizations for which the user specified by `userId` is the principal user.

To call this endpoint, you must be an account administrator or you must be the specified principal user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The ID of the principal user.
 @return ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest
*/
func (a *AuthorizationsAPIService) UserAuthorizationsGetPrincipalUserAuthorizations(ctx context.Context, accountId string, userId string) ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest {
	return ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserAuthorizations
func (a *AuthorizationsAPIService) UserAuthorizationsGetPrincipalUserAuthorizationsExecute(r ApiUserAuthorizationsGetPrincipalUserAuthorizationsRequest) (*UserAuthorizations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserAuthorizations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationsAPIService.UserAuthorizationsGetPrincipalUserAuthorizations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/authorizations"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_only", r.activeOnly, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.emailSubstring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email_substring", r.emailSubstring, "")
	}
	if r.includeClosedUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_closed_users", r.includeClosedUsers, "")
	}
	if r.permissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissions", r.permissions, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	if r.userNameSubstring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_name_substring", r.userNameSubstring, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserAuthorizationsPostUserAuthorizationsRequest struct {
	ctx context.Context
	ApiService *AuthorizationsAPIService
	accountId string
	userId string
	userAuthorizationsRequest *UserAuthorizationsRequest
}

func (r ApiUserAuthorizationsPostUserAuthorizationsRequest) UserAuthorizationsRequest(userAuthorizationsRequest UserAuthorizationsRequest) ApiUserAuthorizationsPostUserAuthorizationsRequest {
	r.userAuthorizationsRequest = &userAuthorizationsRequest
	return r
}

func (r ApiUserAuthorizationsPostUserAuthorizationsRequest) Execute() (*UserAuthorizationsResponse, *http.Response, error) {
	return r.ApiService.UserAuthorizationsPostUserAuthorizationsExecute(r)
}

/*
UserAuthorizationsPostUserAuthorizations Create or update multiple user authorizations.

Create or update multiple user authorizations in a single request. The body of the request is a list of userAuthorizationSomething objects. To create a new authorization, specify the `agentUser` and `permission` fields, with the optional `startDate` and `endDate` fields. To update an existing authorization, specify the `authorizationId` field and the `startDate` and/or `endDate` fields.

For example, to create a new authorization and update the end date of an existing authorization, your request body might look like this:

```
{
  "authorizations": [
    {
      "agentUser": {
        "userId": "1470ff66-xxxx-xxxx-xxxx-8c46f140da37",
        "accountId": "230546a7-xxxx-xxxx-xxxx-af205d5494ad"
      },
      "permission": "manage"
    },
    {
      "authorizationId": "b73ac983-xxxx-xxxx-xxxx-b3c0ea5b09d3",
      "endDate": "2023-05-09T21:36:27.0000000+00:00"
    }
  ]
}
```

The principal user is specified by the `userId` path parameter. To call this endpoint, you must be an account administrator or the principal user.

**Note:** To create an authorization with signing permission, the `AllowDelegationSigning` setting must be enabled on the account. If you share signing access, the agent user will receive an email notification. Each principal user can only share signing permission with one agent user.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param userId The ID of the principal user.
 @return ApiUserAuthorizationsPostUserAuthorizationsRequest
*/
func (a *AuthorizationsAPIService) UserAuthorizationsPostUserAuthorizations(ctx context.Context, accountId string, userId string) ApiUserAuthorizationsPostUserAuthorizationsRequest {
	return ApiUserAuthorizationsPostUserAuthorizationsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserAuthorizationsResponse
func (a *AuthorizationsAPIService) UserAuthorizationsPostUserAuthorizationsExecute(r ApiUserAuthorizationsPostUserAuthorizationsRequest) (*UserAuthorizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserAuthorizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationsAPIService.UserAuthorizationsPostUserAuthorizations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/users/{userId}/authorizations"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userAuthorizationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
