/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// EnvelopeDocumentsAPIService EnvelopeDocumentsAPI service
type EnvelopeDocumentsAPIService service

type ApiDocumentsDeleteDocumentsRequest struct {
	ctx context.Context
	ApiService *EnvelopeDocumentsAPIService
	accountId string
	envelopeId string
	envelopeDefinition *EnvelopeDefinition
}

func (r ApiDocumentsDeleteDocumentsRequest) EnvelopeDefinition(envelopeDefinition EnvelopeDefinition) ApiDocumentsDeleteDocumentsRequest {
	r.envelopeDefinition = &envelopeDefinition
	return r
}

func (r ApiDocumentsDeleteDocumentsRequest) Execute() (*EnvelopeDocumentsResult, *http.Response, error) {
	return r.ApiService.DocumentsDeleteDocumentsExecute(r)
}

/*
DocumentsDeleteDocuments Deletes documents from a draft envelope.

Deletes one or more documents from an existing envelope that has not yet been completed.

To delete a document, use only the relevant parts of the [`envelopeDefinition`](#envelopeDefinition).
For example, this request body specifies that you want to delete the document whose `documentId` is "1".


```text
{
  "documents": [
    {
      "documentId": "1"
    }
  ]
}
```

The envelope status must be one of:

- `created`
- `sent`
- `delivered`




 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiDocumentsDeleteDocumentsRequest
*/
func (a *EnvelopeDocumentsAPIService) DocumentsDeleteDocuments(ctx context.Context, accountId string, envelopeId string) ApiDocumentsDeleteDocumentsRequest {
	return ApiDocumentsDeleteDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return EnvelopeDocumentsResult
func (a *EnvelopeDocumentsAPIService) DocumentsDeleteDocumentsExecute(r ApiDocumentsDeleteDocumentsRequest) (*EnvelopeDocumentsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeDocumentsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeDocumentsAPIService.DocumentsDeleteDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsGetDocumentRequest struct {
	ctx context.Context
	ApiService *EnvelopeDocumentsAPIService
	accountId string
	documentId string
	envelopeId string
	certificate *string
	documentsByUserid *string
	encoding *string
	encrypt *string
	language *string
	recipientId *string
	sharedUserId *string
	showChanges *string
	watermark *string
}

// Used only when the &#x60;documentId&#x60; parameter is the special keyword &#x60;combined&#x60;.  When **true,** the certificate of completion is included in the combined PDF file. When **false,** (the default) the certificate of completion is not included in the combined PDF file.  
func (r ApiDocumentsGetDocumentRequest) Certificate(certificate string) ApiDocumentsGetDocumentRequest {
	r.certificate = &certificate
	return r
}

// When **true,** allows recipients to get documents by their user id. For example, if a user is included in two different routing orders with different visibilities, using this parameter returns all of the documents from both routing orders.
func (r ApiDocumentsGetDocumentRequest) DocumentsByUserid(documentsByUserid string) ApiDocumentsGetDocumentRequest {
	r.documentsByUserid = &documentsByUserid
	return r
}

// Reserved for DocuSign.
func (r ApiDocumentsGetDocumentRequest) Encoding(encoding string) ApiDocumentsGetDocumentRequest {
	r.encoding = &encoding
	return r
}

// When **true,** the PDF bytes returned in the response are encrypted for all the key managers configured on your DocuSign account. You can decrypt the documents by using the Key Manager DecryptDocument API method. For more information about Key Manager, see the DocuSign Security Appliance Installation Guide that your organization received from DocuSign.
func (r ApiDocumentsGetDocumentRequest) Encrypt(encrypt string) ApiDocumentsGetDocumentRequest {
	r.encrypt = &encrypt
	return r
}

// Specifies the language for the Certificate of Completion in the response. The supported languages are: Chinese Simplified (zh_CN), Chinese Traditional (zh_TW), Dutch (nl), English US (en), French (fr), German (de), Italian (it), Japanese (ja), Korean (ko), Portuguese (pt), Portuguese (Brazil) (pt_BR), Russian (ru), Spanish (es). 
func (r ApiDocumentsGetDocumentRequest) Language(language string) ApiDocumentsGetDocumentRequest {
	r.language = &language
	return r
}

// Allows the sender to retrieve the documents as one of the recipients that they control. The &#x60;documents_by_userid&#x60; parameter must be set to **false** for this functionality to work.
func (r ApiDocumentsGetDocumentRequest) RecipientId(recipientId string) ApiDocumentsGetDocumentRequest {
	r.recipientId = &recipientId
	return r
}

// The ID of a shared user that you want to impersonate in order to retrieve their view of the list of documents. This parameter is used in the context of a shared inbox (i.e., when you share envelopes from one user to another through the DocuSign Admin console).
func (r ApiDocumentsGetDocumentRequest) SharedUserId(sharedUserId string) ApiDocumentsGetDocumentRequest {
	r.sharedUserId = &sharedUserId
	return r
}

// When **true,** any changed fields for the returned PDF are highlighted in yellow and optional signatures or initials outlined in red. The account must have the **Highlight Data Changes** feature enabled.
func (r ApiDocumentsGetDocumentRequest) ShowChanges(showChanges string) ApiDocumentsGetDocumentRequest {
	r.showChanges = &showChanges
	return r
}

// When **true,** the account has the watermark feature enabled, and the envelope is not complete, then the watermark for the account is added to the PDF documents. This option can remove the watermark. 
func (r ApiDocumentsGetDocumentRequest) Watermark(watermark string) ApiDocumentsGetDocumentRequest {
	r.watermark = &watermark
	return r
}

func (r ApiDocumentsGetDocumentRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DocumentsGetDocumentExecute(r)
}

/*
DocumentsGetDocument Retrieves a single document or all documents from an envelope.

Retrieves a single document or all documents from an envelope.

To retrieve a single document, provide the ID of the document in the `documentId` path parameter.
Alternatively, by setting the `documentId` parameter to special keyword values,
you can retrieve all the documents (as a combined PDF, portfolio PDF, or ZIP archive)
or just the certificate of completion. See the `documentId` description for how to retrieve each format.


The response body of this method
is a file. If you request multiple documents,
the result is a ZIP archive
that contains all of the documents.

In all other cases, the response is a PDF
file or PDF portfolio.


You can get the file name and document ID from the response's `Content-Disposition` header:

```
Content-Disposition: file; filename="NDA.pdf"; documentid="1
```

By default, the response is the PDF file
as a byte stream.
For example a request/response in `curl` looks like this:

```
$ curl --request GET 'https://demo.docusign.net/restapi/v2/accounts/0cdb3ff3-xxxx-xxxx-xxxx-e43af011006d/envelopes/ea4cc25b-xxxx-xxxx-xxxx-a67a0a2a4f6c/documents/1/' \
       --header 'Authorization: Bearer eyJ...bqg'


HTTP/1.1 200 OK
Content-Length: 167539
Content-Type: application/pdf
. . .
Content-Disposition: file; filename="Lorem_Ipsum.pdf"; documentid="1"
Date: Tue, 23 Aug 2022 01:13:15 GMT

%PDF-1.4
%˚¸˝˛
6 0 obj
<</Length 14>>stream
. . .
```

By using the `Content-Transfer-Encoding`
header in the request, you can obtain the PDF file
encoded in base64. The same `curl` request with
the base64 header would look like this:

```
$ curl --request GET 'https://demo.docusign.net/restapi/v2/accounts/0cdb3ff3-xxxx-xxxx-xxxx-e43af011006d/envelopes/ea4cc25b-xxxx-xxxx-xxxx-a67a0a2a4f6c/documents/1/' \
       --header 'Authorization: Bearer eyJ...bqg' \
       --header 'Content-Transfer-Encoding: base64'


HTTP/1.1 200 OK
Content-Length: 223384
Content-Type: application/pdf
. . .
Content-Disposition: file; filename="Lorem_Ipsum.pdf"; documentid="1"
Content-Transfer-Encoding: base64
Date: Tue, 23 Aug 2022 01:12:30 GMT

JVBERi0xLjQKJfv8/f4KNiAwIG9iago8PC9MZW. . .==
```


(In an actual `curl` request you would use the `--output` switch to
save the byte stream into a file.)

### Related topics

- [How to download envelope documents](/docs/esign-rest-api/how-to/download-envelope-documents/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param documentId The ID of the document to retrieve. Alternatively, you can use one of the following special keywords:  - `combined`: Retrieves all of the documents as a single PDF file.   When the query parameter `certificate` is **true,** the certificate of completion is included in the PDF file.   When the query parameter `certificate` is **false,** the certificate of completion is not included in the PDF file. - `archive`: Retrieves a ZIP archive that contains all of the PDF documents and the certificate of completion. - `certificate`: Retrieves only the certificate of completion as a PDF file. - `portfolio`: Retrieves the envelope documents as a [PDF portfolio](https://helpx.adobe.com/acrobat/using/overview-pdf-portfolios.html).
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiDocumentsGetDocumentRequest
*/
func (a *EnvelopeDocumentsAPIService) DocumentsGetDocument(ctx context.Context, accountId string, documentId string, envelopeId string) ApiDocumentsGetDocumentRequest {
	return ApiDocumentsGetDocumentRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		documentId: documentId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *EnvelopeDocumentsAPIService) DocumentsGetDocumentExecute(r ApiDocumentsGetDocumentRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeDocumentsAPIService.DocumentsGetDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/documents/{documentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.certificate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "certificate", r.certificate, "")
	}
	if r.documentsByUserid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "documents_by_userid", r.documentsByUserid, "")
	}
	if r.encoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encoding", r.encoding, "")
	}
	if r.encrypt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encrypt", r.encrypt, "")
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	if r.recipientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recipient_id", r.recipientId, "")
	}
	if r.sharedUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shared_user_id", r.sharedUserId, "")
	}
	if r.showChanges != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_changes", r.showChanges, "")
	}
	if r.watermark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "watermark", r.watermark, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsGetDocumentsRequest struct {
	ctx context.Context
	ApiService *EnvelopeDocumentsAPIService
	accountId string
	envelopeId string
	documentsByUserid *string
	includeDocgenFormfields *string
	includeMetadata *string
	includeTabs *string
	recipientId *string
	sharedUserId *string
}

// When **true,** allows recipients to get documents by their user id. For example, if a user is included in two different routing orders with different visibilities, using this parameter returns all of the documents from both routing orders.
func (r ApiDocumentsGetDocumentsRequest) DocumentsByUserid(documentsByUserid string) ApiDocumentsGetDocumentsRequest {
	r.documentsByUserid = &documentsByUserid
	return r
}

// Reserved for DocuSign.
func (r ApiDocumentsGetDocumentsRequest) IncludeDocgenFormfields(includeDocgenFormfields string) ApiDocumentsGetDocumentsRequest {
	r.includeDocgenFormfields = &includeDocgenFormfields
	return r
}

// When **true,** the response includes metadata that indicates which properties the sender can edit.
func (r ApiDocumentsGetDocumentsRequest) IncludeMetadata(includeMetadata string) ApiDocumentsGetDocumentsRequest {
	r.includeMetadata = &includeMetadata
	return r
}

// When **true,** information about the tabs, including prefill tabs, associated with the documents are included in the response.
func (r ApiDocumentsGetDocumentsRequest) IncludeTabs(includeTabs string) ApiDocumentsGetDocumentsRequest {
	r.includeTabs = &includeTabs
	return r
}

// Allows the sender to retrieve the documents as one of the recipients that they control. The &#x60;documents_by_userid&#x60; parameter must be set to **false** for this to work.
func (r ApiDocumentsGetDocumentsRequest) RecipientId(recipientId string) ApiDocumentsGetDocumentsRequest {
	r.recipientId = &recipientId
	return r
}

// The ID of a shared user that you want to impersonate in order to retrieve their view of the list of documents. This parameter is used in the context of a shared inbox (i.e., when you share envelopes from one user to another through the DocuSign Admin console).
func (r ApiDocumentsGetDocumentsRequest) SharedUserId(sharedUserId string) ApiDocumentsGetDocumentsRequest {
	r.sharedUserId = &sharedUserId
	return r
}

func (r ApiDocumentsGetDocumentsRequest) Execute() (*EnvelopeDocumentsResult, *http.Response, error) {
	return r.ApiService.DocumentsGetDocumentsExecute(r)
}

/*
DocumentsGetDocuments Gets a list of documents in an envelope.

Retrieves a list of documents associated with the specified envelope.

### Related topics

- [How to list envelope documents](/docs/esign-rest-api/how-to/list-envelope-documents/)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiDocumentsGetDocumentsRequest
*/
func (a *EnvelopeDocumentsAPIService) DocumentsGetDocuments(ctx context.Context, accountId string, envelopeId string) ApiDocumentsGetDocumentsRequest {
	return ApiDocumentsGetDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return EnvelopeDocumentsResult
func (a *EnvelopeDocumentsAPIService) DocumentsGetDocumentsExecute(r ApiDocumentsGetDocumentsRequest) (*EnvelopeDocumentsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeDocumentsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeDocumentsAPIService.DocumentsGetDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.documentsByUserid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "documents_by_userid", r.documentsByUserid, "")
	}
	if r.includeDocgenFormfields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_docgen_formfields", r.includeDocgenFormfields, "")
	}
	if r.includeMetadata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_metadata", r.includeMetadata, "")
	}
	if r.includeTabs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_tabs", r.includeTabs, "")
	}
	if r.recipientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recipient_id", r.recipientId, "")
	}
	if r.sharedUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shared_user_id", r.sharedUserId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsPutDocumentRequest struct {
	ctx context.Context
	ApiService *EnvelopeDocumentsAPIService
	accountId string
	documentId string
	envelopeId string
	documentFileBytes *os.File
}

// Updated document content.
func (r ApiDocumentsPutDocumentRequest) DocumentFileBytes(documentFileBytes *os.File) ApiDocumentsPutDocumentRequest {
	r.documentFileBytes = documentFileBytes
	return r
}

func (r ApiDocumentsPutDocumentRequest) Execute() (*EnvelopeDocument, *http.Response, error) {
	return r.ApiService.DocumentsPutDocumentExecute(r)
}

/*
DocumentsPutDocument Adds or replaces a document in an existing envelope.

Adds or replaces a document in an existing draft or in-process envelope.
An in-process envelope is one that has been sent but not yet completed or voided.


**Note:** When adding or modifying documents for an in-process envelope,
DocuSign recommends
[locking the envelope](/docs/esign-rest-api/reference/envelopes/envelopelocks/create/)
prior to making any changes.

To add a new document, set the `documentId` path parameter to a new document ID.

To replace a document, set the `documentId` path parameter to the document ID of the existing document.
The tabs of the original document will be applied to the new document.
For example, a request in cURL looks like this:

```
$ curl --location --request PUT 'https://demo.docusign.net/restapi/v2.1/accounts/0cdb3ff3-xxxx-xxxx-xxxx-e43af011006d/envelopes/ea4cc25b-xxxx-xxxx-xxxx-a67a0a2a4f6c/documents/1' \
    --header 'Authorization: Bearer eyJ...bqg' \
    --header 'Content-Disposition: filename="newDocument"' \
    --header 'Content-Type: application/pdf' \
    --data-binary '@/location/of/document.pdf'
```


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param documentId The unique ID of the document within the envelope.  Unlike other IDs in the eSignature API, you specify the `documentId` yourself. Typically the first document has the ID `1`, the second document `2`, and so on, but you can use any numbering scheme that fits within a 32-bit signed integer (1 through 2147483647).   Tab objects have a `documentId` property that specifies the document on which to place the tab. 
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiDocumentsPutDocumentRequest
*/
func (a *EnvelopeDocumentsAPIService) DocumentsPutDocument(ctx context.Context, accountId string, documentId string, envelopeId string) ApiDocumentsPutDocumentRequest {
	return ApiDocumentsPutDocumentRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		documentId: documentId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return EnvelopeDocument
func (a *EnvelopeDocumentsAPIService) DocumentsPutDocumentExecute(r ApiDocumentsPutDocumentRequest) (*EnvelopeDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeDocumentsAPIService.DocumentsPutDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/documents/{documentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.documentFileBytes == nil {
		return localVarReturnValue, nil, reportError("documentFileBytes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/pdf"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.documentFileBytes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsPutDocumentsRequest struct {
	ctx context.Context
	ApiService *EnvelopeDocumentsAPIService
	accountId string
	envelopeId string
	envelopeDefinition *EnvelopeDefinition
}

func (r ApiDocumentsPutDocumentsRequest) EnvelopeDefinition(envelopeDefinition EnvelopeDefinition) ApiDocumentsPutDocumentsRequest {
	r.envelopeDefinition = &envelopeDefinition
	return r
}

func (r ApiDocumentsPutDocumentsRequest) Execute() (*EnvelopeDocumentsResult, *http.Response, error) {
	return r.ApiService.DocumentsPutDocumentsExecute(r)
}

/*
DocumentsPutDocuments Adds one or more documents to an existing envelope.

Adds one or more documents to an existing envelope.
The tabs of the original document will be applied to the new document.


**Note:** When adding or modifying documents for an in-process envelope,
DocuSign recommends
[locking the envelope](/docs/esign-rest-api/reference/envelopes/envelopelocks/create/)
prior to making any changes.

If the file name of a document contains Unicode characters, you need to include a `Content-Disposition` header. Example:


**Header:** `Content-Disposition`


**Value:** `file; filename=\"name\";fileExtension=ext;documentId=1`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiDocumentsPutDocumentsRequest
*/
func (a *EnvelopeDocumentsAPIService) DocumentsPutDocuments(ctx context.Context, accountId string, envelopeId string) ApiDocumentsPutDocumentsRequest {
	return ApiDocumentsPutDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return EnvelopeDocumentsResult
func (a *EnvelopeDocumentsAPIService) DocumentsPutDocumentsExecute(r ApiDocumentsPutDocumentsRequest) (*EnvelopeDocumentsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeDocumentsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeDocumentsAPIService.DocumentsPutDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
