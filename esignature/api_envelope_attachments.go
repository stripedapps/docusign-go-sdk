/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// EnvelopeAttachmentsAPIService EnvelopeAttachmentsAPI service
type EnvelopeAttachmentsAPIService service

type ApiAttachmentsDeleteAttachmentsRequest struct {
	ctx context.Context
	ApiService *EnvelopeAttachmentsAPIService
	accountId string
	envelopeId string
	envelopeAttachmentsRequest *EnvelopeAttachmentsRequest
}

func (r ApiAttachmentsDeleteAttachmentsRequest) EnvelopeAttachmentsRequest(envelopeAttachmentsRequest EnvelopeAttachmentsRequest) ApiAttachmentsDeleteAttachmentsRequest {
	r.envelopeAttachmentsRequest = &envelopeAttachmentsRequest
	return r
}

func (r ApiAttachmentsDeleteAttachmentsRequest) Execute() (*EnvelopeAttachmentsResult, *http.Response, error) {
	return r.ApiService.AttachmentsDeleteAttachmentsExecute(r)
}

/*
AttachmentsDeleteAttachments Deletes one or more envelope attachments from a draft envelope.

Deletes one or more envelope attachments from a draft envelope.

<!-- std notice DEVDOCS-114911 -->
<ds-inlinemessage kind="information" markdown="1">

It's easy to confuse envelope attachments,
which are developer-only files associated with an envelope,
with signer attachments.

To learn about the different types of attachments, see [Attachments](/docs/esign-rest-api/esign101/concepts/documents/attachments/) in the concept guide.

</ds-inlinemessage>
<!-- end notice DEVDOCS-114911 -->


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiAttachmentsDeleteAttachmentsRequest
*/
func (a *EnvelopeAttachmentsAPIService) AttachmentsDeleteAttachments(ctx context.Context, accountId string, envelopeId string) ApiAttachmentsDeleteAttachmentsRequest {
	return ApiAttachmentsDeleteAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return EnvelopeAttachmentsResult
func (a *EnvelopeAttachmentsAPIService) AttachmentsDeleteAttachmentsExecute(r ApiAttachmentsDeleteAttachmentsRequest) (*EnvelopeAttachmentsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeAttachmentsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeAttachmentsAPIService.AttachmentsDeleteAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeAttachmentsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttachmentsGetAttachmentRequest struct {
	ctx context.Context
	ApiService *EnvelopeAttachmentsAPIService
	accountId string
	attachmentId string
	envelopeId string
}

func (r ApiAttachmentsGetAttachmentRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.AttachmentsGetAttachmentExecute(r)
}

/*
AttachmentsGetAttachment Retrieves an envelope attachment from an envelope.

Retrieves an envelope attachment from an envelope.

<!-- std notice DEVDOCS-114911 -->
<ds-inlinemessage kind="information" markdown="1">

It's easy to confuse envelope attachments,
which are developer-only files associated with an envelope,
with signer attachments.

To learn about the different types of attachments, see [Attachments](/docs/esign-rest-api/esign101/concepts/documents/attachments/) in the concept guide.

</ds-inlinemessage>
<!-- end notice DEVDOCS-114911 -->


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param attachmentId The unique identifier for the attachment.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiAttachmentsGetAttachmentRequest
*/
func (a *EnvelopeAttachmentsAPIService) AttachmentsGetAttachment(ctx context.Context, accountId string, attachmentId string, envelopeId string) ApiAttachmentsGetAttachmentRequest {
	return ApiAttachmentsGetAttachmentRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		attachmentId: attachmentId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *EnvelopeAttachmentsAPIService) AttachmentsGetAttachmentExecute(r ApiAttachmentsGetAttachmentRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeAttachmentsAPIService.AttachmentsGetAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/attachments/{attachmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttachmentsGetAttachmentsRequest struct {
	ctx context.Context
	ApiService *EnvelopeAttachmentsAPIService
	accountId string
	envelopeId string
}

func (r ApiAttachmentsGetAttachmentsRequest) Execute() (*EnvelopeAttachmentsResult, *http.Response, error) {
	return r.ApiService.AttachmentsGetAttachmentsExecute(r)
}

/*
AttachmentsGetAttachments Returns a list of envelope attachments associated with a specified envelope.

Returns a list of envelope attachments associated with a specified envelope.

<!-- std notice DEVDOCS-114911 -->
<ds-inlinemessage kind="information" markdown="1">

It's easy to confuse envelope attachments,
which are developer-only files associated with an envelope,
with signer attachments.

To get a list of user-visible attachments,
use [EnvelopeDocuments: get](/docs/esign-rest-api/reference/envelopes/envelopedocuments/get/).

To learn about the different types of attachments, see [Attachments](/docs/esign-rest-api/esign101/concepts/documents/attachments/) in the concept guide.

</ds-inlinemessage>
<!-- end notice DEVDOCS-114911 -->


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiAttachmentsGetAttachmentsRequest
*/
func (a *EnvelopeAttachmentsAPIService) AttachmentsGetAttachments(ctx context.Context, accountId string, envelopeId string) ApiAttachmentsGetAttachmentsRequest {
	return ApiAttachmentsGetAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return EnvelopeAttachmentsResult
func (a *EnvelopeAttachmentsAPIService) AttachmentsGetAttachmentsExecute(r ApiAttachmentsGetAttachmentsRequest) (*EnvelopeAttachmentsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeAttachmentsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeAttachmentsAPIService.AttachmentsGetAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttachmentsPutAttachmentRequest struct {
	ctx context.Context
	ApiService *EnvelopeAttachmentsAPIService
	accountId string
	attachmentId string
	envelopeId string
	attachment *Attachment
}

func (r ApiAttachmentsPutAttachmentRequest) Attachment(attachment Attachment) ApiAttachmentsPutAttachmentRequest {
	r.attachment = &attachment
	return r
}

func (r ApiAttachmentsPutAttachmentRequest) Execute() (*EnvelopeAttachmentsResult, *http.Response, error) {
	return r.ApiService.AttachmentsPutAttachmentExecute(r)
}

/*
AttachmentsPutAttachment Updates an envelope attachment in a draft or in-process envelope.

Updates an envelope attachment to a draft or in-process envelope.

<!-- std notice DEVDOCS-114911 -->
<ds-inlinemessage kind="information" markdown="1">

It's easy to confuse envelope attachments,
which are developer-only files associated with an envelope,
with signer attachments.

To learn about the different types of attachments, see [Attachments](/docs/esign-rest-api/esign101/concepts/documents/attachments/) in the concept guide.

</ds-inlinemessage>
<!-- end notice DEVDOCS-114911 -->


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param attachmentId The unique identifier for the attachment.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiAttachmentsPutAttachmentRequest
*/
func (a *EnvelopeAttachmentsAPIService) AttachmentsPutAttachment(ctx context.Context, accountId string, attachmentId string, envelopeId string) ApiAttachmentsPutAttachmentRequest {
	return ApiAttachmentsPutAttachmentRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		attachmentId: attachmentId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return EnvelopeAttachmentsResult
func (a *EnvelopeAttachmentsAPIService) AttachmentsPutAttachmentExecute(r ApiAttachmentsPutAttachmentRequest) (*EnvelopeAttachmentsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeAttachmentsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeAttachmentsAPIService.AttachmentsPutAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/attachments/{attachmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attachment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttachmentsPutAttachmentsRequest struct {
	ctx context.Context
	ApiService *EnvelopeAttachmentsAPIService
	accountId string
	envelopeId string
	envelopeAttachmentsRequest *EnvelopeAttachmentsRequest
}

func (r ApiAttachmentsPutAttachmentsRequest) EnvelopeAttachmentsRequest(envelopeAttachmentsRequest EnvelopeAttachmentsRequest) ApiAttachmentsPutAttachmentsRequest {
	r.envelopeAttachmentsRequest = &envelopeAttachmentsRequest
	return r
}

func (r ApiAttachmentsPutAttachmentsRequest) Execute() (*EnvelopeAttachmentsResult, *http.Response, error) {
	return r.ApiService.AttachmentsPutAttachmentsExecute(r)
}

/*
AttachmentsPutAttachments Adds one or more envelope attachments to a draft or in-process envelope.

Adds one or more envelope attachments to a draft or in-process envelope.
Each envelope can have a maximum of 12 attachments.

Envelope attachments are files that an application can include in an envelope. They are not converted to PDF. Envelope attachments are available only through the API. There is no user interface in the DocuSign web application for them.

For a list of supported file formats, see [Supported File Formats](https://support.docusign.com/s/document-item?bundleId=gbo1643332197980&topicId=xln1578456261162.html).

<!-- std notice DEVDOCS-114911 -->
<ds-inlinemessage kind="information" markdown="1">

It's easy to confuse envelope attachments,
which are developer-only files associated with an envelope,
with signer attachments.

To learn about the different types of attachments, see [Attachments](/docs/esign-rest-api/esign101/concepts/documents/attachments/) in the concept guide.

</ds-inlinemessage>
<!-- end notice DEVDOCS-114911 -->




 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param envelopeId The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec` 
 @return ApiAttachmentsPutAttachmentsRequest
*/
func (a *EnvelopeAttachmentsAPIService) AttachmentsPutAttachments(ctx context.Context, accountId string, envelopeId string) ApiAttachmentsPutAttachmentsRequest {
	return ApiAttachmentsPutAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		envelopeId: envelopeId,
	}
}

// Execute executes the request
//  @return EnvelopeAttachmentsResult
func (a *EnvelopeAttachmentsAPIService) AttachmentsPutAttachmentsExecute(r ApiAttachmentsPutAttachmentsRequest) (*EnvelopeAttachmentsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvelopeAttachmentsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvelopeAttachmentsAPIService.AttachmentsPutAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/envelopes/{envelopeId}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envelopeId"+"}", url.PathEscape(parameterValueToString(r.envelopeId, "envelopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.envelopeAttachmentsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
