/*
DocuSign REST API

The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// BCCEmailArchiveAPIService BCCEmailArchiveAPI service
type BCCEmailArchiveAPIService service

type ApiBCCEmailArchiveDeleteBCCEmailArchiveRequest struct {
	ctx context.Context
	ApiService *BCCEmailArchiveAPIService
	accountId string
	bccEmailArchiveId string
}

func (r ApiBCCEmailArchiveDeleteBCCEmailArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.BCCEmailArchiveDeleteBCCEmailArchiveExecute(r)
}

/*
BCCEmailArchiveDeleteBCCEmailArchive Deletes a BCC email archive configuration.

This method deletes a BCC email archive configuration from an account.

When you use this method, the status of the BCC email archive configuration switches to `closed` and the BCC email address is no longer used to archive DocuSign-generated email messages.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param bccEmailArchiveId The ID of the BCC email archive configuration.
 @return ApiBCCEmailArchiveDeleteBCCEmailArchiveRequest
*/
func (a *BCCEmailArchiveAPIService) BCCEmailArchiveDeleteBCCEmailArchive(ctx context.Context, accountId string, bccEmailArchiveId string) ApiBCCEmailArchiveDeleteBCCEmailArchiveRequest {
	return ApiBCCEmailArchiveDeleteBCCEmailArchiveRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		bccEmailArchiveId: bccEmailArchiveId,
	}
}

// Execute executes the request
func (a *BCCEmailArchiveAPIService) BCCEmailArchiveDeleteBCCEmailArchiveExecute(r ApiBCCEmailArchiveDeleteBCCEmailArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BCCEmailArchiveAPIService.BCCEmailArchiveDeleteBCCEmailArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/settings/bcc_email_archives/{bccEmailArchiveId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bccEmailArchiveId"+"}", url.PathEscape(parameterValueToString(r.bccEmailArchiveId, "bccEmailArchiveId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBCCEmailArchiveGetBCCEmailArchiveHistoryListRequest struct {
	ctx context.Context
	ApiService *BCCEmailArchiveAPIService
	accountId string
	bccEmailArchiveId string
	count *string
	startPosition *string
}

// The maximum number of results to return.  Use &#x60;start_position&#x60; to specify the number of items to skip. 
func (r ApiBCCEmailArchiveGetBCCEmailArchiveHistoryListRequest) Count(count string) ApiBCCEmailArchiveGetBCCEmailArchiveHistoryListRequest {
	r.count = &count
	return r
}

// The zero-based index of the result from which to start returning results.  Use with &#x60;count&#x60; to limit the number of results.  The default value is &#x60;0&#x60;. 
func (r ApiBCCEmailArchiveGetBCCEmailArchiveHistoryListRequest) StartPosition(startPosition string) ApiBCCEmailArchiveGetBCCEmailArchiveHistoryListRequest {
	r.startPosition = &startPosition
	return r
}

func (r ApiBCCEmailArchiveGetBCCEmailArchiveHistoryListRequest) Execute() (*BccEmailArchiveHistoryList, *http.Response, error) {
	return r.ApiService.BCCEmailArchiveGetBCCEmailArchiveHistoryListExecute(r)
}

/*
BCCEmailArchiveGetBCCEmailArchiveHistoryList Gets a BCC email archive configuration and its history.

This method returns a specific BCC email archive configuration for an account, as well as the history of changes to the email address.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @param bccEmailArchiveId The ID of the BCC email archive configuration.
 @return ApiBCCEmailArchiveGetBCCEmailArchiveHistoryListRequest
*/
func (a *BCCEmailArchiveAPIService) BCCEmailArchiveGetBCCEmailArchiveHistoryList(ctx context.Context, accountId string, bccEmailArchiveId string) ApiBCCEmailArchiveGetBCCEmailArchiveHistoryListRequest {
	return ApiBCCEmailArchiveGetBCCEmailArchiveHistoryListRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		bccEmailArchiveId: bccEmailArchiveId,
	}
}

// Execute executes the request
//  @return BccEmailArchiveHistoryList
func (a *BCCEmailArchiveAPIService) BCCEmailArchiveGetBCCEmailArchiveHistoryListExecute(r ApiBCCEmailArchiveGetBCCEmailArchiveHistoryListRequest) (*BccEmailArchiveHistoryList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BccEmailArchiveHistoryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BCCEmailArchiveAPIService.BCCEmailArchiveGetBCCEmailArchiveHistoryList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/settings/bcc_email_archives/{bccEmailArchiveId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bccEmailArchiveId"+"}", url.PathEscape(parameterValueToString(r.bccEmailArchiveId, "bccEmailArchiveId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBCCEmailArchiveGetBCCEmailArchiveListRequest struct {
	ctx context.Context
	ApiService *BCCEmailArchiveAPIService
	accountId string
	count *string
	startPosition *string
}

// The maximum number of results to return.  Use &#x60;start_position&#x60; to specify the number of results to skip. 
func (r ApiBCCEmailArchiveGetBCCEmailArchiveListRequest) Count(count string) ApiBCCEmailArchiveGetBCCEmailArchiveListRequest {
	r.count = &count
	return r
}

// The zero-based index of the result from which to start returning results.  Use with &#x60;count&#x60; to limit the number of results.  The default value is &#x60;0&#x60;. 
func (r ApiBCCEmailArchiveGetBCCEmailArchiveListRequest) StartPosition(startPosition string) ApiBCCEmailArchiveGetBCCEmailArchiveListRequest {
	r.startPosition = &startPosition
	return r
}

func (r ApiBCCEmailArchiveGetBCCEmailArchiveListRequest) Execute() (*BccEmailArchiveList, *http.Response, error) {
	return r.ApiService.BCCEmailArchiveGetBCCEmailArchiveListExecute(r)
}

/*
BCCEmailArchiveGetBCCEmailArchiveList Gets the BCC email archive configurations for an account.

This method retrieves all of the BCC email archive configurations associated with an account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiBCCEmailArchiveGetBCCEmailArchiveListRequest
*/
func (a *BCCEmailArchiveAPIService) BCCEmailArchiveGetBCCEmailArchiveList(ctx context.Context, accountId string) ApiBCCEmailArchiveGetBCCEmailArchiveListRequest {
	return ApiBCCEmailArchiveGetBCCEmailArchiveListRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return BccEmailArchiveList
func (a *BCCEmailArchiveAPIService) BCCEmailArchiveGetBCCEmailArchiveListExecute(r ApiBCCEmailArchiveGetBCCEmailArchiveListRequest) (*BccEmailArchiveList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BccEmailArchiveList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BCCEmailArchiveAPIService.BCCEmailArchiveGetBCCEmailArchiveList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/settings/bcc_email_archives"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.startPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_position", r.startPosition, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBCCEmailArchivePostBCCEmailArchiveRequest struct {
	ctx context.Context
	ApiService *BCCEmailArchiveAPIService
	accountId string
	bccEmailArchive *BccEmailArchive
}

// Boolean that specifies whether BCC for Email Archive is enabled for the account. BCC for Email Archive allows you to set up an archive email address so that a BCC copy of an envelope is sent only to that address.
func (r ApiBCCEmailArchivePostBCCEmailArchiveRequest) BccEmailArchive(bccEmailArchive BccEmailArchive) ApiBCCEmailArchivePostBCCEmailArchiveRequest {
	r.bccEmailArchive = &bccEmailArchive
	return r
}

func (r ApiBCCEmailArchivePostBCCEmailArchiveRequest) Execute() (*BccEmailArchive, *http.Response, error) {
	return r.ApiService.BCCEmailArchivePostBCCEmailArchiveExecute(r)
}

/*
BCCEmailArchivePostBCCEmailArchive Creates a BCC email archive configuration.

This method creates a BCC email archive configuration for an account (adds a BCC email address to the account for archiving the emails that DocuSign generates).

The only property that you must set in the request body is the BCC email address that you want to use.

**Note:** An account can have up to five active and pending email archive addresses combined, but you must use this method to add them to the account one at a time. Each email address is considered a separate BCC email archive configuration.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The external account number (int) or account ID GUID.
 @return ApiBCCEmailArchivePostBCCEmailArchiveRequest
*/
func (a *BCCEmailArchiveAPIService) BCCEmailArchivePostBCCEmailArchive(ctx context.Context, accountId string) ApiBCCEmailArchivePostBCCEmailArchiveRequest {
	return ApiBCCEmailArchivePostBCCEmailArchiveRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return BccEmailArchive
func (a *BCCEmailArchiveAPIService) BCCEmailArchivePostBCCEmailArchiveExecute(r ApiBCCEmailArchivePostBCCEmailArchiveRequest) (*BccEmailArchive, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BccEmailArchive
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BCCEmailArchiveAPIService.BCCEmailArchivePostBCCEmailArchive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.1/accounts/{accountId}/settings/bcc_email_archives"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bccEmailArchive
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
