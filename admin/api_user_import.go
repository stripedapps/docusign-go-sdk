/*
DocuSign Admin API

An API for an organization administrator to manage organizations, accounts and users

API version: v2.1
Contact: devcenter@docusign.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// UserImportAPIService UserImportAPI service
type UserImportAPIService service

type ApiOrganizationImportOrganizationImportUsersCloseRequest struct {
	ctx context.Context
	ApiService *UserImportAPIService
	organizationId string
	fileCsv *os.File
}

// CSV file.
func (r ApiOrganizationImportOrganizationImportUsersCloseRequest) FileCsv(fileCsv *os.File) ApiOrganizationImportOrganizationImportUsersCloseRequest {
	r.fileCsv = fileCsv
	return r
}

func (r ApiOrganizationImportOrganizationImportUsersCloseRequest) Execute() (*OrganizationImportResponse, *http.Response, error) {
	return r.ApiService.OrganizationImportOrganizationImportUsersCloseExecute(r)
}

/*
OrganizationImportOrganizationImportUsersClose Creates a request to close the accounts of existing users.

Creates a request to close the accounts of existing users.

Given a CSV list of users, close their accounts.

Your CSV import file is made up of a header row with the column headers and a row of user or account data for each user whose account you want to close.

To ensure your CSV is properly formatted, use the
[Sample Bulk Update CSV file](https://admin.docusign.com/static-resources/organization-user-update-import.csv)
 as a template. The following table describes the columns.




| Column              | Required | Description                                                                                                                                                                                                                                                                                                                                                                                                         |
| :------------------ | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| AccountID           | yes      | The 32-character API account ID of the user's account in your organization. You can find this value in the API and Keys section of the Admin area of the account.                                                                                                                                                                                                                                                             |
| AccountName         |          | The name of the user's account in your organization. The account name must match the account ID provided.                                                                                                                                                                                                                                                                                                           |
| FirstName           | yes      | The user's first name.                                                                                                                                                                                                                                                                                                                                                                                              |
| LastName            | yes      | The user's last name.                                                                                                                                                                                                                                                                                                                                                                                               |
| UserEmail           | yes      | The user's complete email address.                                                                                                                                                                                                                                                                                                                                                                                  |
| PermissionSet       | yes      | The user's permission set. The PermissionSet value must match an existing permission set for the account. This value is not case sensitive.                                                                                                                                                                                                                                                                         |

[Required authentication scopes](/docs/admin-api/admin101/auth/): `user_write`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId The organization ID Guid
 @return ApiOrganizationImportOrganizationImportUsersCloseRequest
*/
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersClose(ctx context.Context, organizationId string) ApiOrganizationImportOrganizationImportUsersCloseRequest {
	return ApiOrganizationImportOrganizationImportUsersCloseRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return OrganizationImportResponse
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersCloseExecute(r ApiOrganizationImportOrganizationImportUsersCloseRequest) (*OrganizationImportResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationImportResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserImportAPIService.OrganizationImportOrganizationImportUsersClose")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/organizations/{organizationId}/imports/bulk_users/close"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileCsv == nil {
		return localVarReturnValue, nil, reportError("fileCsv is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileCsvLocalVarFormFileName string
	var fileCsvLocalVarFileName     string
	var fileCsvLocalVarFileBytes    []byte

	fileCsvLocalVarFormFileName = "file.csv"


	fileCsvLocalVarFile := r.fileCsv

	if fileCsvLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileCsvLocalVarFile)

		fileCsvLocalVarFileBytes = fbs
		fileCsvLocalVarFileName = fileCsvLocalVarFile.Name()
		fileCsvLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileCsvLocalVarFileBytes, fileName: fileCsvLocalVarFileName, formFileName: fileCsvLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationImportOrganizationImportUsersCloseExternalRequest struct {
	ctx context.Context
	ApiService *UserImportAPIService
	organizationId string
}

func (r ApiOrganizationImportOrganizationImportUsersCloseExternalRequest) Execute() (*OrganizationImportResponse, *http.Response, error) {
	return r.ApiService.OrganizationImportOrganizationImportUsersCloseExternalExecute(r)
}

/*
OrganizationImportOrganizationImportUsersCloseExternal Closes external memberships.

Closes external memberships.

External memberships are users who have an email address at a verified domain but do not belong to the organization.

[Required authentication scopes](/docs/admin-api/admin101/auth/): `user_write`.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId The organization ID Guid
 @return ApiOrganizationImportOrganizationImportUsersCloseExternalRequest
*/
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersCloseExternal(ctx context.Context, organizationId string) ApiOrganizationImportOrganizationImportUsersCloseExternalRequest {
	return ApiOrganizationImportOrganizationImportUsersCloseExternalRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return OrganizationImportResponse
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersCloseExternalExecute(r ApiOrganizationImportOrganizationImportUsersCloseExternalRequest) (*OrganizationImportResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationImportResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserImportAPIService.OrganizationImportOrganizationImportUsersCloseExternal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/organizations/{organizationId}/imports/bulk_users/close_external"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationImportOrganizationImportUsersDeleteByIdRequest struct {
	ctx context.Context
	ApiService *UserImportAPIService
	organizationId string
	importId string
}

func (r ApiOrganizationImportOrganizationImportUsersDeleteByIdRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.OrganizationImportOrganizationImportUsersDeleteByIdExecute(r)
}

/*
OrganizationImportOrganizationImportUsersDeleteById Deletes a specific user import request.

Deletes a specific import request and its results.

To delete a user, see [closeBulkUserImportRequest](/docs/admin-api/reference/bulkoperations/userimport/closebulkuserimportrequest/).

[Required authentication scopes](/docs/admin-api/admin101/auth/): `user_write`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId The organization ID Guid
 @param importId The import ID GUID for the request.
 @return ApiOrganizationImportOrganizationImportUsersDeleteByIdRequest
*/
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersDeleteById(ctx context.Context, organizationId string, importId string) ApiOrganizationImportOrganizationImportUsersDeleteByIdRequest {
	return ApiOrganizationImportOrganizationImportUsersDeleteByIdRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		importId: importId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersDeleteByIdExecute(r ApiOrganizationImportOrganizationImportUsersDeleteByIdRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserImportAPIService.OrganizationImportOrganizationImportUsersDeleteById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/organizations/{organizationId}/imports/bulk_users/{importId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"importId"+"}", url.PathEscape(parameterValueToString(r.importId, "importId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationImportOrganizationImportUsersGetRequest struct {
	ctx context.Context
	ApiService *UserImportAPIService
	organizationId string
}

func (r ApiOrganizationImportOrganizationImportUsersGetRequest) Execute() (*OrganizationImportsResponse, *http.Response, error) {
	return r.ApiService.OrganizationImportOrganizationImportUsersGetExecute(r)
}

/*
OrganizationImportOrganizationImportUsersGet Gets a list of all of the user import requests.

Gets a list of all of the user import requests.

[Required authentication scopes](/docs/admin-api/admin101/auth/): `user_read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId The organization ID Guid
 @return ApiOrganizationImportOrganizationImportUsersGetRequest
*/
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersGet(ctx context.Context, organizationId string) ApiOrganizationImportOrganizationImportUsersGetRequest {
	return ApiOrganizationImportOrganizationImportUsersGetRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return OrganizationImportsResponse
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersGetExecute(r ApiOrganizationImportOrganizationImportUsersGetRequest) (*OrganizationImportsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationImportsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserImportAPIService.OrganizationImportOrganizationImportUsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/organizations/{organizationId}/imports/bulk_users"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationImportOrganizationImportUsersGetByIdRequest struct {
	ctx context.Context
	ApiService *UserImportAPIService
	organizationId string
	importId string
}

func (r ApiOrganizationImportOrganizationImportUsersGetByIdRequest) Execute() (*OrganizationImportResponse, *http.Response, error) {
	return r.ApiService.OrganizationImportOrganizationImportUsersGetByIdExecute(r)
}

/*
OrganizationImportOrganizationImportUsersGetById Returns the details of a single user import request.

Returns the details of a single user import request.

Use this method to check the status of the request by looking at the `status` property of the response.
Once the status becomes `completed` (or fails), use this method to get the details.

To get a list of all of the user import requests, use `getBulkUserImportRequests`.

[Required authentication scopes](/docs/admin-api/admin101/auth/): `user_read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId The organization ID Guid
 @param importId The import ID GUID for the request.
 @return ApiOrganizationImportOrganizationImportUsersGetByIdRequest
*/
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersGetById(ctx context.Context, organizationId string, importId string) ApiOrganizationImportOrganizationImportUsersGetByIdRequest {
	return ApiOrganizationImportOrganizationImportUsersGetByIdRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		importId: importId,
	}
}

// Execute executes the request
//  @return OrganizationImportResponse
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersGetByIdExecute(r ApiOrganizationImportOrganizationImportUsersGetByIdRequest) (*OrganizationImportResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationImportResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserImportAPIService.OrganizationImportOrganizationImportUsersGetById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/organizations/{organizationId}/imports/bulk_users/{importId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"importId"+"}", url.PathEscape(parameterValueToString(r.importId, "importId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationImportOrganizationImportUsersGetCSVResultsRequest struct {
	ctx context.Context
	ApiService *UserImportAPIService
	organizationId string
	importId string
}

func (r ApiOrganizationImportOrganizationImportUsersGetCSVResultsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.OrganizationImportOrganizationImportUsersGetCSVResultsExecute(r)
}

/*
OrganizationImportOrganizationImportUsersGetCSVResults Given the ID of a user import request, return the CSV file that was imported.

Returns the contents of the CSV file
associated with a user import request.

The results have an additional column,
`ProcessingResults`,
that describes the results of importing that row.

[Required authentication scopes](/docs/admin-api/admin101/auth/): `user_read`.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId The organization ID Guid
 @param importId The import ID GUID for the request.
 @return ApiOrganizationImportOrganizationImportUsersGetCSVResultsRequest
*/
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersGetCSVResults(ctx context.Context, organizationId string, importId string) ApiOrganizationImportOrganizationImportUsersGetCSVResultsRequest {
	return ApiOrganizationImportOrganizationImportUsersGetCSVResultsRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		importId: importId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersGetCSVResultsExecute(r ApiOrganizationImportOrganizationImportUsersGetCSVResultsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserImportAPIService.OrganizationImportOrganizationImportUsersGetCSVResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/organizations/{organizationId}/imports/bulk_users/{importId}/results_csv"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"importId"+"}", url.PathEscape(parameterValueToString(r.importId, "importId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationImportOrganizationImportUsersInsertRequest struct {
	ctx context.Context
	ApiService *UserImportAPIService
	organizationId string
	fileCsv *os.File
}

// CSV file.
func (r ApiOrganizationImportOrganizationImportUsersInsertRequest) FileCsv(fileCsv *os.File) ApiOrganizationImportOrganizationImportUsersInsertRequest {
	r.fileCsv = fileCsv
	return r
}

func (r ApiOrganizationImportOrganizationImportUsersInsertRequest) Execute() (*OrganizationImportResponse, *http.Response, error) {
	return r.ApiService.OrganizationImportOrganizationImportUsersInsertExecute(r)
}

/*
OrganizationImportOrganizationImportUsersInsert Creates a request to import new users into an account.

Creates a request to import *new* users.

Your CSV import file is made up of a header row with the column headers and a row of user or account data for each user you want to add to an account. Only new users can be imported. Any changes to existing users will be ignored. To make changes to existing users, use [UserImport:updateBulkUserImports][imports].

To ensure your CSV is properly formatted, use the
[Sample Bulk Add CSV file](https://admin.docusign.com/static-resources/organization-user-import.csv)
 as a template. The following table describes the columns.



| Column              | Required | Description                                                                                                                                                                                                                                                                                                                                                                                                         |
| :------------------ | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| AccountID           | yes      | The API account ID for the account to which you want you add the user. You can find this ID in the Admin area for the account under **API and Keys.**                                                                                                                                                                                                                                                            |
| AccountName         |          | The name of the user's account in your organization. The account name must match the account ID provided.                                                                                                                                                                                                                                                                                                           |
| FirstName           | yes      | The user's first name.                                                                                                                                                                                                                                                                                                                                                                                              |
| LastName            | yes      | The user's last name.                                                                                                                                                                                                                                                                                                                                                                                               |
| UserEmail           | yes      | The user's complete email address.                                                                                                                                                                                                                                                                                                                                                                                  |
| PermissionSet       | yes      | The user's permission set. The PermissionSet value must match an existing permission set for the account. This value is not case sensitive.                                                                                                                                                                                                                                                                         |
| UserTitle           |          | The user's job title.                                                                                                                                                                                                                                                                                                                                                                                               |
| CompanyName         |          | The user's company name.                                                                                                                                                                                                                                                                                                                                                                                            |
| Group               |          | The user's assigned groups. The Group values must match existing Group names for the account. Additional Group columns can be added to the file to add users to more than one group. You do not need to add users to the Everyone group, since all new users are automatically added to that group.                                                                                                                 |
| AddressLine1        |          | The user's address, first line.                                                                                                                                                                                                                                                                                                                                                                                     |
| AddressLine2        |          | The user's address, second line.                                                                                                                                                                                                                                                                                                                                                                                    |
| City                |          | The user's city name.                                                                                                                                                                                                                                                                                                                                                                                               |
| StateRegionProvince |          | The user's regional location.                                                                                                                                                                                                                                                                                                                                                                                       |
| PostalCode          |          | The user's postal code.                                                                                                                                                                                                                                                                                                                                                                                             |
| Phone               |          | The user's phone number.                                                                                                                                                                                                                                                                                                                                                                                            |
| Language            |          | The user's display language for their DocuSign account. Must be one of: <ul><li>Chinese Simplified: <code>zh_CN</code></li><li>Chinese Traditional: <code>zh_TW</code></li><li>Dutch: <code>nl</code></li><li>English: <code>en</code></li><li>French: <code>fr</code></li><li>German: <code>de</code></li><li>Italian: <code>it</code></li><li>Japanese: <code>ja</code></li><li>Korean: <code>ko</code></li><li>Portuguese: <code>pt</code></li><li>Portuguese Brazil: <code>pt_BR</code></li><li>Russian: <code>ru</code></li><li>Spanish: <code>es</code></li></ul>                                                                                                                                                                                                                                                                                                                                                            |
| LoginPolicy         |          | The user's login policy. Valid values include the following: <ul> <li>Column left blank = The user is created with no policy assigned.</li> <li>FedAuthRequired = The user must log in with an Identity Provider.</li> <li>FedAuthBypass = The user may log in with an Identity Provider or their DocuSign username and password.</li> </ul> For more information on login policies, see [Setting User Login Policy](https://support.docusign.com/s/document-item?bundleId=rrf1583359212854&topicId=zah1583359147774.html). |
| AutoActivate        |          | For domain users, new users can be activated automatically for domain accounts using SSO by setting the value to **true.** The user is activated automatically once the import is complete. Memberships activated in this way do not receive an activation email.                                                                                                                                                   |


You can add up to 2,000 users to an account and include up to 50 accounts per import. The maximum number of users per import is 8,000.

[Required authentication scopes](/docs/admin-api/admin101/auth/): `user_write`.


[imports]: /docs/admin-api/reference/bulkoperations/userimport/updatebulkuserimports/


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId The organization ID Guid
 @return ApiOrganizationImportOrganizationImportUsersInsertRequest
*/
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersInsert(ctx context.Context, organizationId string) ApiOrganizationImportOrganizationImportUsersInsertRequest {
	return ApiOrganizationImportOrganizationImportUsersInsertRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return OrganizationImportResponse
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersInsertExecute(r ApiOrganizationImportOrganizationImportUsersInsertRequest) (*OrganizationImportResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationImportResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserImportAPIService.OrganizationImportOrganizationImportUsersInsert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/organizations/{organizationId}/imports/bulk_users/add"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileCsv == nil {
		return localVarReturnValue, nil, reportError("fileCsv is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileCsvLocalVarFormFileName string
	var fileCsvLocalVarFileName     string
	var fileCsvLocalVarFileBytes    []byte

	fileCsvLocalVarFormFileName = "file.csv"


	fileCsvLocalVarFile := r.fileCsv

	if fileCsvLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileCsvLocalVarFile)

		fileCsvLocalVarFileBytes = fbs
		fileCsvLocalVarFileName = fileCsvLocalVarFile.Name()
		fileCsvLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileCsvLocalVarFileBytes, fileName: fileCsvLocalVarFileName, formFileName: fileCsvLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrganizationImportOrganizationImportUsersUpdateRequest struct {
	ctx context.Context
	ApiService *UserImportAPIService
	organizationId string
	fileCsv *os.File
}

// CSV file.
func (r ApiOrganizationImportOrganizationImportUsersUpdateRequest) FileCsv(fileCsv *os.File) ApiOrganizationImportOrganizationImportUsersUpdateRequest {
	r.fileCsv = fileCsv
	return r
}

func (r ApiOrganizationImportOrganizationImportUsersUpdateRequest) Execute() (*OrganizationImportResponse, *http.Response, error) {
	return r.ApiService.OrganizationImportOrganizationImportUsersUpdateExecute(r)
}

/*
OrganizationImportOrganizationImportUsersUpdate Bulk updates information for existing users.

Bulk updates information for existing users.

Your CSV import file is made up of a header row with the column headers and a row of user or account data for each user you want to add to an account. 


**Update limit:** You can update up to 2,000 users on an account and include up to 50 accounts per import. The maximum number of updated users per import is 8,000.

This method requires the following HTTP headers:

| Header | Value |
| :--- |  :--- |
| Content-Type | `text/csv` |
| Content-Disposition |  `filename=filename.csv` |



To ensure your CSV is properly formatted, use the
[Sample Bulk Update CSV file](https://admin.docusign.com/static-resources/organization-user-update-import.csv)
 as a template. The following table describes the columns.

Note that the columns for bulk adding users and bulk update users are slightly different.
The update CSV file requires an `APIUserName` column, and does not have an `AutoActivate` column.



| Column              | Required | Description                                                                                                                                                                                                                                                                                                                                                                                                         |
| :------------------ | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| AccountID           | yes      | The 32-character API account ID of the user's account in your organization. You can find this value in the API and Keys section of the Admin area of the account.                                                                                                                                                                                                                                                             |
| AccountName         |          | The name of the user's account in your organization. The account name must match the account ID provided.                                                                                                                                                                                                                                                                                                           |
| FirstName           | yes      | The user's first name.                                                                                                                                                                                                                                                                                                                                                                                              |
| LastName            | yes      | The user's last name.                                                                                                                                                                                                                                                                                                                                                                                               |
| UserEmail           | yes      | The user's complete email address.                                                                                                                                                                                                                                                                                                                                                                                  |
| PermissionSet       | yes      | The user's permission set. The PermissionSet value must match an existing permission set for the account. This value is not case sensitive.                                                                                                                                                                                                                                                                         |
| UserTitle           |          | The user's job title.                                                                                                                                                                                                                                                                                                                                                                                               |
| CompanyName         |          | The user's company name.                                                                                                                                                                                                                                                                                                                                                                                            |
| Group               |          | The user's assigned groups. The Group values must match existing Group names for the account. Additional Group columns can be added to the file to add users to more than one group. You do not need to add users to the Everyone group, since all new users are automatically added to that group.                                                                                                                 |
| AddressLine1        |          | The user's address, first line.                                                                                                                                                                                                                                                                                                                                                                                     |
| AddressLine2        |          | The user's address, second line.                                                                                                                                                                                                                                                                                                                                                                                    |
| City                |          | The user's city name.                                                                                                                                                                                                                                                                                                                                                                                               |
| StateRegionProvince |          | The user's regional location.                                                                                                                                                                                                                                                                                                                                                                                       |
| PostalCode          |          | The user's postal code.                                                                                                                                                                                                                                                                                                                                                                                             |
| Phone               |          | The user's phone number.                                                                                                                                                                                                                                                                                                                                                                                            |
| Language            |          | The user's display language for their DocuSign account. Must be one of: <ul><li>Chinese Simplified: <code>zh_CN</code></li><li>Chinese Traditional: <code>zh_TW</code></li><li>Dutch: <code>nl</code></li><li>English: <code>en</code></li><li>French: <code>fr</code></li><li>German: <code>de</code></li><li>Italian: <code>it</code></li><li>Japanese: <code>ja</code></li><li>Korean: <code>ko</code></li><li>Portuguese: <code>pt</code></li><li>Portuguese Brazil: <code>pt_BR</code></li><li>Russian: <code>ru</code></li><li>Spanish: <code>es</code></li></ul>                                                                                                                                                                                                                                                                                                                                                            |
| LoginPolicy         |          | The user's login policy. Valid values include the following: <ul> <li>Column left blank = The user is created with no policy assigned.</li> <li>FedAuthRequired = The user must log in with an Identity Provider.</li> <li>FedAuthBypass = The user may log in with an Identity Provider or their DocuSign username and password.</li> </ul> For more information on login policies, see [Setting User Login Policy](https://support.docusign.com/s/document-item?bundleId=rrf1583359212854&topicId=zah1583359147774.html). |
| AutoActivate        |          | For domain users, new users can be activated automatically for domain accounts using SSO by setting the value to **true.** The user is activated automatically once the import is complete. Memberships activated in this way do not receive an activation email.                                                                                                                                                   |



## Updating user email addresses

Changing a user's email address should be done carefully. The user's email address is used to log in to DocuSign and receive documents to sign from others.
Once changed, existing documents that were sent or received:

- Will still appear in the user's documents list.
- Notifications about these documents will be sent to the new email address. If someone sends a new document to the old email address:
- DocuSign will send a notification to the old address.
- It will not appear in the documents list of the account.

This change of email address will be applied to all of the user's account memberships.

[Required authentication scopes](/docs/admin-api/admin101/auth/): `user_write`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId The organization ID Guid
 @return ApiOrganizationImportOrganizationImportUsersUpdateRequest
*/
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersUpdate(ctx context.Context, organizationId string) ApiOrganizationImportOrganizationImportUsersUpdateRequest {
	return ApiOrganizationImportOrganizationImportUsersUpdateRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return OrganizationImportResponse
func (a *UserImportAPIService) OrganizationImportOrganizationImportUsersUpdateExecute(r ApiOrganizationImportOrganizationImportUsersUpdateRequest) (*OrganizationImportResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationImportResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserImportAPIService.OrganizationImportOrganizationImportUsersUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/organizations/{organizationId}/imports/bulk_users/update"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileCsv == nil {
		return localVarReturnValue, nil, reportError("fileCsv is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileCsvLocalVarFormFileName string
	var fileCsvLocalVarFileName     string
	var fileCsvLocalVarFileBytes    []byte

	fileCsvLocalVarFormFileName = "file.csv"


	fileCsvLocalVarFile := r.fileCsv

	if fileCsvLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileCsvLocalVarFile)

		fileCsvLocalVarFileBytes = fbs
		fileCsvLocalVarFileName = fileCsvLocalVarFile.Name()
		fileCsvLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileCsvLocalVarFileBytes, fileName: fileCsvLocalVarFileName, formFileName: fileCsvLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
